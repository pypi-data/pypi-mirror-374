# Alternative Automated Release Pipeline using Personal Access Token
#
# This is an example workflow that uses a Personal Access Token instead of GITHUB_TOKEN
# Use this if the main workflow fails due to permission issues that can't be resolved
# with repository settings.
#
# To use this workflow:
# 1. Create a Personal Access Token with 'repo' and 'workflow' scopes
# 2. Add it as a repository secret named 'PERSONAL_ACCESS_TOKEN'
# 3. Rename this file to 'auto-release.yml' (replacing the existing one)

name: Automated Release Pipeline (PAT)

on:
  push:
    branches: [ main ]
    paths-ignore:
      - 'README.md'
      - 'docs/**'
      - '.gitignore'
      - 'LICENSE'

# Explicit permissions (still needed even with PAT)
permissions:
  contents: write
  actions: write
  packages: write
  pull-requests: write
  issues: write

env:
  PYTHON_VERSION: '3.11'

jobs:
  analyze-and-version:
    runs-on: ubuntu-latest
    outputs:
      should_release: ${{ steps.version_check.outputs.should_release }}
      version_type: ${{ steps.version_check.outputs.version_type }}
      new_version: ${{ steps.version_check.outputs.new_version }}
      current_version: ${{ steps.version_check.outputs.current_version }}

    steps:
    - uses: actions/checkout@v4
      with:
        fetch-depth: 0
        # Use Personal Access Token instead of GITHUB_TOKEN
        token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}
        persist-credentials: true

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Configure Git with PAT
      run: |
        git config --local user.email "41898282+github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        # Configure git to use the Personal Access Token
        git config --local url."https://x-access-token:${{ secrets.PERSONAL_ACCESS_TOKEN }}@github.com/".insteadOf "https://github.com/"

    - name: Set up Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy

    - name: Check Rust formatting
      run: cargo fmt --all -- --check

    - name: Run Rust linting
      run: cargo clippy --all-targets --all-features -- -D warnings

    - name: Analyze commits and determine version bump
      id: version_check
      run: |
        # Get current version
        CURRENT_VERSION=$(python scripts/get_version.py)
        echo "current_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
        echo "Current version: $CURRENT_VERSION"

        # Get commits since last tag
        LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
        if [ -z "$LAST_TAG" ]; then
          COMMITS=$(git log --oneline)
        else
          COMMITS=$(git log ${LAST_TAG}..HEAD --oneline)
        fi

        echo "Analyzing commits since $LAST_TAG:"
        echo "$COMMITS"

        # Determine version bump type based on commit messages
        VERSION_TYPE="none"

        # Check for breaking changes (major version)
        if echo "$COMMITS" | grep -qiE "(BREAKING CHANGE|breaking:|major:)"; then
          VERSION_TYPE="major"
        # Check for new features (minor version)
        elif echo "$COMMITS" | grep -qiE "(feat:|feature:|minor:)"; then
          VERSION_TYPE="minor"
        # Check for bug fixes and other changes (patch version)
        elif echo "$COMMITS" | grep -qiE "(fix:|patch:|chore:|docs:|style:|refactor:|perf:|test:)"; then
          VERSION_TYPE="patch"
        fi

        # Skip release if no relevant changes
        if [ "$VERSION_TYPE" = "none" ]; then
          echo "No version-relevant changes detected. Skipping release."
          echo "should_release=false" >> $GITHUB_OUTPUT
          echo "version_type=none" >> $GITHUB_OUTPUT
          echo "new_version=$CURRENT_VERSION" >> $GITHUB_OUTPUT
          exit 0
        fi

        echo "Determined version bump type: $VERSION_TYPE"
        echo "should_release=true" >> $GITHUB_OUTPUT
        echo "version_type=$VERSION_TYPE" >> $GITHUB_OUTPUT

        # Calculate new version
        python scripts/bump_version.py $VERSION_TYPE
        NEW_VERSION=$(python scripts/get_version.py)
        echo "new_version=$NEW_VERSION" >> $GITHUB_OUTPUT
        echo "New version will be: $NEW_VERSION"

    - name: Commit version changes
      if: steps.version_check.outputs.should_release == 'true'
      run: |
        # Check if there are changes to commit
        if git diff --staged --quiet && git diff --quiet; then
          echo "No changes to commit"
        else
          echo "Committing version changes..."
          git add -A
          git commit -m "chore: bump version to ${{ steps.version_check.outputs.new_version }} [skip ci]"

          # Push with retry logic using PAT
          for i in {1..3}; do
            if git push origin main; then
              echo "✅ Successfully pushed version bump commit"
              break
            else
              echo "❌ Push attempt $i failed, retrying in 5 seconds..."
              sleep 5
            fi

            if [ $i -eq 3 ]; then
              echo "❌ Failed to push after 3 attempts"
              echo "Token permissions: ${{ secrets.PERSONAL_ACCESS_TOKEN && 'PAT configured' || 'PAT missing' }}"
              exit 1
            fi
          done
        fi

    - name: Create and push tag
      if: steps.version_check.outputs.should_release == 'true'
      run: |
        TAG_NAME="v${{ steps.version_check.outputs.new_version }}"
        echo "Creating tag: $TAG_NAME"

        # Check if tag already exists
        if git tag -l | grep -q "^$TAG_NAME$"; then
          echo "⚠️  Tag $TAG_NAME already exists, skipping tag creation"
        else
          git tag "$TAG_NAME"
          echo "✅ Created tag: $TAG_NAME"

          # Push tag with retry logic using PAT
          for i in {1..3}; do
            if git push origin "$TAG_NAME"; then
              echo "✅ Successfully pushed tag: $TAG_NAME"
              break
            else
              echo "❌ Tag push attempt $i failed, retrying in 5 seconds..."
              sleep 5
            fi

            if [ $i -eq 3 ]; then
              echo "❌ Failed to push tag after 3 attempts"
              exit 1
            fi
          done
        fi

  # Rest of the workflow remains the same as the main auto-release.yml
  # (build-and-release, build-sdist, publish, create-release jobs)

  build-and-release:
    needs: analyze-and-version
    if: needs.analyze-and-version.outputs.should_release == 'true'
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, windows-latest, macos-latest]

    steps:
    - uses: actions/checkout@v4
      with:
        ref: v${{ needs.analyze-and-version.outputs.new_version }}
        token: ${{ secrets.PERSONAL_ACCESS_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v5
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: Set up Rust
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy

    - name: Check Rust formatting
      run: cargo fmt --all -- --check

    - name: Run Rust linting
      run: cargo clippy --all-targets --all-features -- -D warnings

    - name: Install maturin
      run: pip install maturin

    - name: Build wheels
      run: maturin build --release --out dist --find-interpreter

    - name: Upload wheels
      uses: actions/upload-artifact@v4
      with:
        name: wheels-${{ matrix.os }}
        path: dist/*.whl

  # Additional jobs would continue here...
  # This is a simplified example focusing on the permission fix
