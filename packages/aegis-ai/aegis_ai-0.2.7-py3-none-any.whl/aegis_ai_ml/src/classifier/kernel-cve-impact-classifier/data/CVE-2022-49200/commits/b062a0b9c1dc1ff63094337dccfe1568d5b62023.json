{
  "commit_hash": "b062a0b9c1dc1ff63094337dccfe1568d5b62023",
  "commit_url": "https://git.kernel.org/stable/c/b062a0b9c1dc1ff63094337dccfe1568d5b62023",
  "commit_details": "commit b062a0b9c1dc1ff63094337dccfe1568d5b62023\nAuthor:     Yake Yang <yake.yang@mediatek.com>\nAuthorDate: Thu Mar 17 07:15:19 2022 +0800\nCommit:     Marcel Holtmann <marcel@holtmann.org>\nCommitDate: Fri Mar 18 17:12:08 2022 +0100\n\n    Bluetooth: btmtksdio: Fix kernel oops in btmtksdio_interrupt\n    \n    Fix the following kernel oops in btmtksdio_interrrupt\n    \n    [   14.339134]  btmtksdio_interrupt+0x28/0x54\n    [   14.339139]  process_sdio_pending_irqs+0x68/0x1a0\n    [   14.339144]  sdio_irq_work+0x40/0x70\n    [   14.339154]  process_one_work+0x184/0x39c\n    [   14.339160]  worker_thread+0x228/0x3e8\n    [   14.339168]  kthread+0x148/0x3ac\n    [   14.339176]  ret_from_fork+0x10/0x30\n    \n    That happened because hdev->power_on is already called before\n    sdio_set_drvdata which btmtksdio_interrupt handler relies on is not\n    properly set up.\n    \n    The details are shown as the below: hci_register_dev would run\n    queue_work(hdev->req_workqueue, &hdev->power_on) as WQ_HIGHPRI\n    workqueue_struct to complete the power-on sequeunce and thus hci_power_on\n    may run before sdio_set_drvdata is done in btmtksdio_probe.\n    \n    The hci_dev_do_open in hci_power_on would initialize the device and enable\n    the interrupt and thus it is possible that btmtksdio_interrupt is being\n    called right before sdio_set_drvdata is filled out.\n    \n    When btmtksdio_interrupt is being called and sdio_set_drvdata is not filled\n    , the kernel oops is going to happen because btmtksdio_interrupt access an\n    uninitialized pointer.\n    \n    Fixes: 9aebfd4a2200 (\"Bluetooth: mediatek: add support for MediaTek MT7663S and MT7668S SDIO devices\")\n    Reviewed-by: Mark Chen <markyawenchen@gmail.com>\n    Co-developed-by: Sean Wang <sean.wang@mediatek.com>\n    Signed-off-by: Sean Wang <sean.wang@mediatek.com>\n    Signed-off-by: Yake Yang <yake.yang@mediatek.com>\n    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>\n",
  "patch_content": "commit b062a0b9c1dc1ff63094337dccfe1568d5b62023\nAuthor: Yake Yang <yake.yang@mediatek.com>\nDate:   Thu Mar 17 07:15:19 2022 +0800\n\n    Bluetooth: btmtksdio: Fix kernel oops in btmtksdio_interrupt\n    \n    Fix the following kernel oops in btmtksdio_interrrupt\n    \n    [   14.339134]  btmtksdio_interrupt+0x28/0x54\n    [   14.339139]  process_sdio_pending_irqs+0x68/0x1a0\n    [   14.339144]  sdio_irq_work+0x40/0x70\n    [   14.339154]  process_one_work+0x184/0x39c\n    [   14.339160]  worker_thread+0x228/0x3e8\n    [   14.339168]  kthread+0x148/0x3ac\n    [   14.339176]  ret_from_fork+0x10/0x30\n    \n    That happened because hdev->power_on is already called before\n    sdio_set_drvdata which btmtksdio_interrupt handler relies on is not\n    properly set up.\n    \n    The details are shown as the below: hci_register_dev would run\n    queue_work(hdev->req_workqueue, &hdev->power_on) as WQ_HIGHPRI\n    workqueue_struct to complete the power-on sequeunce and thus hci_power_on\n    may run before sdio_set_drvdata is done in btmtksdio_probe.\n    \n    The hci_dev_do_open in hci_power_on would initialize the device and enable\n    the interrupt and thus it is possible that btmtksdio_interrupt is being\n    called right before sdio_set_drvdata is filled out.\n    \n    When btmtksdio_interrupt is being called and sdio_set_drvdata is not filled\n    , the kernel oops is going to happen because btmtksdio_interrupt access an\n    uninitialized pointer.\n    \n    Fixes: 9aebfd4a2200 (\"Bluetooth: mediatek: add support for MediaTek MT7663S and MT7668S SDIO devices\")\n    Reviewed-by: Mark Chen <markyawenchen@gmail.com>\n    Co-developed-by: Sean Wang <sean.wang@mediatek.com>\n    Signed-off-by: Sean Wang <sean.wang@mediatek.com>\n    Signed-off-by: Yake Yang <yake.yang@mediatek.com>\n    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>\n\ndiff --git a/drivers/bluetooth/btmtksdio.c b/drivers/bluetooth/btmtksdio.c\nindex df3f9d090529..9644069cecbb 100644\n--- a/drivers/bluetooth/btmtksdio.c\n+++ b/drivers/bluetooth/btmtksdio.c\n@@ -1281,6 +1281,8 @@ static int btmtksdio_probe(struct sdio_func *func,\n \thdev->manufacturer = 70;\n \tset_bit(HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks);\n \n+\tsdio_set_drvdata(func, bdev);\n+\n \terr = hci_register_dev(hdev);\n \tif (err < 0) {\n \t\tdev_err(&func->dev, \"Can't register HCI device\\n\");\n@@ -1288,8 +1290,6 @@ static int btmtksdio_probe(struct sdio_func *func,\n \t\treturn err;\n \t}\n \n-\tsdio_set_drvdata(func, bdev);\n-\n \t/* pm_runtime_enable would be done after the firmware is being\n \t * downloaded because the core layer probably already enables\n \t * runtime PM for this func such as the case host->caps &\n",
  "changed_files": [
    "drivers/bluetooth/btmtksdio.c"
  ],
  "diff_stats": " drivers/bluetooth/btmtksdio.c | 4 ++--\n 1 file changed, 2 insertions(+), 2 deletions(-)\n"
}