{
  "commit_hash": "cbf937dcadfd571a434f8074d057b32cd14fbea5",
  "commit_url": "https://git.kernel.org/stable/c/cbf937dcadfd571a434f8074d057b32cd14fbea5",
  "commit_details": "commit cbf937dcadfd571a434f8074d057b32cd14fbea5\nAuthor:     Daniel Stodden <daniel.stodden@gmail.com>\nAuthorDate: Sun Dec 22 19:39:08 2024 -0800\nCommit:     Krzysztof Wilczy\u0144ski <kwilczynski@kernel.org>\nCommitDate: Thu Feb 20 10:05:56 2025 +0000\n\n    PCI/ASPM: Fix link state exit during switch upstream function removal\n    \n    Before 456d8aa37d0f (\"PCI/ASPM: Disable ASPM on MFD function removal to\n    avoid use-after-free\"), we would free the ASPM link only after the last\n    function on the bus pertaining to the given link was removed.\n    \n    That was too late. If function 0 is removed before sibling function,\n    link->downstream would point to free'd memory after.\n    \n    After above change, we freed the ASPM parent link state upon any function\n    removal on the bus pertaining to a given link.\n    \n    That is too early. If the link is to a PCIe switch with MFD on the upstream\n    port, then removing functions other than 0 first would free a link which\n    still remains parent_link to the remaining downstream ports.\n    \n    The resulting GPFs are especially frequent during hot-unplug, because\n    pciehp removes devices on the link bus in reverse order.\n    \n    On that switch, function 0 is the virtual P2P bridge to the internal bus.\n    Free exactly when function 0 is removed -- before the parent link is\n    obsolete, but after all subordinate links are gone.\n    \n    Link: https://lore.kernel.org/r/e12898835f25234561c9d7de4435590d957b85d9.1734924854.git.dns@arista.com\n    Fixes: 456d8aa37d0f (\"PCI/ASPM: Disable ASPM on MFD function removal to avoid use-after-free\")\n    Signed-off-by: Daniel Stodden <dns@arista.com>\n    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>\n    [kwilczynski: commit log]\n    Signed-off-by: Krzysztof Wilczy\u0144ski <kwilczynski@kernel.org>\n",
  "patch_content": "commit cbf937dcadfd571a434f8074d057b32cd14fbea5\nAuthor: Daniel Stodden <daniel.stodden@gmail.com>\nDate:   Sun Dec 22 19:39:08 2024 -0800\n\n    PCI/ASPM: Fix link state exit during switch upstream function removal\n    \n    Before 456d8aa37d0f (\"PCI/ASPM: Disable ASPM on MFD function removal to\n    avoid use-after-free\"), we would free the ASPM link only after the last\n    function on the bus pertaining to the given link was removed.\n    \n    That was too late. If function 0 is removed before sibling function,\n    link->downstream would point to free'd memory after.\n    \n    After above change, we freed the ASPM parent link state upon any function\n    removal on the bus pertaining to a given link.\n    \n    That is too early. If the link is to a PCIe switch with MFD on the upstream\n    port, then removing functions other than 0 first would free a link which\n    still remains parent_link to the remaining downstream ports.\n    \n    The resulting GPFs are especially frequent during hot-unplug, because\n    pciehp removes devices on the link bus in reverse order.\n    \n    On that switch, function 0 is the virtual P2P bridge to the internal bus.\n    Free exactly when function 0 is removed -- before the parent link is\n    obsolete, but after all subordinate links are gone.\n    \n    Link: https://lore.kernel.org/r/e12898835f25234561c9d7de4435590d957b85d9.1734924854.git.dns@arista.com\n    Fixes: 456d8aa37d0f (\"PCI/ASPM: Disable ASPM on MFD function removal to avoid use-after-free\")\n    Signed-off-by: Daniel Stodden <dns@arista.com>\n    Signed-off-by: Bjorn Helgaas <bhelgaas@google.com>\n    [kwilczynski: commit log]\n    Signed-off-by: Krzysztof Wilczy\u0144ski <kwilczynski@kernel.org>\n\ndiff --git a/drivers/pci/pcie/aspm.c b/drivers/pci/pcie/aspm.c\nindex e0bc90597dca..25954cc89bf3 100644\n--- a/drivers/pci/pcie/aspm.c\n+++ b/drivers/pci/pcie/aspm.c\n@@ -1273,16 +1273,16 @@ void pcie_aspm_exit_link_state(struct pci_dev *pdev)\n \tparent_link = link->parent;\n \n \t/*\n-\t * link->downstream is a pointer to the pci_dev of function 0.  If\n-\t * we remove that function, the pci_dev is about to be deallocated,\n-\t * so we can't use link->downstream again.  Free the link state to\n-\t * avoid this.\n+\t * Free the parent link state, no later than function 0 (i.e.\n+\t * link->downstream) being removed.\n \t *\n-\t * If we're removing a non-0 function, it's possible we could\n-\t * retain the link state, but PCIe r6.0, sec 7.5.3.7, recommends\n-\t * programming the same ASPM Control value for all functions of\n-\t * multi-function devices, so disable ASPM for all of them.\n+\t * Do not free the link state any earlier. If function 0 is a\n+\t * switch upstream port, this link state is parent_link to all\n+\t * subordinate ones.\n \t */\n+\tif (pdev != link->downstream)\n+\t\tgoto out;\n+\n \tpcie_config_aspm_link(link, 0);\n \tlist_del(&link->sibling);\n \tfree_link_state(link);\n@@ -1293,6 +1293,7 @@ void pcie_aspm_exit_link_state(struct pci_dev *pdev)\n \t\tpcie_config_aspm_path(parent_link);\n \t}\n \n+ out:\n \tmutex_unlock(&aspm_lock);\n \tup_read(&pci_bus_sem);\n }\n",
  "changed_files": [
    "drivers/pci/pcie/aspm.c"
  ],
  "diff_stats": " drivers/pci/pcie/aspm.c | 17 +++++++++--------\n 1 file changed, 9 insertions(+), 8 deletions(-)\n"
}