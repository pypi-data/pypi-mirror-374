{
  "commit_hash": "9aebfd4a2200ab8075e44379c758bccefdc589bb",
  "commit_url": "https://git.kernel.org/stable/c/9aebfd4a2200ab8075e44379c758bccefdc589bb",
  "commit_details": "commit 9aebfd4a2200ab8075e44379c758bccefdc589bb\nAuthor:     Sean Wang <sean.wang@mediatek.com>\nAuthorDate: Fri Mar 8 09:15:44 2019 +0800\nCommit:     Marcel Holtmann <marcel@holtmann.org>\nCommitDate: Tue Apr 23 18:09:07 2019 +0200\n\n    Bluetooth: mediatek: add support for MediaTek MT7663S and MT7668S SDIO devices\n    \n    This adds the support of enabling MT7663S and MT7668S SDIO-based\n    Bluetooth function.\n    \n    There are quite many differences between MT766[3,8]S and standard\n    Bluetooth SDIO devices such as Type-A and Type-B devices. For example,\n    MT766[3,8]S have its own SDIO registers layout, definition, SDIO packet\n    format, and the specific flow should be programmed on them to complete\n    the device initialization and low power control and so on.\n    \n    Currently, there are many independent programming sequences from the\n    transport which are exactly the same as the ones in btusb.c about MediaTek\n    support [1] and btmtkuart.c. We can try to split the transport independent\n    Bluetooth setups on the advance, place them into the common files and allow\n    varous transport drivers to reuse them in the future.\n    \n    [1] http://lists.infradead.org/pipermail/linux-mediatek/2019-January/017074.html\n    \n    Signed-off-by: Sean Wang <sean.wang@mediatek.com>\n    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>\n",
  "patch_content": "commit 9aebfd4a2200ab8075e44379c758bccefdc589bb\nAuthor: Sean Wang <sean.wang@mediatek.com>\nDate:   Fri Mar 8 09:15:44 2019 +0800\n\n    Bluetooth: mediatek: add support for MediaTek MT7663S and MT7668S SDIO devices\n    \n    This adds the support of enabling MT7663S and MT7668S SDIO-based\n    Bluetooth function.\n    \n    There are quite many differences between MT766[3,8]S and standard\n    Bluetooth SDIO devices such as Type-A and Type-B devices. For example,\n    MT766[3,8]S have its own SDIO registers layout, definition, SDIO packet\n    format, and the specific flow should be programmed on them to complete\n    the device initialization and low power control and so on.\n    \n    Currently, there are many independent programming sequences from the\n    transport which are exactly the same as the ones in btusb.c about MediaTek\n    support [1] and btmtkuart.c. We can try to split the transport independent\n    Bluetooth setups on the advance, place them into the common files and allow\n    varous transport drivers to reuse them in the future.\n    \n    [1] http://lists.infradead.org/pipermail/linux-mediatek/2019-January/017074.html\n    \n    Signed-off-by: Sean Wang <sean.wang@mediatek.com>\n    Signed-off-by: Marcel Holtmann <marcel@holtmann.org>\n\ndiff --git a/drivers/bluetooth/Kconfig b/drivers/bluetooth/Kconfig\nindex 7b2e76e7f22f..b0f9a20401d6 100644\n--- a/drivers/bluetooth/Kconfig\n+++ b/drivers/bluetooth/Kconfig\n@@ -379,6 +379,17 @@ config BT_WILINK\n \t  Say Y here to compile support for Texas Instrument's WiLink7 driver\n \t  into the kernel or say M to compile it as module (btwilink).\n \n+config BT_MTKSDIO\n+\ttristate \"MediaTek HCI SDIO driver\"\n+\tdepends on MMC\n+\thelp\n+\t  MediaTek Bluetooth HCI SDIO driver.\n+\t  This driver is required if you want to use MediaTek Bluetooth\n+\t  with SDIO interface.\n+\n+\t  Say Y here to compile support for MediaTek Bluetooth SDIO devices\n+\t  into the kernel or say M to compile it as module (btmtksdio).\n+\n config BT_MTKUART\n \ttristate \"MediaTek HCI UART driver\"\n \tdepends on SERIAL_DEV_BUS\ndiff --git a/drivers/bluetooth/Makefile b/drivers/bluetooth/Makefile\nindex b7e393cfc1e3..34887b9b3a85 100644\n--- a/drivers/bluetooth/Makefile\n+++ b/drivers/bluetooth/Makefile\n@@ -20,6 +20,7 @@ obj-$(CONFIG_BT_ATH3K)\t\t+= ath3k.o\n obj-$(CONFIG_BT_MRVL)\t\t+= btmrvl.o\n obj-$(CONFIG_BT_MRVL_SDIO)\t+= btmrvl_sdio.o\n obj-$(CONFIG_BT_WILINK)\t\t+= btwilink.o\n+obj-$(CONFIG_BT_MTKSDIO)\t+= btmtksdio.o\n obj-$(CONFIG_BT_MTKUART)\t+= btmtkuart.o\n obj-$(CONFIG_BT_QCOMSMD)\t+= btqcomsmd.o\n obj-$(CONFIG_BT_BCM)\t\t+= btbcm.o\ndiff --git a/drivers/bluetooth/btmtksdio.c b/drivers/bluetooth/btmtksdio.c\nnew file mode 100644\nindex 000000000000..b4b8320f279e\n--- /dev/null\n+++ b/drivers/bluetooth/btmtksdio.c\n@@ -0,0 +1,979 @@\n+// SPDX-License-Identifier: GPL-2.0\n+// Copyright (c) 2019 MediaTek Inc.\n+\n+/*\n+ * Bluetooth support for MediaTek SDIO devices\n+ *\n+ * This file is written based on btsdio.c and btmtkuart.c.\n+ *\n+ * Author: Sean Wang <sean.wang@mediatek.com>\n+ *\n+ */\n+\n+#include <asm/unaligned.h>\n+#include <linux/atomic.h>\n+#include <linux/firmware.h>\n+#include <linux/init.h>\n+#include <linux/iopoll.h>\n+#include <linux/kernel.h>\n+#include <linux/module.h>\n+#include <linux/skbuff.h>\n+\n+#include <linux/mmc/host.h>\n+#include <linux/mmc/sdio_ids.h>\n+#include <linux/mmc/sdio_func.h>\n+\n+#include <net/bluetooth/bluetooth.h>\n+#include <net/bluetooth/hci_core.h>\n+\n+#include \"h4_recv.h\"\n+\n+#define VERSION \"0.1\"\n+\n+#define FIRMWARE_MT7663\t\t\"mediatek/mt7663pr2h.bin\"\n+#define FIRMWARE_MT7668\t\t\"mediatek/mt7668pr2h.bin\"\n+\n+struct btmtksdio_data {\n+\tconst char *fwname;\n+};\n+\n+static const struct btmtksdio_data mt7663_data = {\n+\t.fwname = FIRMWARE_MT7663,\n+};\n+\n+static const struct btmtksdio_data mt7668_data = {\n+\t.fwname = FIRMWARE_MT7668,\n+};\n+\n+static const struct sdio_device_id btmtksdio_table[] = {\n+\t{SDIO_DEVICE(SDIO_VENDOR_ID_MEDIATEK, 0x7663),\n+\t .driver_data = (kernel_ulong_t)&mt7663_data },\n+\t{SDIO_DEVICE(SDIO_VENDOR_ID_MEDIATEK, 0x7668),\n+\t .driver_data = (kernel_ulong_t)&mt7668_data },\n+\t{ }\t/* Terminating entry */\n+};\n+\n+#define MTK_REG_CHLPCR\t\t0x4\t/* W1S */\n+#define C_INT_EN_SET\t\tBIT(0)\n+#define C_INT_EN_CLR\t\tBIT(1)\n+#define C_FW_OWN_REQ_SET\tBIT(8)\n+#define C_FW_OWN_REQ_CLR\tBIT(9)\n+\n+#define MTK_REG_CSDIOCSR\t0x8\n+#define SDIO_RE_INIT_EN\t\tBIT(0)\n+#define SDIO_INT_CTL\t\tBIT(2)\n+\n+#define MTK_REG_CHCR\t\t0xc\n+#define C_INT_CLR_CTRL\t\tBIT(1)\n+\n+/* CHISR have the same bits field definition with CHIER */\n+#define MTK_REG_CHISR\t\t0x10\n+#define MTK_REG_CHIER\t\t0x14\n+#define FW_OWN_BACK_INT\t\tBIT(0)\n+#define RX_DONE_INT\t\tBIT(1)\n+#define TX_EMPTY\t\tBIT(2)\n+#define TX_FIFO_OVERFLOW\tBIT(8)\n+#define RX_PKT_LEN\t\tGENMASK(31, 16)\n+\n+#define MTK_REG_CTDR\t\t0x18\n+\n+#define MTK_REG_CRDR\t\t0x1c\n+\n+#define MTK_SDIO_BLOCK_SIZE\t256\n+\n+#define BTMTKSDIO_TX_WAIT_VND_EVT\t1\n+\n+enum {\n+\tMTK_WMT_PATCH_DWNLD = 0x1,\n+\tMTK_WMT_TEST = 0x2,\n+\tMTK_WMT_WAKEUP = 0x3,\n+\tMTK_WMT_HIF = 0x4,\n+\tMTK_WMT_FUNC_CTRL = 0x6,\n+\tMTK_WMT_RST = 0x7,\n+\tMTK_WMT_SEMAPHORE = 0x17,\n+};\n+\n+enum {\n+\tBTMTK_WMT_INVALID,\n+\tBTMTK_WMT_PATCH_UNDONE,\n+\tBTMTK_WMT_PATCH_DONE,\n+\tBTMTK_WMT_ON_UNDONE,\n+\tBTMTK_WMT_ON_DONE,\n+\tBTMTK_WMT_ON_PROGRESS,\n+};\n+\n+struct mtkbtsdio_hdr {\n+\t__le16\tlen;\n+\t__le16\treserved;\n+\tu8\tbt_type;\n+} __packed;\n+\n+struct mtk_wmt_hdr {\n+\tu8\tdir;\n+\tu8\top;\n+\t__le16\tdlen;\n+\tu8\tflag;\n+} __packed;\n+\n+struct mtk_hci_wmt_cmd {\n+\tstruct mtk_wmt_hdr hdr;\n+\tu8 data[256];\n+} __packed;\n+\n+struct btmtk_hci_wmt_evt {\n+\tstruct hci_event_hdr hhdr;\n+\tstruct mtk_wmt_hdr whdr;\n+} __packed;\n+\n+struct btmtk_hci_wmt_evt_funcc {\n+\tstruct btmtk_hci_wmt_evt hwhdr;\n+\t__be16 status;\n+} __packed;\n+\n+struct btmtk_tci_sleep {\n+\tu8 mode;\n+\t__le16 duration;\n+\t__le16 host_duration;\n+\tu8 host_wakeup_pin;\n+\tu8 time_compensation;\n+} __packed;\n+\n+struct btmtk_hci_wmt_params {\n+\tu8 op;\n+\tu8 flag;\n+\tu16 dlen;\n+\tconst void *data;\n+\tu32 *status;\n+};\n+\n+struct btmtksdio_dev {\n+\tstruct hci_dev *hdev;\n+\tstruct sdio_func *func;\n+\n+\tstruct work_struct tx_work;\n+\tunsigned long tx_state;\n+\tstruct sk_buff_head txq;\n+\n+\tstruct sk_buff *evt_skb;\n+\n+\tconst struct btmtksdio_data *data;\n+};\n+\n+static int mtk_hci_wmt_sync(struct hci_dev *hdev,\n+\t\t\t    struct btmtk_hci_wmt_params *wmt_params)\n+{\n+\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n+\tstruct btmtk_hci_wmt_evt_funcc *wmt_evt_funcc;\n+\tu32 hlen, status = BTMTK_WMT_INVALID;\n+\tstruct btmtk_hci_wmt_evt *wmt_evt;\n+\tstruct mtk_hci_wmt_cmd wc;\n+\tstruct mtk_wmt_hdr *hdr;\n+\tint err;\n+\n+\thlen = sizeof(*hdr) + wmt_params->dlen;\n+\tif (hlen > 255)\n+\t\treturn -EINVAL;\n+\n+\thdr = (struct mtk_wmt_hdr *)&wc;\n+\thdr->dir = 1;\n+\thdr->op = wmt_params->op;\n+\thdr->dlen = cpu_to_le16(wmt_params->dlen + 1);\n+\thdr->flag = wmt_params->flag;\n+\tmemcpy(wc.data, wmt_params->data, wmt_params->dlen);\n+\n+\tset_bit(BTMTKSDIO_TX_WAIT_VND_EVT, &bdev->tx_state);\n+\n+\terr = __hci_cmd_send(hdev, 0xfc6f, hlen, &wc);\n+\tif (err < 0) {\n+\t\tclear_bit(BTMTKSDIO_TX_WAIT_VND_EVT, &bdev->tx_state);\n+\t\treturn err;\n+\t}\n+\n+\t/* The vendor specific WMT commands are all answered by a vendor\n+\t * specific event and will not have the Command Status or Command\n+\t * Complete as with usual HCI command flow control.\n+\t *\n+\t * After sending the command, wait for BTMTKSDIO_TX_WAIT_VND_EVT\n+\t * state to be cleared. The driver specific event receive routine\n+\t * will clear that state and with that indicate completion of the\n+\t * WMT command.\n+\t */\n+\terr = wait_on_bit_timeout(&bdev->tx_state, BTMTKSDIO_TX_WAIT_VND_EVT,\n+\t\t\t\t  TASK_INTERRUPTIBLE, HCI_INIT_TIMEOUT);\n+\tif (err == -EINTR) {\n+\t\tbt_dev_err(hdev, \"Execution of wmt command interrupted\");\n+\t\tclear_bit(BTMTKSDIO_TX_WAIT_VND_EVT, &bdev->tx_state);\n+\t\treturn err;\n+\t}\n+\n+\tif (err) {\n+\t\tbt_dev_err(hdev, \"Execution of wmt command timed out\");\n+\t\tclear_bit(BTMTKSDIO_TX_WAIT_VND_EVT, &bdev->tx_state);\n+\t\treturn -ETIMEDOUT;\n+\t}\n+\n+\t/* Parse and handle the return WMT event */\n+\twmt_evt = (struct btmtk_hci_wmt_evt *)bdev->evt_skb->data;\n+\tif (wmt_evt->whdr.op != hdr->op) {\n+\t\tbt_dev_err(hdev, \"Wrong op received %d expected %d\",\n+\t\t\t   wmt_evt->whdr.op, hdr->op);\n+\t\terr = -EIO;\n+\t\tgoto err_free_skb;\n+\t}\n+\n+\tswitch (wmt_evt->whdr.op) {\n+\tcase MTK_WMT_SEMAPHORE:\n+\t\tif (wmt_evt->whdr.flag == 2)\n+\t\t\tstatus = BTMTK_WMT_PATCH_UNDONE;\n+\t\telse\n+\t\t\tstatus = BTMTK_WMT_PATCH_DONE;\n+\t\tbreak;\n+\tcase MTK_WMT_FUNC_CTRL:\n+\t\twmt_evt_funcc = (struct btmtk_hci_wmt_evt_funcc *)wmt_evt;\n+\t\tif (be16_to_cpu(wmt_evt_funcc->status) == 0x404)\n+\t\t\tstatus = BTMTK_WMT_ON_DONE;\n+\t\telse if (be16_to_cpu(wmt_evt_funcc->status) == 0x420)\n+\t\t\tstatus = BTMTK_WMT_ON_PROGRESS;\n+\t\telse\n+\t\t\tstatus = BTMTK_WMT_ON_UNDONE;\n+\t\tbreak;\n+\t}\n+\n+\tif (wmt_params->status)\n+\t\t*wmt_params->status = status;\n+\n+err_free_skb:\n+\tkfree_skb(bdev->evt_skb);\n+\tbdev->evt_skb = NULL;\n+\n+\treturn err;\n+}\n+\n+static int btmtksdio_tx_packet(struct btmtksdio_dev *bdev,\n+\t\t\t       struct sk_buff *skb)\n+{\n+\tstruct mtkbtsdio_hdr *sdio_hdr;\n+\tint err;\n+\n+\t/* Make sure that there are enough rooms for SDIO header */\n+\tif (unlikely(skb_headroom(skb) < sizeof(*sdio_hdr))) {\n+\t\terr = pskb_expand_head(skb, sizeof(*sdio_hdr), 0,\n+\t\t\t\t       GFP_ATOMIC);\n+\t\tif (err < 0)\n+\t\t\treturn err;\n+\t}\n+\n+\t/* Prepend MediaTek SDIO Specific Header */\n+\tskb_push(skb, sizeof(*sdio_hdr));\n+\n+\tsdio_hdr = (void *)skb->data;\n+\tsdio_hdr->len = cpu_to_le16(skb->len);\n+\tsdio_hdr->reserved = cpu_to_le16(0);\n+\tsdio_hdr->bt_type = hci_skb_pkt_type(skb);\n+\n+\terr = sdio_writesb(bdev->func, MTK_REG_CTDR, skb->data,\n+\t\t\t   round_up(skb->len, MTK_SDIO_BLOCK_SIZE));\n+\tif (err < 0)\n+\t\tgoto err_skb_pull;\n+\n+\tbdev->hdev->stat.byte_tx += skb->len;\n+\n+\tkfree_skb(skb);\n+\n+\treturn 0;\n+\n+err_skb_pull:\n+\tskb_pull(skb, sizeof(*sdio_hdr));\n+\n+\treturn err;\n+}\n+\n+static u32 btmtksdio_drv_own_query(struct btmtksdio_dev *bdev)\n+{\n+\treturn sdio_readl(bdev->func, MTK_REG_CHLPCR, NULL);\n+}\n+\n+static void btmtksdio_tx_work(struct work_struct *work)\n+{\n+\tstruct btmtksdio_dev *bdev = container_of(work, struct btmtksdio_dev,\n+\t\t\t\t\t\t  tx_work);\n+\tstruct sk_buff *skb;\n+\tint err;\n+\n+\tsdio_claim_host(bdev->func);\n+\n+\twhile ((skb = skb_dequeue(&bdev->txq))) {\n+\t\terr = btmtksdio_tx_packet(bdev, skb);\n+\t\tif (err < 0) {\n+\t\t\tbdev->hdev->stat.err_tx++;\n+\t\t\tskb_queue_head(&bdev->txq, skb);\n+\t\t\tbreak;\n+\t\t}\n+\t}\n+\n+\tsdio_release_host(bdev->func);\n+}\n+\n+static int btmtksdio_recv_event(struct hci_dev *hdev, struct sk_buff *skb)\n+{\n+\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n+\tstruct hci_event_hdr *hdr = (void *)skb->data;\n+\tint err;\n+\n+\t/* Fix up the vendor event id with 0xff for vendor specific instead\n+\t * of 0xe4 so that event send via monitoring socket can be parsed\n+\t * properly.\n+\t */\n+\tif (hdr->evt == 0xe4)\n+\t\thdr->evt = HCI_EV_VENDOR;\n+\n+\t/* When someone waits for the WMT event, the skb is being cloned\n+\t * and being processed the events from there then.\n+\t */\n+\tif (test_bit(BTMTKSDIO_TX_WAIT_VND_EVT, &bdev->tx_state)) {\n+\t\tbdev->evt_skb = skb_clone(skb, GFP_KERNEL);\n+\t\tif (!bdev->evt_skb) {\n+\t\t\terr = -ENOMEM;\n+\t\t\tgoto err_out;\n+\t\t}\n+\t}\n+\n+\terr = hci_recv_frame(hdev, skb);\n+\tif (err < 0)\n+\t\tgoto err_free_skb;\n+\n+\tif (hdr->evt == HCI_EV_VENDOR) {\n+\t\tif (test_and_clear_bit(BTMTKSDIO_TX_WAIT_VND_EVT,\n+\t\t\t\t       &bdev->tx_state)) {\n+\t\t\t/* Barrier to sync with other CPUs */\n+\t\t\tsmp_mb__after_atomic();\n+\t\t\twake_up_bit(&bdev->tx_state, BTMTKSDIO_TX_WAIT_VND_EVT);\n+\t\t}\n+\t}\n+\n+\treturn 0;\n+\n+err_free_skb:\n+\tkfree_skb(bdev->evt_skb);\n+\tbdev->evt_skb = NULL;\n+\n+err_out:\n+\treturn err;\n+}\n+\n+static const struct h4_recv_pkt mtk_recv_pkts[] = {\n+\t{ H4_RECV_ACL,      .recv = hci_recv_frame },\n+\t{ H4_RECV_SCO,      .recv = hci_recv_frame },\n+\t{ H4_RECV_EVENT,    .recv = btmtksdio_recv_event },\n+};\n+\n+static int btmtksdio_rx_packet(struct btmtksdio_dev *bdev, u16 rx_size)\n+{\n+\tconst struct h4_recv_pkt *pkts = mtk_recv_pkts;\n+\tint pkts_count = ARRAY_SIZE(mtk_recv_pkts);\n+\tstruct mtkbtsdio_hdr *sdio_hdr;\n+\tunsigned char *old_data;\n+\tunsigned int old_len;\n+\tint err, i, pad_size;\n+\tstruct sk_buff *skb;\n+\tu16 dlen;\n+\n+\tif (rx_size < sizeof(*sdio_hdr))\n+\t\treturn -EILSEQ;\n+\n+\t/* A SDIO packet is exactly containing a Bluetooth packet */\n+\tskb = bt_skb_alloc(rx_size, GFP_KERNEL);\n+\tif (!skb)\n+\t\treturn -ENOMEM;\n+\n+\tskb_put(skb, rx_size);\n+\n+\terr = sdio_readsb(bdev->func, skb->data, MTK_REG_CRDR, rx_size);\n+\tif (err < 0)\n+\t\tgoto err_kfree_skb;\n+\n+\t/* Keep old data for dump the content in case of some error is\n+\t * caught in the following packet parsing.\n+\t */\n+\told_data = skb->data;\n+\told_len = skb->len;\n+\n+\tbdev->hdev->stat.byte_rx += rx_size;\n+\n+\tsdio_hdr = (void *)skb->data;\n+\n+\t/* We assume the default error as -EILSEQ simply to make the error path\n+\t * be cleaner.\n+\t */\n+\terr = -EILSEQ;\n+\n+\tif (rx_size != le16_to_cpu(sdio_hdr->len)) {\n+\t\tbt_dev_err(bdev->hdev, \"Rx size in sdio header is mismatched \");\n+\t\tgoto err_kfree_skb;\n+\t}\n+\n+\thci_skb_pkt_type(skb) = sdio_hdr->bt_type;\n+\n+\t/* Remove MediaTek SDIO header */\n+\tskb_pull(skb, sizeof(*sdio_hdr));\n+\n+\t/* We have to dig into the packet to get payload size and then know how\n+\t * many padding bytes at the tail, these padding bytes should be removed\n+\t * before the packet is indicated to the core layer.\n+\t */\n+\tfor (i = 0; i < pkts_count; i++) {\n+\t\tif (sdio_hdr->bt_type == (&pkts[i])->type)\n+\t\t\tbreak;\n+\t}\n+\n+\tif (i >= pkts_count) {\n+\t\tbt_dev_err(bdev->hdev, \"Invalid bt type 0x%02x\",\n+\t\t\t   sdio_hdr->bt_type);\n+\t\tgoto err_kfree_skb;\n+\t}\n+\n+\t/* Remaining bytes cannot hold a header*/\n+\tif (skb->len < (&pkts[i])->hlen) {\n+\t\tbt_dev_err(bdev->hdev, \"The size of bt header is mismatched\");\n+\t\tgoto err_kfree_skb;\n+\t}\n+\n+\tswitch ((&pkts[i])->lsize) {\n+\t\tcase 1:\n+\t\t\tdlen = skb->data[(&pkts[i])->loff];\n+\t\t\tbreak;\n+\t\tcase 2:\n+\t\t\tdlen = get_unaligned_le16(skb->data +\n+\t\t\t\t\t\t  (&pkts[i])->loff);\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tgoto err_kfree_skb;\n+\t}\n+\n+\tpad_size = skb->len - (&pkts[i])->hlen -  dlen;\n+\n+\t/* Remaining bytes cannot hold a payload */\n+\tif (pad_size < 0) {\n+\t\tbt_dev_err(bdev->hdev, \"The size of bt payload is mismatched\");\n+\t\tgoto err_kfree_skb;\n+\t}\n+\n+\t/* Remove padding bytes */\n+\tskb_trim(skb, skb->len - pad_size);\n+\n+\t/* Complete frame */\n+\t(&pkts[i])->recv(bdev->hdev, skb);\n+\n+\treturn 0;\n+\n+err_kfree_skb:\n+\tprint_hex_dump(KERN_ERR, \"err sdio rx: \", DUMP_PREFIX_NONE, 4, 1,\n+\t\t       old_data, old_len, true);\n+\tkfree_skb(skb);\n+\n+\treturn err;\n+}\n+\n+static void btmtksdio_interrupt(struct sdio_func *func)\n+{\n+\tstruct btmtksdio_dev *bdev = sdio_get_drvdata(func);\n+\tu32 int_status;\n+\tu16 rx_size;\n+\n+\t/* Disable interrupt */\n+\tsdio_writel(func, C_INT_EN_CLR, MTK_REG_CHLPCR, 0);\n+\n+\tint_status = sdio_readl(func, MTK_REG_CHISR, NULL);\n+\n+\t/* Ack an interrupt as soon as possible before any operation on\n+\t * hardware.\n+\t *\n+\t * Note that we don't ack any status during operations to avoid race\n+\t * condition between the host and the device such as it's possible to\n+\t * mistakenly ack RX_DONE for the next packet and then cause interrupts\n+\t * not be raised again but there is still pending data in the hardware\n+\t * FIFO.\n+\t */\n+\tsdio_writel(func, int_status, MTK_REG_CHISR, NULL);\n+\n+\tif (unlikely(!int_status))\n+\t\tbt_dev_err(bdev->hdev, \"CHISR is 0\\n\");\n+\n+\tif (int_status & FW_OWN_BACK_INT)\n+\t\tbt_dev_dbg(bdev->hdev, \"Get fw own back\\n\");\n+\n+\tif (int_status & TX_EMPTY)\n+\t\tschedule_work(&bdev->tx_work);\n+\telse if (unlikely(int_status & TX_FIFO_OVERFLOW))\n+\t\tbt_dev_warn(bdev->hdev, \"Tx fifo overflow\\n\");\n+\n+\tif (int_status & RX_DONE_INT) {\n+\t\trx_size = (int_status & RX_PKT_LEN) >> 16;\n+\n+\t\tif (btmtksdio_rx_packet(bdev, rx_size) < 0)\n+\t\t\tbdev->hdev->stat.err_rx++;\n+\t}\n+\n+\t/* Enable interrupt */\n+\tsdio_writel(func, C_INT_EN_SET, MTK_REG_CHLPCR, 0);\n+}\n+\n+static int btmtksdio_open(struct hci_dev *hdev)\n+{\n+\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n+\tint err;\n+\tu32 status;\n+\n+\tsdio_claim_host(bdev->func);\n+\n+\terr = sdio_enable_func(bdev->func);\n+\tif (err < 0)\n+\t\tgoto err_release_host;\n+\n+\t/* Get ownership from the device */\n+\tsdio_writel(bdev->func, C_FW_OWN_REQ_CLR, MTK_REG_CHLPCR, &err);\n+\tif (err < 0)\n+\t\tgoto err_disable_func;\n+\n+\terr = readx_poll_timeout(btmtksdio_drv_own_query, bdev, status,\n+\t\t\t\t status & C_FW_OWN_REQ_SET, 2000, 1000000);\n+\tif (err < 0) {\n+\t\tbt_dev_err(bdev->hdev, \"Cannot get ownership from device\");\n+\t\tgoto err_disable_func;\n+\t}\n+\n+\t/* Disable interrupt & mask out all interrupt sources */\n+\tsdio_writel(bdev->func, C_INT_EN_CLR, MTK_REG_CHLPCR, &err);\n+\tif (err < 0)\n+\t\tgoto err_disable_func;\n+\n+\tsdio_writel(bdev->func, 0, MTK_REG_CHIER, &err);\n+\tif (err < 0)\n+\t\tgoto err_disable_func;\n+\n+\terr = sdio_claim_irq(bdev->func, btmtksdio_interrupt);\n+\tif (err < 0)\n+\t\tgoto err_disable_func;\n+\n+\terr = sdio_set_block_size(bdev->func, MTK_SDIO_BLOCK_SIZE);\n+\tif (err < 0)\n+\t\tgoto err_release_irq;\n+\n+\t/* SDIO CMD 5 allows the SDIO device back to idle state an\n+\t * synchronous interrupt is supported in SDIO 4-bit mode\n+\t */\n+\tsdio_writel(bdev->func, SDIO_INT_CTL | SDIO_RE_INIT_EN,\n+\t\t    MTK_REG_CSDIOCSR, &err);\n+\tif (err < 0)\n+\t\tgoto err_release_irq;\n+\n+\t/* Setup write-1-clear for CHISR register */\n+\tsdio_writel(bdev->func, C_INT_CLR_CTRL, MTK_REG_CHCR, &err);\n+\tif (err < 0)\n+\t\tgoto err_release_irq;\n+\n+\t/* Setup interrupt sources */\n+\tsdio_writel(bdev->func, RX_DONE_INT | TX_EMPTY | TX_FIFO_OVERFLOW,\n+\t\t    MTK_REG_CHIER, &err);\n+\tif (err < 0)\n+\t\tgoto err_release_irq;\n+\n+\t/* Enable interrupt */\n+\tsdio_writel(bdev->func, C_INT_EN_SET, MTK_REG_CHLPCR, &err);\n+\tif (err < 0)\n+\t\tgoto err_release_irq;\n+\n+\tsdio_release_host(bdev->func);\n+\n+\treturn 0;\n+\n+err_release_irq:\n+\tsdio_release_irq(bdev->func);\n+\n+err_disable_func:\n+\tsdio_disable_func(bdev->func);\n+\n+err_release_host:\n+\tsdio_release_host(bdev->func);\n+\n+\treturn err;\n+}\n+\n+static int btmtksdio_close(struct hci_dev *hdev)\n+{\n+\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n+\tu32 status;\n+\tint err;\n+\n+\tsdio_claim_host(bdev->func);\n+\n+\t/* Disable interrupt */\n+\tsdio_writel(bdev->func, C_INT_EN_CLR, MTK_REG_CHLPCR, NULL);\n+\n+\tsdio_release_irq(bdev->func);\n+\n+\t/* Return ownership to the device */\n+\tsdio_writel(bdev->func, C_FW_OWN_REQ_SET, MTK_REG_CHLPCR, NULL);\n+\n+\terr = readx_poll_timeout(btmtksdio_drv_own_query, bdev, status,\n+\t\t\t\t !(status & C_FW_OWN_REQ_SET), 2000, 1000000);\n+\tif (err < 0)\n+\t\tbt_dev_err(bdev->hdev, \"Cannot return ownership to device\");\n+\n+\tsdio_disable_func(bdev->func);\n+\n+\tsdio_release_host(bdev->func);\n+\n+\treturn 0;\n+}\n+\n+static int btmtksdio_flush(struct hci_dev *hdev)\n+{\n+\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n+\n+\tskb_queue_purge(&bdev->txq);\n+\n+\tcancel_work_sync(&bdev->tx_work);\n+\n+\treturn 0;\n+}\n+\n+static int btmtksdio_func_query(struct hci_dev *hdev)\n+{\n+\tstruct btmtk_hci_wmt_params wmt_params;\n+\tint status, err;\n+\tu8 param = 0;\n+\n+\t/* Query whether the function is enabled */\n+\twmt_params.op = MTK_WMT_FUNC_CTRL;\n+\twmt_params.flag = 4;\n+\twmt_params.dlen = sizeof(param);\n+\twmt_params.data = &param;\n+\twmt_params.status = &status;\n+\n+\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n+\tif (err < 0) {\n+\t\tbt_dev_err(hdev, \"Failed to query function status (%d)\", err);\n+\t\treturn err;\n+\t}\n+\n+\treturn status;\n+}\n+\n+static int mtk_setup_firmware(struct hci_dev *hdev, const char *fwname)\n+{\n+\tstruct btmtk_hci_wmt_params wmt_params;\n+\tconst struct firmware *fw;\n+\tconst u8 *fw_ptr;\n+\tsize_t fw_size;\n+\tint err, dlen;\n+\tu8 flag;\n+\n+\terr = request_firmware(&fw, fwname, &hdev->dev);\n+\tif (err < 0) {\n+\t\tbt_dev_err(hdev, \"Failed to load firmware file (%d)\", err);\n+\t\treturn err;\n+\t}\n+\n+\tfw_ptr = fw->data;\n+\tfw_size = fw->size;\n+\n+\t/* The size of patch header is 30 bytes, should be skip */\n+\tif (fw_size < 30) {\n+\t\terr = -EINVAL;\n+\t\tgoto free_fw;\n+\t}\n+\n+\tfw_size -= 30;\n+\tfw_ptr += 30;\n+\tflag = 1;\n+\n+\twmt_params.op = MTK_WMT_PATCH_DWNLD;\n+\twmt_params.status = NULL;\n+\n+\twhile (fw_size > 0) {\n+\t\tdlen = min_t(int, 250, fw_size);\n+\n+\t\t/* Tell device the position in sequence */\n+\t\tif (fw_size - dlen <= 0)\n+\t\t\tflag = 3;\n+\t\telse if (fw_size < fw->size - 30)\n+\t\t\tflag = 2;\n+\n+\t\twmt_params.flag = flag;\n+\t\twmt_params.dlen = dlen;\n+\t\twmt_params.data = fw_ptr;\n+\n+\t\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n+\t\tif (err < 0) {\n+\t\t\tbt_dev_err(hdev, \"Failed to send wmt patch dwnld (%d)\",\n+\t\t\t\t   err);\n+\t\t\tgoto free_fw;\n+\t\t}\n+\n+\t\tfw_size -= dlen;\n+\t\tfw_ptr += dlen;\n+\t}\n+\n+\twmt_params.op = MTK_WMT_RST;\n+\twmt_params.flag = 4;\n+\twmt_params.dlen = 0;\n+\twmt_params.data = NULL;\n+\twmt_params.status = NULL;\n+\n+\t/* Activate funciton the firmware providing to */\n+\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n+\tif (err < 0) {\n+\t\tbt_dev_err(hdev, \"Failed to send wmt rst (%d)\", err);\n+\t\tgoto free_fw;\n+\t}\n+\n+\t/* Wait a few moments for firmware activation done */\n+\tusleep_range(10000, 12000);\n+\n+free_fw:\n+\trelease_firmware(fw);\n+\treturn err;\n+}\n+\n+static int btmtksdio_setup(struct hci_dev *hdev)\n+{\n+\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n+\tstruct btmtk_hci_wmt_params wmt_params;\n+\tktime_t calltime, delta, rettime;\n+\tstruct btmtk_tci_sleep tci_sleep;\n+\tunsigned long long duration;\n+\tstruct sk_buff *skb;\n+\tint err, status;\n+\tu8 param = 0x1;\n+\n+\tcalltime = ktime_get();\n+\n+\t/* Query whether the firmware is already download */\n+\twmt_params.op = MTK_WMT_SEMAPHORE;\n+\twmt_params.flag = 1;\n+\twmt_params.dlen = 0;\n+\twmt_params.data = NULL;\n+\twmt_params.status = &status;\n+\n+\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n+\tif (err < 0) {\n+\t\tbt_dev_err(hdev, \"Failed to query firmware status (%d)\", err);\n+\t\treturn err;\n+\t}\n+\n+\tif (status == BTMTK_WMT_PATCH_DONE) {\n+\t\tbt_dev_info(hdev, \"Firmware already downloaded\");\n+\t\tgoto ignore_setup_fw;\n+\t}\n+\n+\t/* Setup a firmware which the device definitely requires */\n+\terr = mtk_setup_firmware(hdev, bdev->data->fwname);\n+\tif (err < 0)\n+\t\treturn err;\n+\n+ignore_setup_fw:\n+\t/* Query whether the device is already enabled */\n+\terr = readx_poll_timeout(btmtksdio_func_query, hdev, status,\n+\t\t\t\t status < 0 || status != BTMTK_WMT_ON_PROGRESS,\n+\t\t\t\t 2000, 5000000);\n+\t/* -ETIMEDOUT happens */\n+\tif (err < 0)\n+\t\treturn err;\n+\n+\t/* The other errors happen in btusb_mtk_func_query */\n+\tif (status < 0)\n+\t\treturn status;\n+\n+\tif (status == BTMTK_WMT_ON_DONE) {\n+\t\tbt_dev_info(hdev, \"function already on\");\n+\t\tgoto ignore_func_on;\n+\t}\n+\n+\t/* Enable Bluetooth protocol */\n+\twmt_params.op = MTK_WMT_FUNC_CTRL;\n+\twmt_params.flag = 0;\n+\twmt_params.dlen = sizeof(param);\n+\twmt_params.data = &param;\n+\twmt_params.status = NULL;\n+\n+\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n+\tif (err < 0) {\n+\t\tbt_dev_err(hdev, \"Failed to send wmt func ctrl (%d)\", err);\n+\t\treturn err;\n+\t}\n+\n+ignore_func_on:\n+\t/* Apply the low power environment setup */\n+\ttci_sleep.mode = 0x5;\n+\ttci_sleep.duration = cpu_to_le16(0x640);\n+\ttci_sleep.host_duration = cpu_to_le16(0x640);\n+\ttci_sleep.host_wakeup_pin = 0;\n+\ttci_sleep.time_compensation = 0;\n+\n+\tskb = __hci_cmd_sync(hdev, 0xfc7a, sizeof(tci_sleep), &tci_sleep,\n+\t\t\t     HCI_INIT_TIMEOUT);\n+\tif (IS_ERR(skb)) {\n+\t\terr = PTR_ERR(skb);\n+\t\tbt_dev_err(hdev, \"Failed to apply low power setting (%d)\", err);\n+\t\treturn err;\n+\t}\n+\tkfree_skb(skb);\n+\n+\trettime = ktime_get();\n+\tdelta = ktime_sub(rettime, calltime);\n+\tduration = (unsigned long long)ktime_to_ns(delta) >> 10;\n+\n+\tbt_dev_info(hdev, \"Device setup in %llu usecs\", duration);\n+\n+\treturn 0;\n+}\n+\n+static int btmtksdio_shutdown(struct hci_dev *hdev)\n+{\n+\tstruct btmtk_hci_wmt_params wmt_params;\n+\tu8 param = 0x0;\n+\tint err;\n+\n+\t/* Disable the device */\n+\twmt_params.op = MTK_WMT_FUNC_CTRL;\n+\twmt_params.flag = 0;\n+\twmt_params.dlen = sizeof(param);\n+\twmt_params.data = &param;\n+\twmt_params.status = NULL;\n+\n+\terr = mtk_hci_wmt_sync(hdev, &wmt_params);\n+\tif (err < 0) {\n+\t\tbt_dev_err(hdev, \"Failed to send wmt func ctrl (%d)\", err);\n+\t\treturn err;\n+\t}\n+\n+\treturn 0;\n+}\n+\n+static int btmtksdio_send_frame(struct hci_dev *hdev, struct sk_buff *skb)\n+{\n+\tstruct btmtksdio_dev *bdev = hci_get_drvdata(hdev);\n+\n+\tswitch (hci_skb_pkt_type(skb)) {\n+\tcase HCI_COMMAND_PKT:\n+\t\thdev->stat.cmd_tx++;\n+\t\tbreak;\n+\n+\tcase HCI_ACLDATA_PKT:\n+\t\thdev->stat.acl_tx++;\n+\t\tbreak;\n+\n+\tcase HCI_SCODATA_PKT:\n+\t\thdev->stat.sco_tx++;\n+\t\tbreak;\n+\n+\tdefault:\n+\t\treturn -EILSEQ;\n+\t}\n+\n+\tskb_queue_tail(&bdev->txq, skb);\n+\n+\tschedule_work(&bdev->tx_work);\n+\n+\treturn 0;\n+}\n+\n+static int btmtksdio_probe(struct sdio_func *func,\n+\t\t\t   const struct sdio_device_id *id)\n+{\n+\tstruct btmtksdio_dev *bdev;\n+\tstruct hci_dev *hdev;\n+\tint err;\n+\n+\tbdev = devm_kzalloc(&func->dev, sizeof(*bdev), GFP_KERNEL);\n+\tif (!bdev)\n+\t\treturn -ENOMEM;\n+\n+\tbdev->data = (void *)id->driver_data;\n+\tif (!bdev->data)\n+\t\treturn -ENODEV;\n+\n+\tbdev->func = func;\n+\n+\tINIT_WORK(&bdev->tx_work, btmtksdio_tx_work);\n+\tskb_queue_head_init(&bdev->txq);\n+\n+\t/* Initialize and register HCI device */\n+\thdev = hci_alloc_dev();\n+\tif (!hdev) {\n+\t\tdev_err(&func->dev, \"Can't allocate HCI device\\n\");\n+\t\treturn -ENOMEM;\n+\t}\n+\n+\tbdev->hdev = hdev;\n+\n+\thdev->bus = HCI_SDIO;\n+\thci_set_drvdata(hdev, bdev);\n+\n+\thdev->open     = btmtksdio_open;\n+\thdev->close    = btmtksdio_close;\n+\thdev->flush    = btmtksdio_flush;\n+\thdev->setup    = btmtksdio_setup;\n+\thdev->shutdown = btmtksdio_shutdown;\n+\thdev->send     = btmtksdio_send_frame;\n+\tSET_HCIDEV_DEV(hdev, &func->dev);\n+\n+\thdev->manufacturer = 70;\n+\tset_bit(HCI_QUIRK_NON_PERSISTENT_SETUP, &hdev->quirks);\n+\n+\terr = hci_register_dev(hdev);\n+\tif (err < 0) {\n+\t\tdev_err(&func->dev, \"Can't register HCI device\\n\");\n+\t\thci_free_dev(hdev);\n+\t\treturn err;\n+\t}\n+\n+\tsdio_set_drvdata(func, bdev);\n+\n+\treturn 0;\n+}\n+\n+static void btmtksdio_remove(struct sdio_func *func)\n+{\n+\tstruct btmtksdio_dev *bdev = sdio_get_drvdata(func);\n+\tstruct hci_dev *hdev;\n+\n+\tif (!bdev)\n+\t\treturn;\n+\n+\thdev = bdev->hdev;\n+\n+\tsdio_set_drvdata(func, NULL);\n+\thci_unregister_dev(hdev);\n+\thci_free_dev(hdev);\n+}\n+\n+static struct sdio_driver btmtksdio_driver = {\n+\t.name\t\t= \"btmtksdio\",\n+\t.probe\t\t= btmtksdio_probe,\n+\t.remove\t\t= btmtksdio_remove,\n+\t.id_table\t= btmtksdio_table,\n+};\n+\n+static int __init btmtksdio_init(void)\n+{\n+\tBT_INFO(\"MediaTek Bluetooth SDIO driver ver %s\", VERSION);\n+\n+\treturn sdio_register_driver(&btmtksdio_driver);\n+}\n+\n+static void __exit btmtksdio_exit(void)\n+{\n+\tsdio_unregister_driver(&btmtksdio_driver);\n+}\n+\n+module_init(btmtksdio_init);\n+module_exit(btmtksdio_exit);\n+\n+MODULE_AUTHOR(\"Sean Wang <sean.wang@mediatek.com>\");\n+MODULE_DESCRIPTION(\"MediaTek Bluetooth SDIO driver ver \" VERSION);\n+MODULE_VERSION(VERSION);\n+MODULE_LICENSE(\"GPL\");\n+MODULE_FIRMWARE(FIRMWARE_MT7663);\n+MODULE_FIRMWARE(FIRMWARE_MT7668);\n",
  "changed_files": [
    "drivers/bluetooth/Kconfig",
    "drivers/bluetooth/Makefile",
    "drivers/bluetooth/btmtksdio.c"
  ],
  "diff_stats": " drivers/bluetooth/Kconfig     |  11 +\n drivers/bluetooth/Makefile    |   1 +\n drivers/bluetooth/btmtksdio.c | 979 ++++++++++++++++++++++++++++++++++++++++++\n 3 files changed, 991 insertions(+)\n"
}