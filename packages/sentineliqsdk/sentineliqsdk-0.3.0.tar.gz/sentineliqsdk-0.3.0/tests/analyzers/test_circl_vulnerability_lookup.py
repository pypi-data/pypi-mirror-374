from __future__ import annotations

from unittest.mock import Mock, patch

import pytest

from sentineliqsdk import WorkerConfig, WorkerInput
from sentineliqsdk.analyzers.circl_vulnerability_lookup import CIRCLVulnerabilityLookupAnalyzer


class TestCIRCLVulnerabilityLookupAnalyzer:
    """Test cases for CIRCLVulnerabilityLookupAnalyzer."""

    def setup_method(self):
        """Set up test fixtures."""
        self.secrets = {"circl_vulnerability_lookup": {"token": "test_token"}}

        self.config = WorkerConfig(
            check_tlp=True,
            max_tlp=2,
            check_pap=True,
            max_pap=2,
            auto_extract=True,
            secrets=self.secrets,
        )

    def test_init_with_config(self):
        """Test analyzer initialization with configuration."""
        input_data = WorkerInput(data_type="cve", data="CVE-2021-44228", config=self.config)

        analyzer = CIRCLVulnerabilityLookupAnalyzer(input_data)

        assert analyzer.url == "https://vulnerability.circl.lu/"
        assert analyzer.token == "test_token"

    def test_init_with_default_url(self):
        """Test analyzer initialization with default URL."""
        config = WorkerConfig(secrets=self.secrets)
        input_data = WorkerInput(data_type="cve", data="CVE-2021-44228", config=config)

        analyzer = CIRCLVulnerabilityLookupAnalyzer(input_data)

        assert analyzer.url == "https://vulnerability.circl.lu/"
        assert analyzer.token == "test_token"

    def test_unsupported_data_type(self):
        """Test error for unsupported data type."""
        input_data = WorkerInput(data_type="ip", data="1.2.3.4", config=self.config)

        analyzer = CIRCLVulnerabilityLookupAnalyzer(input_data)

        with pytest.raises(SystemExit):
            analyzer.execute()

    def test_parse_epss_short_report_high_risk(self):
        """Test EPSS parsing for high risk vulnerability."""
        input_data = WorkerInput(data_type="cve", data="CVE-2021-44228", config=self.config)

        analyzer = CIRCLVulnerabilityLookupAnalyzer(input_data)

        epss_data = {"data": [{"epss": 0.95, "percentile": 0.95}]}

        short_report, taxonomy, tag = analyzer.parse_epss_short_report(epss_data)

        assert short_report is not None
        assert "Very High" in short_report
        assert "95th percentile" in short_report
        assert taxonomy is not None
        assert taxonomy["level"] == "malicious"
        assert tag == "very-high"

    def test_parse_epss_short_report_low_risk(self):
        """Test EPSS parsing for low risk vulnerability."""
        input_data = WorkerInput(data_type="cve", data="CVE-2021-44228", config=self.config)

        analyzer = CIRCLVulnerabilityLookupAnalyzer(input_data)

        epss_data = {"data": [{"epss": 0.05, "percentile": 0.05}]}

        short_report, taxonomy, tag = analyzer.parse_epss_short_report(epss_data)

        assert short_report is not None
        assert "Very Low" in short_report
        assert "5th percentile" in short_report
        assert taxonomy is not None
        assert taxonomy["level"] == "safe"
        assert tag == "very-low"

    def test_parse_epss_short_report_invalid_data(self):
        """Test EPSS parsing with invalid data."""
        input_data = WorkerInput(data_type="cve", data="CVE-2021-44228", config=self.config)

        analyzer = CIRCLVulnerabilityLookupAnalyzer(input_data)

        # Test with empty data
        short_report, taxonomy, tag = analyzer.parse_epss_short_report({})
        assert short_report is None
        assert taxonomy is None
        assert tag is None

        # Test with invalid data structure
        short_report, taxonomy, tag = analyzer.parse_epss_short_report({"data": []})
        assert short_report is None
        assert taxonomy is None
        assert tag is None

    def test_extract_cvss_scores_legacy(self):
        """Test CVSS score extraction from legacy format."""
        input_data = WorkerInput(data_type="cve", data="CVE-2021-44228", config=self.config)

        analyzer = CIRCLVulnerabilityLookupAnalyzer(input_data)

        vuln_data = {
            "metrics": {
                "cvssMetricV31": [
                    {
                        "cvssData": {
                            "baseScore": 9.8,
                            "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                            "baseSeverity": "CRITICAL",
                        },
                        "exploitabilityScore": 3.9,
                        "impactScore": 5.9,
                    }
                ]
            }
        }

        scores = analyzer.extract_cvss_scores(vuln_data)

        assert "3.1" in scores
        assert scores["3.1"]["score"] == 9.8
        assert scores["3.1"]["severity"] == "CRITICAL"
        assert scores["3.1"]["exploitabilityScore"] == 3.9
        assert scores["3.1"]["impactScore"] == 5.9

    def test_extract_cvss_scores_cna_format(self):
        """Test CVSS score extraction from CNA format."""
        input_data = WorkerInput(data_type="cve", data="CVE-2021-44228", config=self.config)

        analyzer = CIRCLVulnerabilityLookupAnalyzer(input_data)

        vuln_data = {
            "containers": {
                "cna": {
                    "metrics": [
                        {
                            "cvssV4_0": {
                                "baseScore": 8.5,
                                "vectorString": "CVSS:4.0/AV:N/AC:L/AT:N/PR:N/UI:N/VC:H/VI:H/VA:H/SC:N/SI:N/SA:N",
                                "baseSeverity": "HIGH",
                            },
                            "exploitabilityScore": 3.9,
                            "impactScore": 4.6,
                        }
                    ]
                }
            }
        }

        scores = analyzer.extract_cvss_scores(vuln_data)

        assert "4.0" in scores
        assert scores["4.0"]["score"] == 8.5
        assert scores["4.0"]["severity"] == "HIGH"

    @patch("sentineliqsdk.analyzers.circl_vulnerability_lookup.PyVulnerabilityLookup")
    def test_execute_success(self, mock_pyvuln):
        """Test successful execution with mock data."""
        # Mock the PyVulnerabilityLookup instance
        mock_instance = Mock()
        mock_pyvuln.return_value = mock_instance

        # Mock API responses
        mock_instance.get_vulnerability.return_value = {
            "id": "CVE-2021-44228",
            "metrics": {
                "cvssMetricV31": [
                    {
                        "cvssData": {
                            "baseScore": 9.8,
                            "vectorString": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H",
                            "baseSeverity": "CRITICAL",
                        }
                    }
                ]
            },
        }

        mock_instance.get_sightings.return_value = {
            "data": [{"type": "exploited"}, {"type": "seen"}]
        }

        mock_instance.get_epss.return_value = {"data": [{"epss": 0.95, "percentile": 0.95}]}

        mock_instance.get_comments.return_value = {"data": []}

        input_data = WorkerInput(data_type="cve", data="CVE-2021-44228", config=self.config)

        analyzer = CIRCLVulnerabilityLookupAnalyzer(input_data)
        report = analyzer.execute()

        assert report.success is True
        assert "vulnerability" in report.full_report
        assert "cvss_scores" in report.full_report
        assert "sightings" in report.full_report
        assert "epss" in report.full_report
        assert "taxonomy" in report.full_report
        assert "metadata" in report.full_report

        # Check taxonomy entries
        taxonomy = report.full_report["taxonomy"]
        assert len(taxonomy) >= 2  # At least CVSS and EPSS

        # Check CVSS taxonomy
        cvss_taxonomy = next((t for t in taxonomy if t["predicate"] == "cvss"), None)
        assert cvss_taxonomy is not None
        assert cvss_taxonomy["level"] == "malicious"
        assert "Critical" in cvss_taxonomy["value"]

        # Check EPSS taxonomy
        epss_taxonomy = next((t for t in taxonomy if t["predicate"] == "epss"), None)
        assert epss_taxonomy is not None
        assert epss_taxonomy["level"] == "malicious"

    @patch("sentineliqsdk.analyzers.circl_vulnerability_lookup.PyVulnerabilityLookup")
    def test_execute_no_data(self, mock_pyvuln):
        """Test execution when no data is found."""
        mock_instance = Mock()
        mock_pyvuln.return_value = mock_instance

        # Mock empty responses
        mock_instance.get_vulnerability.return_value = {}
        mock_instance.get_sightings.return_value = {}
        mock_instance.get_epss.return_value = {}
        mock_instance.get_comments.return_value = {}

        input_data = WorkerInput(data_type="cve", data="CVE-2021-44228", config=self.config)

        analyzer = CIRCLVulnerabilityLookupAnalyzer(input_data)

        with pytest.raises(SystemExit):
            analyzer.execute()

    def test_execute_missing_library(self):
        """Test execution when pyvulnerabilitylookup is not available."""
        input_data = WorkerInput(data_type="cve", data="CVE-2021-44228", config=self.config)

        analyzer = CIRCLVulnerabilityLookupAnalyzer(input_data)

        with patch(
            "sentineliqsdk.analyzers.circl_vulnerability_lookup.PyVulnerabilityLookup",
            side_effect=ImportError,
        ):
            with pytest.raises(SystemExit):
                analyzer.execute()

    def test_metadata(self):
        """Test that metadata is properly set."""
        assert CIRCLVulnerabilityLookupAnalyzer.METADATA.name == "CIRCL Vulnerability Lookup"
        assert CIRCLVulnerabilityLookupAnalyzer.METADATA.pattern == "threat-intel"
        assert CIRCLVulnerabilityLookupAnalyzer.METADATA.version_stage == "TESTING"
