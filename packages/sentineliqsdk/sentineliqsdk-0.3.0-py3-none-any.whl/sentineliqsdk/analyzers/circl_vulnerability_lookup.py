"""CIRCL Vulnerability Lookup Analyzer for SentinelIQ SDK."""

from __future__ import annotations

from typing import Any

from sentineliqsdk import Analyzer
from sentineliqsdk.models import AnalyzerReport, ModuleMetadata, TaxonomyLevel

try:
    from pyvulnerabilitylookup import PyVulnerabilityLookup
except ImportError:
    PyVulnerabilityLookup = None  # type: ignore

# Constants for EPSS risk levels
EPSS_VERY_HIGH_THRESHOLD = 0.90
EPSS_HIGH_THRESHOLD = 0.70
EPSS_MODERATE_THRESHOLD = 0.40
EPSS_LOW_THRESHOLD = 0.10

# Constants for CVSS severity levels
CVSS_CRITICAL_THRESHOLD = 9.0
CVSS_HIGH_THRESHOLD = 7.0
CVSS_MEDIUM_THRESHOLD = 4.0


class CIRCLVulnerabilityLookupAnalyzer(Analyzer):
    """Analyzes CVE vulnerabilities using CIRCL Vulnerability Lookup API."""

    METADATA = ModuleMetadata(
        name="CIRCL Vulnerability Lookup",
        description="Analyzes CVE vulnerabilities using CIRCL Vulnerability Lookup API with EPSS scores and CVSS metrics",
        author=("SentinelIQ Team <team@sentineliq.com.br>",),
        pattern="threat-intel",
        doc_pattern="MkDocs module page; programmatic usage",
        doc="https://killsearch.github.io/sentineliqsdk/modulos/analyzers/circl_vulnerability_lookup/",
        version_stage="TESTING",
    )

    def __init__(self, input_data, secret_phrases=None):
        super().__init__(input_data, secret_phrases)

        # Get configuration from WorkerConfig
        self.url = self.get_config(
            "circl_vulnerability_lookup.url", "https://vulnerability.circl.lu/"
        )
        self.token = self.get_secret(
            "circl_vulnerability_lookup.token", message="CIRCL API token required"
        )

    def parse_epss_short_report(
        self, epss_raw: dict[str, Any]
    ) -> tuple[str | None, dict[str, Any] | None, str | None]:
        """Parse EPSS data and return short report, taxonomy, and tag."""
        try:
            data = epss_raw.get("data", [])
            if not data:
                return None, None, None

            data = data[0]
            epss_score = float(data.get("epss", 0))
            percentile = float(data.get("percentile", 0))
        except (IndexError, ValueError, TypeError):
            return None, None, None

        if percentile >= EPSS_VERY_HIGH_THRESHOLD:
            level: TaxonomyLevel = "malicious"
            label = "Very High"
        elif percentile >= EPSS_HIGH_THRESHOLD:
            level = "suspicious"
            label = "High"
        elif percentile >= EPSS_MODERATE_THRESHOLD:
            level = "suspicious"
            label = "Moderate"
        elif percentile >= EPSS_LOW_THRESHOLD:
            level = "info"
            label = "Low"
        else:
            level = "safe"
            label = "Very Low"

        short_report = (
            f"EPSS Risk: {label} (Score {epss_score:.2f}, {round(percentile * 100)}th percentile)"
        )

        taxonomy = self.build_taxonomy(
            level, "CIRCLVulnL", "epss", f"{label} ({round(percentile * 100)}th percentile)"
        )

        return short_report, taxonomy.to_dict(), label.lower().replace(" ", "-")

    def extract_cvss_scores(self, vuln_data: dict[str, Any]) -> dict[str, dict[str, Any]]:
        """Extract CVSS scores from vulnerability data."""
        scores = {}
        metrics_legacy = vuln_data.get("metrics", {})
        metrics_cna = vuln_data.get("containers", {}).get("cna", {}).get("metrics", [])

        version_mapping = {
            "cvssMetricV2": "2.0",
            "cvssMetricV30": "3.0",
            "cvssMetricV31": "3.1",
            "cvssMetricV40": "4.0",
        }

        # Legacy CVSS structure
        for key, version in version_mapping.items():
            metric_data = metrics_legacy.get(key, [])
            if metric_data:
                cvss_data = metric_data[0].get("cvssData", {})
                scores[version] = {
                    "score": cvss_data.get("baseScore"),
                    "vector": cvss_data.get("vectorString"),
                    "severity": cvss_data.get("baseSeverity"),
                    "exploitabilityScore": metric_data[0].get("exploitabilityScore"),
                    "impactScore": metric_data[0].get("impactScore"),
                }

        # CVE 5.1 format (containers.cna.metrics)
        for entry in metrics_cna:
            for key in entry:
                if key.startswith("cvssV"):
                    version = key.replace("cvssV", "")
                    version = version.replace("_", ".")
                    data = entry[key]
                    scores[version] = {
                        "score": data.get("baseScore"),
                        "vector": data.get("vectorString"),
                        "severity": data.get("baseSeverity"),
                        "exploitabilityScore": entry.get("exploitabilityScore"),
                        "impactScore": entry.get("impactScore"),
                    }

        return scores

    def _build_cvss_taxonomy(self, cvss_scores: dict[str, dict[str, Any]]) -> dict[str, Any]:
        """Build CVSS taxonomy entry."""
        max_score = 0
        selected = None

        for entry in cvss_scores.values():
            score = entry.get("score")
            if score is not None and score > max_score:
                max_score = score
                selected = entry

        if selected:
            if max_score >= CVSS_CRITICAL_THRESHOLD:
                level_cvss: TaxonomyLevel = "malicious"
                value_cvss = f"Critical (CVSS {max_score})"
            elif max_score >= CVSS_HIGH_THRESHOLD:
                level_cvss = "malicious"
                value_cvss = f"High (CVSS {max_score})"
            elif max_score >= CVSS_MEDIUM_THRESHOLD:
                level_cvss = "suspicious"
                value_cvss = f"Medium (CVSS {max_score})"
            else:
                level_cvss = "info"
                value_cvss = f"Low (CVSS {max_score})"
        else:
            level_cvss = "safe"
            value_cvss = "No CVSS score"

        return self.build_taxonomy(level_cvss, "CIRCLVulnL", "cvss", value_cvss).to_dict()

    def _build_sightings_taxonomy(self, sightings_data: list[dict[str, Any]]) -> dict[str, Any]:
        """Build sightings taxonomy entry."""
        type_counts: dict[str, int] = {}
        for s in sightings_data:
            t = s.get("type", "unknown")
            type_counts[t] = type_counts.get(t, 0) + 1

        if type_counts.get("exploited"):
            level_sightings: TaxonomyLevel = "malicious"
            value_sightings = f"Exploited ({type_counts['exploited']} times)"
        elif type_counts.get("seen"):
            level_sightings = "suspicious"
            value_sightings = f"Seen ({type_counts['seen']} times)"
        elif sightings_data:
            level_sightings = "suspicious"
            value_sightings = f"Other sightings ({len(sightings_data)} total)"
        else:
            level_sightings = "info"
            value_sightings = "No sightings"

        return self.build_taxonomy(
            level_sightings, "CIRCLVulnL", "sightings", value_sightings
        ).to_dict()

    def _build_short_report(
        self, cvss_scores: dict[str, dict[str, Any]], epss_report: str | None
    ) -> list[str]:
        """Build short report lines."""
        short_report_lines = []

        if epss_report:
            short_report_lines.append(epss_report)

        for version, score_data in cvss_scores.items():
            severity = score_data.get("severity")
            score = score_data.get("score")
            line = f"CVSS {version}: {severity if severity else 'Unknown'} ({score if score is not None else 'N/A'})"
            if score_data.get("exploitabilityScore") is not None:
                line += f", Exploitability: {score_data.get('exploitabilityScore')}"
            if score_data.get("impactScore") is not None:
                line += f", Impact: {score_data.get('impactScore')}"
            short_report_lines.append(line)

        return short_report_lines

    def execute(self) -> AnalyzerReport:
        """Execute the vulnerability analysis."""
        observable = self.get_data()
        datatype = self.data_type

        if not (
            "vuln" in datatype.lower() or "cve" in datatype.lower() or datatype.lower() == "other"
        ):
            self.error(f"Unsupported data type: {datatype}")

        try:
            if PyVulnerabilityLookup is None:
                self.error(
                    "pyvulnerabilitylookup library not available. Please install it: pip install pyvulnerabilitylookup"
                )

            vuln_lookup = PyVulnerabilityLookup(self.url, token=self.token)

            vulnerability = vuln_lookup.get_vulnerability(vulnerability_id=observable) or {}
            sightings = vuln_lookup.get_sightings(vuln_id=observable) or {}
            epss = vuln_lookup.get_epss(vulnerability=observable) or {}
            comments = vuln_lookup.get_comments(vuln_id=observable) or {}

            if not any([sightings, epss]):
                self.error(f"No data found for {observable}. CVE might be unknown or not indexed.")

            sighting_stats: dict[str, int] = {}
            total_sightings = 0

            for s in sightings.get("data", []):
                t = s.get("type", "unknown")
                sighting_stats[t] = sighting_stats.get(t, 0) + 1
                total_sightings += 1

            cvss_scores = self.extract_cvss_scores(vulnerability)

        except Exception as e:
            self.error(f"Error querying vulnerability data: {e!s}")

        # Parse EPSS data
        epss_report, epss_taxonomy, epss_tag = self.parse_epss_short_report(epss)

        # Build taxonomy entries
        taxonomies = []
        taxonomies.append(self._build_cvss_taxonomy(cvss_scores))
        taxonomies.append(self._build_sightings_taxonomy(sightings.get("data", [])))

        # Add EPSS taxonomy if available
        if epss_taxonomy:
            taxonomies.append(epss_taxonomy)

        # Build short report
        short_report_lines = self._build_short_report(cvss_scores, epss_report)

        # Build operations
        operations = []
        if epss_tag:
            operations.append(self.build_operation("AddTagToArtifact", tag=f"epss:{epss_tag}"))

        full_report = {
            "vulnerability": vulnerability,
            "cvss_scores": cvss_scores,
            "comments": comments,
            "sightings": sightings,
            "epss": epss,
            "url": f"https://vulnerability.circl.lu/vuln/{observable}",
            "short_report": short_report_lines,
            "stats": {"sightings_by_type": sighting_stats, "total_sightings": total_sightings},
            "_epss_tag": epss_tag,
            "taxonomy": taxonomies,
            "metadata": self.METADATA.to_dict(),
        }

        return self.report(full_report)

    def run(self) -> None:
        """Run the analyzer."""
        self.execute()
