{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Sup Language Sup is an English-like programming language with deterministic semantics and human-friendly errors!!! Variables, arithmetic, strings Collections (lists, maps) Control flow (if/else, while, for each) Functions Errors and imports Transpiler to Python Get started Install and run an example: pip install sup-lang sup sup-lang/examples/06_mixed.sup Documentation map Quickstart: first steps, install, hello world, CLI basics Language Spec: grammar and semantics of the MVP Standard Library: built-in operations for math, strings, lists, maps Types: basic types and behavior Modules: imports and packaging Packaging: building and distributing SUP code Get started: sup examples/06_mixed.sup","title":"Home"},{"location":"#sup-language","text":"Sup is an English-like programming language with deterministic semantics and human-friendly errors!!! Variables, arithmetic, strings Collections (lists, maps) Control flow (if/else, while, for each) Functions Errors and imports Transpiler to Python","title":"Sup Language"},{"location":"#get-started","text":"Install and run an example: pip install sup-lang sup sup-lang/examples/06_mixed.sup","title":"Get started"},{"location":"#documentation-map","text":"Quickstart: first steps, install, hello world, CLI basics Language Spec: grammar and semantics of the MVP Standard Library: built-in operations for math, strings, lists, maps Types: basic types and behavior Modules: imports and packaging Packaging: building and distributing SUP code Get started: sup examples/06_mixed.sup","title":"Documentation map"},{"location":"modules/","text":"Modules, Imports, and Package Metadata Resolution Search order: current working directory, then paths in SUP_PATH (os\u2011path\u2011sep separated). A module foo is sourced from foo.sup . Syntax import foo \u2192 binds namespace foo.* in current scope. from foo import bar as baz \u2192 binds symbol bar (function/var) as baz . Execution model On import, the module executes in its own environment; exported top\u2011level variables and functions become available to importers. Circular import detection raises an error. Package metadata (future) sup.json in project root: { \"name\": \"myapp\", \"version\": \"0.1.0\", \"description\": \"...\", \"entry\": \"main.sup\", \"dependencies\": { \"mathlib\": \"^1.0.0\" } } Used by a future package manager to resolve dependencies and publish packages.","title":"Modules"},{"location":"modules/#modules-imports-and-package-metadata","text":"","title":"Modules, Imports, and Package Metadata"},{"location":"modules/#resolution","text":"Search order: current working directory, then paths in SUP_PATH (os\u2011path\u2011sep separated). A module foo is sourced from foo.sup .","title":"Resolution"},{"location":"modules/#syntax","text":"import foo \u2192 binds namespace foo.* in current scope. from foo import bar as baz \u2192 binds symbol bar (function/var) as baz .","title":"Syntax"},{"location":"modules/#execution-model","text":"On import, the module executes in its own environment; exported top\u2011level variables and functions become available to importers. Circular import detection raises an error.","title":"Execution model"},{"location":"modules/#package-metadata-future","text":"sup.json in project root: { \"name\": \"myapp\", \"version\": \"0.1.0\", \"description\": \"...\", \"entry\": \"main.sup\", \"dependencies\": { \"mathlib\": \"^1.0.0\" } } Used by a future package manager to resolve dependencies and publish packages.","title":"Package metadata (future)"},{"location":"packaging/","text":"Packaging and Project Commands Scaffold sup init myapp Creates main.sup , sup.json , and README.md . Build (transpile project) sup build main.sup --out dist_sup Produces Python modules and a run.py launcher. Sourcemaps are generated with sourceMappingURL . Lockfile sup lock main.sup Writes sup.lock containing module paths and SHA256 hashes for reproducible builds. Test runner sup test tests/ Runs all .sup files in a directory and reports pass count (zero exit code when all pass). Publish (source tarball) sup publish . Creates dist_sup/<name>-<version>.tar.gz using metadata from sup.json .","title":"Packaging"},{"location":"packaging/#packaging-and-project-commands","text":"","title":"Packaging and Project Commands"},{"location":"packaging/#scaffold","text":"sup init myapp Creates main.sup , sup.json , and README.md .","title":"Scaffold"},{"location":"packaging/#build-transpile-project","text":"sup build main.sup --out dist_sup Produces Python modules and a run.py launcher. Sourcemaps are generated with sourceMappingURL .","title":"Build (transpile project)"},{"location":"packaging/#lockfile","text":"sup lock main.sup Writes sup.lock containing module paths and SHA256 hashes for reproducible builds.","title":"Lockfile"},{"location":"packaging/#test-runner","text":"sup test tests/ Runs all .sup files in a directory and reports pass count (zero exit code when all pass).","title":"Test runner"},{"location":"packaging/#publish-source-tarball","text":"sup publish . Creates dist_sup/<name>-<version>.tar.gz using metadata from sup.json .","title":"Publish (source tarball)"},{"location":"quickstart/","text":"Quickstart Install pip install sup-lang From source (editable): python -m venv .venv .venv\\Scripts\\activate pip install -e . Hello world Scaffold a project: sup init hello-sup Or create a single file hello.sup : Create hello.sup : sup print \"Hello, SUP!\" bye Run: sup hello.sup Variables and arithmetic sup set x to add 2 and 3 print the result print subtract 3 from x bye Control flow sup set n to 5 if n is greater than 3 then print \"big\" else print \"small\" end if bye Functions sup define function called square with x return multiply x and x end function print call square with 7 bye Errors and imports sup try throw \"oops\" catch e print e finally print \"done\" end try bye Transpile to Python sup --emit python hello.sup Project transpile (entry + imports) sup transpile sup-lang/examples/06_mixed.sup --out dist_py python dist_py/run.py Formatter and linter supfmt path/to/program.sup suplint path/to/program.sup VS Code extension Install the SUP language support extension for syntax highlighting and snippets.","title":"Quickstart"},{"location":"quickstart/#quickstart","text":"","title":"Quickstart"},{"location":"quickstart/#install","text":"pip install sup-lang From source (editable): python -m venv .venv .venv\\Scripts\\activate pip install -e .","title":"Install"},{"location":"quickstart/#hello-world","text":"Scaffold a project: sup init hello-sup Or create a single file hello.sup : Create hello.sup : sup print \"Hello, SUP!\" bye Run: sup hello.sup","title":"Hello world"},{"location":"quickstart/#variables-and-arithmetic","text":"sup set x to add 2 and 3 print the result print subtract 3 from x bye","title":"Variables and arithmetic"},{"location":"quickstart/#control-flow","text":"sup set n to 5 if n is greater than 3 then print \"big\" else print \"small\" end if bye","title":"Control flow"},{"location":"quickstart/#functions","text":"sup define function called square with x return multiply x and x end function print call square with 7 bye","title":"Functions"},{"location":"quickstart/#errors-and-imports","text":"sup try throw \"oops\" catch e print e finally print \"done\" end try bye","title":"Errors and imports"},{"location":"quickstart/#transpile-to-python","text":"sup --emit python hello.sup","title":"Transpile to Python"},{"location":"quickstart/#project-transpile-entry-imports","text":"sup transpile sup-lang/examples/06_mixed.sup --out dist_py python dist_py/run.py","title":"Project transpile (entry + imports)"},{"location":"quickstart/#formatter-and-linter","text":"supfmt path/to/program.sup suplint path/to/program.sup","title":"Formatter and linter"},{"location":"quickstart/#vs-code-extension","text":"Install the SUP language support extension for syntax highlighting and snippets.","title":"VS Code extension"},{"location":"spec/","text":"Language Specification Grammar highlights: - Program starts with sup and ends with bye . - Assignments: set x to add 2 and 3 - Print: print the result or print <expr> - Input: ask for name - If/Else: if a is greater than b then ... else ... end if - While: while cond ... end while - For Each: for each item in list ... end for - Errors: try ... catch e ... finally ... end try , throw <expr> - Imports: import foo , from foo import bar as baz Booleans and comparisons: and , or , not , == , != , < , > , <= , >= . Examples Assignment and print: sup set x to add 2 and 3 print the result bye If/else and loops: sup set n to 3 if n is greater than 2 then print \"ok\" else print \"no\" end if repeat 2 times print n end repeat bye Standard Library (selected) Strings/Math: upper of S , lower of S , trim of S , concat of A and B , power of A and B , sqrt of A , abs of A , min of A and B , max of A and B , floor of A , ceil of A , contains of A and B , join of SEPARATOR and LIST Files/JSON/Time: read file of PATH , write file of PATH and DATA , json parse of S , json stringify of V , now Env/Path: env get of KEY -> returns value or null env set of KEY and VALUE -> returns true cwd -> current working directory join path of A and B -> OS-specific path join basename of PATH , dirname of PATH , exists of PATH Logging: log of MESSAGE (writes to output stream) Regex: regex match of PATTERN and TEXT , regex search of PATTERN and TEXT , regex replace of PATTERN and TEXT and REPLACEMENT Args (CLI): args get -> all args joined by spaces; args get of INDEX -> positional arg by index (0-based), or null if missing. CLI passes all trailing tokens after file to program via SUP_ARGS . Additional Modules HTTP: http get of URL , http post of URL and BODY (returns response text) Subprocess: spawn of CMD (returns stdout text, raises on nonzero) Globbing: glob of PATTERN (returns list of matched paths) Random: random int of A and B , random float , shuffle of LIST , choice of LIST Crypto: hash md5 of S , hash sha1 of S , hash sha256 of S Datetime: time now (seconds since epoch), format date of TS and \"%Y-%m-%d\" Design goals (FAQ) Readable: strict grammar that reads like English Deterministic: no magical state; explicit evaluation order Helpful errors: line numbers and suggestions when possible Progressive: interpreter first, transpiler available for ecosystem integration Performance & Tooling Optimizer: --opt enables constant folding and simple AST rewrites during run/transpile Transpiler sourcemaps: --emit python --sourcemap appends inline source mapping comments per line Benchmarks: python -m sup.tools.benchmarks prints CSV for basic scenarios; set perf budgets in CI as needed Future backends: experimental VM/JIT/WASM not enabled by default; CLI may expose --backend vm later Grammar (EBNF) The following is an informal EBNF for SUP v0.2: program = ws* \"sup\" nl statements ws* \"bye\" ws* ; statements = { statement nl } ; statement = assignment | print | if | while | repeat | foreach | funcdef | return | callstmt | trycatch | throw | exprstmt ; assignment = \"set\" ( ident | \"result\" | string ) \"to\" expression [ \"in\" value ] ; print = \"print\" ( \"the\" (\"result\" | ident | \"list\" | \"map\") | \"result\" | expression ) ; if = \"if\" boolexpr [\"then\"] nl statements [\"else\" nl statements] \"end if\" ; while = \"while\" boolexpr nl statements \"end while\" ; repeat = \"repeat\" value \"times\" nl statements \"end repeat\" ; foreach = \"for each\" ident \"in\" value nl statements \"end for\" ; funcdef = \"define function called\" ident [\"with\" ident {\"and\" ident}] nl statements \"end function\" ; return = \"return\" [ expression ] ; callstmt = \"call\" ident [\"with\" expression {\"and\" expression}] ; trycatch = \"try\" nl statements [\"catch\" [ident] nl statements] [\"finally\" nl statements] \"end try\" ; throw = \"throw\" expression ; exprstmt = expression ; boolexpr = boolterm {\"or\" boolterm} ; boolterm = boolfactor {\"and\" boolfactor} ; boolfactor = [\"not\"] ( compare | value ) ; compare = value relop value ; relop = \">\" | \"<\" | \"==\" | \"!=\" | \">=\" | \"<=\" ; expression = add | sub | mul | div | call | make | builtin | value ; add = \"add\" value \"and\" value ; sub = \"subtract\" ( value \"and\" value | value \"from\" value ) ; mul = \"multiply\" value \"and\" value ; div = \"divide\" value \"by\" value ; make = \"make\" ( list | map ) ; list = \"list\" \"of\" value {\",\" value} ; map = \"map\" ; builtin = builtin_op ; // see stdlib for forms call = \"call\" ident [\"with\" expression {\"and\" expression}] ; value = number | string | ident | \"result\" | make | call | add | sub | mul | div ; ident = /[A-Za-z_][A-Za-z0-9_]*/ ; number = /-?\\d+(\\.\\d+)?/ ; string = '\"' ( '\\\\' any | not('\"') )* '\"' ; nl = /\\r?\\n/ ; ws = /[ \\t]*/ ; Semantics Evaluation order: left\u2011to\u2011right, expressions strictly evaluated; no short\u2011circuit for arithmetic; boolean and / or short\u2011circuit. Variables are case\u2011insensitive identifiers in the current scope; assignment updates last_result . Control flow: repeat N times executes body N times (N coerced to int), while evaluates condition each loop. Functions: lexical scoping, arguments bound by name position; return exits current function with optional value. Errors: runtime errors raise and can be handled by try / catch / finally ; throw raises arbitrary values. Modules/imports: import foo binds module namespace foo.* ; from foo import bar as baz binds symbol directly. Resolution searches CWD then SUP_PATH . Concurrency: not yet specified (single\u2011threaded). Future versions may add spawn task , message passing, and async IO.","title":"Language Spec"},{"location":"spec/#language-specification","text":"Grammar highlights: - Program starts with sup and ends with bye . - Assignments: set x to add 2 and 3 - Print: print the result or print <expr> - Input: ask for name - If/Else: if a is greater than b then ... else ... end if - While: while cond ... end while - For Each: for each item in list ... end for - Errors: try ... catch e ... finally ... end try , throw <expr> - Imports: import foo , from foo import bar as baz Booleans and comparisons: and , or , not , == , != , < , > , <= , >= .","title":"Language Specification"},{"location":"spec/#examples","text":"Assignment and print: sup set x to add 2 and 3 print the result bye If/else and loops: sup set n to 3 if n is greater than 2 then print \"ok\" else print \"no\" end if repeat 2 times print n end repeat bye","title":"Examples"},{"location":"spec/#standard-library-selected","text":"Strings/Math: upper of S , lower of S , trim of S , concat of A and B , power of A and B , sqrt of A , abs of A , min of A and B , max of A and B , floor of A , ceil of A , contains of A and B , join of SEPARATOR and LIST Files/JSON/Time: read file of PATH , write file of PATH and DATA , json parse of S , json stringify of V , now Env/Path: env get of KEY -> returns value or null env set of KEY and VALUE -> returns true cwd -> current working directory join path of A and B -> OS-specific path join basename of PATH , dirname of PATH , exists of PATH Logging: log of MESSAGE (writes to output stream) Regex: regex match of PATTERN and TEXT , regex search of PATTERN and TEXT , regex replace of PATTERN and TEXT and REPLACEMENT Args (CLI): args get -> all args joined by spaces; args get of INDEX -> positional arg by index (0-based), or null if missing. CLI passes all trailing tokens after file to program via SUP_ARGS .","title":"Standard Library (selected)"},{"location":"spec/#additional-modules","text":"HTTP: http get of URL , http post of URL and BODY (returns response text) Subprocess: spawn of CMD (returns stdout text, raises on nonzero) Globbing: glob of PATTERN (returns list of matched paths) Random: random int of A and B , random float , shuffle of LIST , choice of LIST Crypto: hash md5 of S , hash sha1 of S , hash sha256 of S Datetime: time now (seconds since epoch), format date of TS and \"%Y-%m-%d\"","title":"Additional Modules"},{"location":"spec/#design-goals-faq","text":"Readable: strict grammar that reads like English Deterministic: no magical state; explicit evaluation order Helpful errors: line numbers and suggestions when possible Progressive: interpreter first, transpiler available for ecosystem integration","title":"Design goals (FAQ)"},{"location":"spec/#performance-tooling","text":"Optimizer: --opt enables constant folding and simple AST rewrites during run/transpile Transpiler sourcemaps: --emit python --sourcemap appends inline source mapping comments per line Benchmarks: python -m sup.tools.benchmarks prints CSV for basic scenarios; set perf budgets in CI as needed Future backends: experimental VM/JIT/WASM not enabled by default; CLI may expose --backend vm later","title":"Performance &amp; Tooling"},{"location":"spec/#grammar-ebnf","text":"The following is an informal EBNF for SUP v0.2: program = ws* \"sup\" nl statements ws* \"bye\" ws* ; statements = { statement nl } ; statement = assignment | print | if | while | repeat | foreach | funcdef | return | callstmt | trycatch | throw | exprstmt ; assignment = \"set\" ( ident | \"result\" | string ) \"to\" expression [ \"in\" value ] ; print = \"print\" ( \"the\" (\"result\" | ident | \"list\" | \"map\") | \"result\" | expression ) ; if = \"if\" boolexpr [\"then\"] nl statements [\"else\" nl statements] \"end if\" ; while = \"while\" boolexpr nl statements \"end while\" ; repeat = \"repeat\" value \"times\" nl statements \"end repeat\" ; foreach = \"for each\" ident \"in\" value nl statements \"end for\" ; funcdef = \"define function called\" ident [\"with\" ident {\"and\" ident}] nl statements \"end function\" ; return = \"return\" [ expression ] ; callstmt = \"call\" ident [\"with\" expression {\"and\" expression}] ; trycatch = \"try\" nl statements [\"catch\" [ident] nl statements] [\"finally\" nl statements] \"end try\" ; throw = \"throw\" expression ; exprstmt = expression ; boolexpr = boolterm {\"or\" boolterm} ; boolterm = boolfactor {\"and\" boolfactor} ; boolfactor = [\"not\"] ( compare | value ) ; compare = value relop value ; relop = \">\" | \"<\" | \"==\" | \"!=\" | \">=\" | \"<=\" ; expression = add | sub | mul | div | call | make | builtin | value ; add = \"add\" value \"and\" value ; sub = \"subtract\" ( value \"and\" value | value \"from\" value ) ; mul = \"multiply\" value \"and\" value ; div = \"divide\" value \"by\" value ; make = \"make\" ( list | map ) ; list = \"list\" \"of\" value {\",\" value} ; map = \"map\" ; builtin = builtin_op ; // see stdlib for forms call = \"call\" ident [\"with\" expression {\"and\" expression}] ; value = number | string | ident | \"result\" | make | call | add | sub | mul | div ; ident = /[A-Za-z_][A-Za-z0-9_]*/ ; number = /-?\\d+(\\.\\d+)?/ ; string = '\"' ( '\\\\' any | not('\"') )* '\"' ; nl = /\\r?\\n/ ; ws = /[ \\t]*/ ;","title":"Grammar (EBNF)"},{"location":"spec/#semantics","text":"Evaluation order: left\u2011to\u2011right, expressions strictly evaluated; no short\u2011circuit for arithmetic; boolean and / or short\u2011circuit. Variables are case\u2011insensitive identifiers in the current scope; assignment updates last_result . Control flow: repeat N times executes body N times (N coerced to int), while evaluates condition each loop. Functions: lexical scoping, arguments bound by name position; return exits current function with optional value. Errors: runtime errors raise and can be handled by try / catch / finally ; throw raises arbitrary values. Modules/imports: import foo binds module namespace foo.* ; from foo import bar as baz binds symbol directly. Resolution searches CWD then SUP_PATH . Concurrency: not yet specified (single\u2011threaded). Future versions may add spawn task , message passing, and async IO.","title":"Semantics"},{"location":"stdlib/","text":"Standard Library Math power of A and B \u2013 exponentiation min of A and B , max of A and B sqrt of X , floor of X , ceil of X , absolute of X Examples: sup print power of 2 and 10 print min of 4 and 9 print floor of 3.7 bye Strings upper of S , lower of S , trim of S , length of S , concat of A and B join of SEP and LIST Examples: sup set name to \"Sup\" print upper of name print concat of name and \"!\" print join of \", \" and make list of \"a\", \"b\", \"c\" bye Collections make list of ... , push , pop , length of L make map , set \"k\" to v in map , get \"k\" from map , delete \"k\" from map get N from list Examples: sup make list of 1, 2, 3 push 4 to list print get 0 from list make map set \"name\" to \"Ada\" in map print get \"name\" from map bye I/O and JSON read file of PATH , write file of PATH and DATA json parse of STRING , json stringify of VALUE now \u2013 current timestamp (ISO) Environment, Paths, and Regex env get of KEY , env set of KEY and VALUE cwd , join path of A and B , basename of PATH , dirname of PATH , exists of PATH regex match/search/replace CLI Args args get \u2013 all args joined by spaces args get of INDEX \u2013 positional arg (0\u2011based) or null","title":"Standard Library"},{"location":"stdlib/#standard-library","text":"","title":"Standard Library"},{"location":"stdlib/#math","text":"power of A and B \u2013 exponentiation min of A and B , max of A and B sqrt of X , floor of X , ceil of X , absolute of X Examples: sup print power of 2 and 10 print min of 4 and 9 print floor of 3.7 bye","title":"Math"},{"location":"stdlib/#strings","text":"upper of S , lower of S , trim of S , length of S , concat of A and B join of SEP and LIST Examples: sup set name to \"Sup\" print upper of name print concat of name and \"!\" print join of \", \" and make list of \"a\", \"b\", \"c\" bye","title":"Strings"},{"location":"stdlib/#collections","text":"make list of ... , push , pop , length of L make map , set \"k\" to v in map , get \"k\" from map , delete \"k\" from map get N from list Examples: sup make list of 1, 2, 3 push 4 to list print get 0 from list make map set \"name\" to \"Ada\" in map print get \"name\" from map bye","title":"Collections"},{"location":"stdlib/#io-and-json","text":"read file of PATH , write file of PATH and DATA json parse of STRING , json stringify of VALUE now \u2013 current timestamp (ISO)","title":"I/O and JSON"},{"location":"stdlib/#environment-paths-and-regex","text":"env get of KEY , env set of KEY and VALUE cwd , join path of A and B , basename of PATH , dirname of PATH , exists of PATH regex match/search/replace","title":"Environment, Paths, and Regex"},{"location":"stdlib/#cli-args","text":"args get \u2013 all args joined by spaces args get of INDEX \u2013 positional arg (0\u2011based) or null","title":"CLI Args"},{"location":"tutorial/","text":"Tiny App Tutorial: Todo CLI In this tutorial we\u2019ll build a tiny Todo CLI in SUP that supports adding, listing, and completing items. Prerequisites Install SUP: pip install sup-lang Project setup Create todo.sup : sup note Initialize an empty list (grammar requires at least one item) make list of 0 set todos to the list pop from todos define function called add with text push text to todos print concat of \"Added: \" and text end function define function called list for each item in todos print item end for end function define function called done with index note convert 1-based to 0-based set n to subtract 1 from index print concat of \"Done: \" and get n from todos end function # Simple router using args set cmd to args get of 0 if cmd is equal to \"add\" then set text to args get of 1 call add with text else if cmd is equal to \"list\" then call list else if cmd is equal to \"done\" then set idx to args get of 1 call done with idx else print \"Usage: sup todo.sup [add TEXT|list|done INDEX]\" end if bye Run sup todo.sup add \"buy milk\" sup todo.sup add \"write code\" sup todo.sup list sup todo.sup done 1 Going further Persist to disk: use write file of PATH and DATA and read file of PATH with json stringify/parse . Packaging: transpile to Python and wrap with a launcher script.","title":"Tutorial"},{"location":"tutorial/#tiny-app-tutorial-todo-cli","text":"In this tutorial we\u2019ll build a tiny Todo CLI in SUP that supports adding, listing, and completing items.","title":"Tiny App Tutorial: Todo CLI"},{"location":"tutorial/#prerequisites","text":"Install SUP: pip install sup-lang","title":"Prerequisites"},{"location":"tutorial/#project-setup","text":"Create todo.sup : sup note Initialize an empty list (grammar requires at least one item) make list of 0 set todos to the list pop from todos define function called add with text push text to todos print concat of \"Added: \" and text end function define function called list for each item in todos print item end for end function define function called done with index note convert 1-based to 0-based set n to subtract 1 from index print concat of \"Done: \" and get n from todos end function # Simple router using args set cmd to args get of 0 if cmd is equal to \"add\" then set text to args get of 1 call add with text else if cmd is equal to \"list\" then call list else if cmd is equal to \"done\" then set idx to args get of 1 call done with idx else print \"Usage: sup todo.sup [add TEXT|list|done INDEX]\" end if bye","title":"Project setup"},{"location":"tutorial/#run","text":"sup todo.sup add \"buy milk\" sup todo.sup add \"write code\" sup todo.sup list sup todo.sup done 1","title":"Run"},{"location":"tutorial/#going-further","text":"Persist to disk: use write file of PATH and DATA and read file of PATH with json stringify/parse . Packaging: transpile to Python and wrap with a launcher script.","title":"Going further"},{"location":"types/","text":"Optional Static Typing (Gradual Types) Goals Preserve SUP\u2019s readability while enabling tooling (errors, IDE, optimization). Opt\u2011in at file/function/variable level; type erasure at runtime unless --typecheck is enabled. Surface syntax (proposed) Type annotations via comment directives on headers: sup note types: add(a: number, b: number) -> number define function called add with a and b return add a and b end function bye Variables (optional): note type: x: number Containers: list<number> , map<string, number> (for docs/tooling; enforced by linter/typechecker). Type system Primitives: number, string, bool, null Structural containers: list , map Functions: (T1, T2, ...) -> R Union and optional: A | B , optional<T> Checker Separate tool suptype (future) validates annotations; LSP uses it for diagnostics if configured. Gradual: missing annotations default to any and don\u2019t block execution.","title":"Types"},{"location":"types/#optional-static-typing-gradual-types","text":"","title":"Optional Static Typing (Gradual Types)"},{"location":"types/#goals","text":"Preserve SUP\u2019s readability while enabling tooling (errors, IDE, optimization). Opt\u2011in at file/function/variable level; type erasure at runtime unless --typecheck is enabled.","title":"Goals"},{"location":"types/#surface-syntax-proposed","text":"Type annotations via comment directives on headers: sup note types: add(a: number, b: number) -> number define function called add with a and b return add a and b end function bye Variables (optional): note type: x: number Containers: list<number> , map<string, number> (for docs/tooling; enforced by linter/typechecker).","title":"Surface syntax (proposed)"},{"location":"types/#type-system","text":"Primitives: number, string, bool, null Structural containers: list , map Functions: (T1, T2, ...) -> R Union and optional: A | B , optional<T>","title":"Type system"},{"location":"types/#checker","text":"Separate tool suptype (future) validates annotations; LSP uses it for diagnostics if configured. Gradual: missing annotations default to any and don\u2019t block execution.","title":"Checker"},{"location":"versioning/","text":"Versioning, Stability, and Releases Versioning policy Semantic Versioning (SemVer): MAJOR.MINOR.PATCH Breaking language changes: MAJOR Backward\u2011compatible features: MINOR Bug fixes/perf improvements: PATCH Stability windows: no breaking changes within a MINOR line; deprecations are announced one MINOR ahead. LTS releases Designate select MINOR versions as LTS (e.g., 1.4, 2.6) supported for 12\u201318 months with backported fixes. Tooling (compiler/VM/LSP) keeps compatibility with LTS minor within its MAJOR. Deprecations Mark features as deprecated in docs and diagnostics; provide migration tips. Remove deprecations only on next MAJOR. Migration policy Each deprecation entry includes: affected syntax/API, replacement, examples, and an automated lint fix if feasible. Provide a --migrate tool (future) to rewrite common patterns; changelog links to guides. Release cadence Regular MINOR releases (4\u20138 weeks), PATCH as needed. RC tags for release candidates; issue a changelog with migration notes.","title":"Versioning"},{"location":"versioning/#versioning-stability-and-releases","text":"","title":"Versioning, Stability, and Releases"},{"location":"versioning/#versioning-policy","text":"Semantic Versioning (SemVer): MAJOR.MINOR.PATCH Breaking language changes: MAJOR Backward\u2011compatible features: MINOR Bug fixes/perf improvements: PATCH Stability windows: no breaking changes within a MINOR line; deprecations are announced one MINOR ahead.","title":"Versioning policy"},{"location":"versioning/#lts-releases","text":"Designate select MINOR versions as LTS (e.g., 1.4, 2.6) supported for 12\u201318 months with backported fixes. Tooling (compiler/VM/LSP) keeps compatibility with LTS minor within its MAJOR.","title":"LTS releases"},{"location":"versioning/#deprecations","text":"Mark features as deprecated in docs and diagnostics; provide migration tips. Remove deprecations only on next MAJOR.","title":"Deprecations"},{"location":"versioning/#migration-policy","text":"Each deprecation entry includes: affected syntax/API, replacement, examples, and an automated lint fix if feasible. Provide a --migrate tool (future) to rewrite common patterns; changelog links to guides.","title":"Migration policy"},{"location":"versioning/#release-cadence","text":"Regular MINOR releases (4\u20138 weeks), PATCH as needed. RC tags for release candidates; issue a changelog with migration notes.","title":"Release cadence"}]}