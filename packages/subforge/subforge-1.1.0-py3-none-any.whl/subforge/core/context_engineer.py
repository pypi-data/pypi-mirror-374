#!/usr/bin/env python3
"""
Context Engineer - SubForge Enhanced with Context Engineering
Combines Factory Pattern with Context Engineering methodology for superior results
"""

import json
from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List

from .project_analyzer import ProjectProfile


class ContextLevel(Enum):
    """Different levels of context engineering depth"""

    MINIMAL = "minimal"  # Basic project info
    STANDARD = "standard"  # Comprehensive analysis
    DEEP = "deep"  # Full context with examples and patterns
    EXPERT = "expert"  # Advanced patterns with validation


@dataclass
class ContextPackage:
    """Complete context package for AI execution"""

    project_context: Dict[str, Any]
    technical_context: Dict[str, Any]
    examples: List[Dict[str, Any]]
    patterns: List[Dict[str, Any]]
    validation_gates: List[Dict[str, Any]]
    references: List[str]
    success_criteria: List[str]

    def to_markdown(self) -> str:
        """Convert context package to structured markdown"""
        md = f"""# Context Package - {self.project_context.get('name', 'Unknown')}

## Project Context
{self._format_dict_as_markdown(self.project_context)}

## Technical Context
{self._format_dict_as_markdown(self.technical_context)}

## Code Examples & Patterns
{self._format_examples_as_markdown()}

## Validation Gates
{self._format_validation_gates_as_markdown()}

## Success Criteria
{self._format_list_as_markdown(self.success_criteria)}

## References
{self._format_list_as_markdown(self.references)}

Generated by SubForge Context Engineer
"""
        return md

    def _format_dict_as_markdown(self, data: Dict[str, Any]) -> str:
        """Format dictionary as markdown list"""
        lines = []
        for key, value in data.items():
            if isinstance(value, list):
                lines.append(
                    f"- **{key.replace('_', ' ').title()}**: {', '.join(map(str, value))}"
                )
            else:
                lines.append(f"- **{key.replace('_', ' ').title()}**: {value}")
        return "\n".join(lines)

    def _format_examples_as_markdown(self) -> str:
        """Format examples as markdown sections"""
        if not self.examples:
            return "No specific examples available"

        sections = []
        for i, example in enumerate(self.examples, 1):
            sections.append(
                f"""### Example {i}: {example.get('title', 'Untitled')}
**Purpose**: {example.get('purpose', 'N/A')}
**Implementation**:
```{example.get('language', 'text')}
{example.get('code', 'No code provided')}
```
**Notes**: {example.get('notes', 'No additional notes')}
"""
            )
        return "\n".join(sections)

    def _format_validation_gates_as_markdown(self) -> str:
        """Format validation gates as executable checklist"""
        if not self.validation_gates:
            return "No validation gates defined"

        gates = []
        for gate in self.validation_gates:
            gates.append(
                f"""### {gate.get('name', 'Unnamed Gate')}
- [ ] **Test**: {gate.get('test', 'No test defined')}
- [ ] **Command**: `{gate.get('command', 'No command')}`
- [ ] **Expected**: {gate.get('expected', 'No expectation set')}
- [ ] **On Failure**: {gate.get('on_failure', 'Manual investigation')}
"""
            )
        return "\n".join(gates)

    def _format_list_as_markdown(self, items: List[str]) -> str:
        """Format list as markdown bullet points"""
        if not items:
            return "None specified"
        return "\n".join(f"- {item}" for item in items)


class ContextEngineer:
    """
    Advanced Context Engineering system that enriches Factory Pattern with comprehensive context

    This class implements the "Context Engineering > Prompt Engineering" philosophy
    by providing rich, structured context for each factory phase and subagent execution.
    """

    def __init__(self, workspace_dir: Path):
        self.workspace_dir = workspace_dir
        self.context_library = workspace_dir / "context_library"
        self.examples_dir = workspace_dir / "examples"
        self.patterns_dir = workspace_dir / "patterns"

        # Ensure directories exist
        for directory in [self.context_library, self.examples_dir, self.patterns_dir]:
            directory.mkdir(parents=True, exist_ok=True)

    def engineer_context_for_phase(
        self,
        phase_name: str,
        project_profile: ProjectProfile,
        previous_outputs: Dict[str, Any],
        context_level: ContextLevel = ContextLevel.STANDARD,
    ) -> ContextPackage:
        """
        Engineer comprehensive context for a specific factory phase

        This is the core method that transforms basic project info into rich context
        """
        print(
            f"    ðŸŽ¯ Engineering {context_level.value} context for {phase_name} phase..."
        )

        # Build project context
        project_context = self._build_project_context(project_profile)

        # Build technical context
        technical_context = self._build_technical_context(project_profile, phase_name)

        # Find relevant examples
        examples = self._find_relevant_examples(project_profile, phase_name)

        # Extract patterns
        patterns = self._extract_patterns(project_profile, phase_name, context_level)

        # Create validation gates
        validation_gates = self._create_validation_gates(phase_name, project_profile)

        # Build references
        references = self._build_references(project_profile, phase_name)

        # Define success criteria
        success_criteria = self._define_success_criteria(phase_name, project_profile)

        context_package = ContextPackage(
            project_context=project_context,
            technical_context=technical_context,
            examples=examples,
            patterns=patterns,
            validation_gates=validation_gates,
            references=references,
            success_criteria=success_criteria,
        )

        # Save context package
        self._save_context_package(phase_name, context_package)

        print(
            f"    âœ… Context package created: {len(examples)} examples, {len(patterns)} patterns"
        )

        return context_package

    def _build_project_context(self, profile: ProjectProfile) -> Dict[str, Any]:
        """Build comprehensive project context"""
        return {
            "name": profile.name,
            "path": str(profile.path),
            "architecture_pattern": profile.architecture_pattern.value,
            "complexity_level": profile.complexity.value,
            "languages": list(profile.technology_stack.languages),
            "frameworks": list(profile.technology_stack.frameworks),
            "databases": list(profile.technology_stack.databases),
            "tools": list(profile.technology_stack.tools),
            "team_size_estimate": profile.team_size_estimate,
            "has_tests": profile.has_tests,
            "has_ci_cd": profile.has_ci_cd,
            "has_docker": profile.has_docker,
            "file_count": profile.file_count,
            "lines_of_code": profile.lines_of_code,
        }

    def _build_technical_context(
        self, profile: ProjectProfile, phase_name: str
    ) -> Dict[str, Any]:
        """Build phase-specific technical context"""
        base_context = {
            "phase": phase_name,
            "primary_language": (
                next(iter(profile.technology_stack.languages))
                if profile.technology_stack.languages
                else "unknown"
            ),
            "deployment_target": "cloud" if profile.has_docker else "traditional",
            "testing_strategy": "comprehensive" if profile.has_tests else "basic",
            "ci_cd_integration": profile.has_ci_cd,
        }

        # Add phase-specific context
        if phase_name == "analysis":
            base_context.update(
                {
                    "analysis_depth": (
                        "deep" if profile.complexity.value != "simple" else "standard"
                    ),
                    "discovery_areas": [
                        "architecture",
                        "dependencies",
                        "patterns",
                        "performance",
                    ],
                }
            )
        elif phase_name == "selection":
            base_context.update(
                {
                    "template_criteria": self._get_template_criteria(profile),
                    "customization_level": (
                        "high" if profile.complexity.value == "complex" else "medium"
                    ),
                }
            )
        elif phase_name == "generation":
            base_context.update(
                {
                    "generation_targets": [
                        "claude_md",
                        "agents",
                        "workflows",
                        "commands",
                    ],
                    "customization_required": True,
                    "integration_complexity": profile.complexity.value,
                }
            )

        return base_context

    def _find_relevant_examples(
        self, profile: ProjectProfile, phase_name: str
    ) -> List[Dict[str, Any]]:
        """Find relevant code examples and patterns for the project"""
        examples = []

        # Language-specific examples
        for lang in profile.technology_stack.languages:
            lang_examples = self._get_language_examples(lang, phase_name)
            examples.extend(lang_examples)

        # Framework-specific examples
        for framework in profile.technology_stack.frameworks:
            framework_examples = self._get_framework_examples(framework, phase_name)
            examples.extend(framework_examples)

        # Architecture pattern examples
        arch_examples = self._get_architecture_examples(
            profile.architecture_pattern, phase_name
        )
        examples.extend(arch_examples)

        return examples[:5]  # Limit to most relevant

    def _get_language_examples(
        self, language: str, phase_name: str
    ) -> List[Dict[str, Any]]:
        """Get language-specific examples"""
        examples = []

        if language.lower() == "python" and phase_name == "generation":
            examples.append(
                {
                    "title": "Python CLAUDE.md Configuration",
                    "purpose": "Standard Python project configuration",
                    "language": "markdown",
                    "code": """# Python Project Configuration

## Build Commands
```bash
python -m pip install -r requirements.txt
python -m pytest tests/
python -m mypy src/
```

## Code Style
- Use Black for formatting
- Follow PEP 8 standards
- Type hints required for public APIs
""",
                    "notes": "Adapt build commands based on project structure",
                }
            )

        if language.lower() == "javascript" and phase_name == "generation":
            examples.append(
                {
                    "title": "JavaScript/Node.js Configuration",
                    "purpose": "Modern JavaScript project setup",
                    "language": "markdown",
                    "code": """# JavaScript Project Configuration

## Build Commands
```bash
npm install
npm run lint
npm run test
npm run build
```

## Code Style
- Use ESLint + Prettier
- Follow Airbnb style guide
- TypeScript preferred for large projects
""",
                    "notes": "Adjust package manager (npm/yarn/pnpm) based on project",
                }
            )

        return examples

    def _get_framework_examples(
        self, framework: str, phase_name: str
    ) -> List[Dict[str, Any]]:
        """Get framework-specific examples"""
        examples = []

        if framework.lower() in ["fastapi", "django"] and phase_name == "generation":
            examples.append(
                {
                    "title": "FastAPI Agent Configuration",
                    "purpose": "API-focused agent specialization",
                    "language": "yaml",
                    "code": """---
name: api-developer
description: FastAPI specialist for REST API development
model: sonnet
tools: [read, write, edit, bash, grep]
---

# API Developer - FastAPI Specialist

You are an expert FastAPI developer specializing in:
- RESTful API design and implementation
- Pydantic model validation
- Async/await patterns
- Database integration with SQLAlchemy
- API documentation with OpenAPI
""",
                    "notes": "Customize based on specific API requirements",
                }
            )

        return examples

    def _get_architecture_examples(
        self, architecture, phase_name: str
    ) -> List[Dict[str, Any]]:
        """Get architecture pattern examples"""
        examples = []

        if phase_name == "generation":
            examples.append(
                {
                    "title": f"{architecture.value.title()} Architecture Workflow",
                    "purpose": f"Workflow patterns for {architecture.value} architecture",
                    "language": "markdown",
                    "code": self._get_architecture_workflow_template(architecture),
                    "notes": f"Customize for {architecture.value} specific needs",
                }
            )

        return examples

    def _get_architecture_workflow_template(self, architecture) -> str:
        """Get workflow template for architecture pattern"""
        if architecture.value == "microservices":
            return """# Microservices Development Workflow

## Service Development Process
1. **Service Design**
   - Define service boundaries
   - Design API contracts
   - Plan data models

2. **Implementation**
   - Implement service logic
   - Add monitoring and health checks
   - Create comprehensive tests

3. **Integration**
   - Test service interactions
   - Validate API contracts
   - Performance testing
"""
        else:
            return """# Standard Development Workflow

## Feature Development Process
1. **Requirements Analysis**
   - Understand feature requirements
   - Plan implementation approach
   - Identify dependencies

2. **Implementation**
   - Write code following project patterns
   - Add comprehensive tests
   - Update documentation

3. **Quality Assurance**
   - Code review process
   - Integration testing
   - Performance validation
"""

    def _extract_patterns(
        self, profile: ProjectProfile, phase_name: str, context_level: ContextLevel
    ) -> List[Dict[str, Any]]:
        """Extract relevant patterns based on context level"""
        patterns = []

        if context_level in [ContextLevel.DEEP, ContextLevel.EXPERT]:
            # Add advanced patterns
            patterns.extend(self._get_advanced_patterns(profile, phase_name))

        if context_level == ContextLevel.EXPERT:
            # Add expert-level patterns
            patterns.extend(self._get_expert_patterns(profile, phase_name))

        return patterns

    def _get_advanced_patterns(
        self, profile: ProjectProfile, phase_name: str
    ) -> List[Dict[str, Any]]:
        """Get advanced implementation patterns"""
        patterns = []

        if phase_name == "generation":
            patterns.append(
                {
                    "name": "Agent Specialization Pattern",
                    "purpose": "Create highly specialized agents for optimal performance",
                    "implementation": "Focus each agent on a specific domain with minimal overlap",
                    "benefits": [
                        "Clearer responsibilities",
                        "Better context",
                        "Reduced conflicts",
                    ],
                    "examples": [
                        "api-developer for REST APIs",
                        "database-specialist for data models",
                    ],
                }
            )

        return patterns

    def _get_expert_patterns(
        self, profile: ProjectProfile, phase_name: str
    ) -> List[Dict[str, Any]]:
        """Get expert-level implementation patterns"""
        patterns = []

        if profile.complexity.value == "complex":
            patterns.append(
                {
                    "name": "Enterprise Coordination Pattern",
                    "purpose": "Manage complex agent interactions in enterprise environments",
                    "implementation": "Use formal handoff protocols with validation gates",
                    "benefits": ["Audit trails", "Error recovery", "Scalability"],
                    "examples": [
                        "Formal code review workflows",
                        "Multi-stage validation",
                    ],
                }
            )

        return patterns

    def _create_validation_gates(
        self, phase_name: str, profile: ProjectProfile
    ) -> List[Dict[str, Any]]:
        """Create executable validation gates for the phase"""
        gates = []

        if phase_name == "generation":
            gates.append(
                {
                    "name": "CLAUDE.md Syntax Validation",
                    "test": "Validate CLAUDE.md file syntax and completeness",
                    "command": "python -c \"import yaml; yaml.safe_load(open('CLAUDE.md'))\"",
                    "expected": "No syntax errors",
                    "on_failure": "Fix CLAUDE.md syntax issues and re-run generation",
                }
            )

            gates.append(
                {
                    "name": "Agent Configuration Validation",
                    "test": "Verify all generated agents have valid YAML frontmatter",
                    "command": "find .claude/agents -name '*.md' -exec python -c \"import yaml,sys; yaml.safe_load(open(sys.argv[1]).read().split('---')[1])\" {} \\;",
                    "expected": "All agent files parse successfully",
                    "on_failure": "Fix invalid agent configurations",
                }
            )

        return gates

    def _build_references(self, profile: ProjectProfile, phase_name: str) -> List[str]:
        """Build list of relevant references and documentation"""
        references = []

        # Add language-specific references
        for lang in profile.technology_stack.languages:
            if lang.lower() == "python":
                references.extend(
                    [
                        "https://pep8.org/ - Python Style Guide",
                        "https://docs.python.org/3/ - Python Documentation",
                        "https://pytest.org/ - Testing Framework",
                    ]
                )
            elif lang.lower() == "javascript":
                references.extend(
                    [
                        "https://developer.mozilla.org/en-US/docs/Web/JavaScript - MDN JavaScript",
                        "https://nodejs.org/en/docs/ - Node.js Documentation",
                        "https://jestjs.io/ - Testing Framework",
                    ]
                )

        # Add framework-specific references
        for framework in profile.technology_stack.frameworks:
            if framework.lower() == "fastapi":
                references.append(
                    "https://fastapi.tiangolo.com/ - FastAPI Documentation"
                )
            elif framework.lower() == "react":
                references.append("https://reactjs.org/docs - React Documentation")

        return references

    def _define_success_criteria(
        self, phase_name: str, profile: ProjectProfile
    ) -> List[str]:
        """Define clear success criteria for the phase"""
        criteria = []

        if phase_name == "analysis":
            criteria.extend(
                [
                    "Project structure is fully analyzed and documented",
                    "Technology stack is accurately identified",
                    "Architecture pattern is correctly classified",
                    "Team size and complexity are appropriately estimated",
                ]
            )
        elif phase_name == "generation":
            criteria.extend(
                [
                    "CLAUDE.md is generated with project-specific configuration",
                    "All selected agents are properly configured",
                    "Workflows are tailored to project architecture",
                    "Commands are functional for the detected tech stack",
                    "All generated files pass validation gates",
                ]
            )

        return criteria

    def _get_template_criteria(self, profile: ProjectProfile) -> List[str]:
        """Get template selection criteria based on project profile"""
        criteria = []

        criteria.append(
            f"Support for {', '.join(profile.technology_stack.languages)} languages"
        )
        criteria.append(
            f"Compatible with {profile.architecture_pattern.value} architecture"
        )
        criteria.append(f"Appropriate for {profile.complexity.value} complexity")

        if profile.has_tests:
            criteria.append("Include comprehensive testing support")

        if profile.has_ci_cd:
            criteria.append("Support CI/CD integration")

        return criteria

    def _save_context_package(self, phase_name: str, context_package: ContextPackage):
        """Save context package for reference and debugging"""
        context_file = self.context_library / f"{phase_name}_context.md"

        with open(context_file, "w", encoding="utf-8") as f:
            f.write(context_package.to_markdown())

        # Also save as JSON for programmatic access (convert sets to lists)
        json_file = self.context_library / f"{phase_name}_context.json"

        def convert_sets_to_lists(obj):
            """Convert sets to lists for JSON serialization"""
            if isinstance(obj, dict):
                return {k: convert_sets_to_lists(v) for k, v in obj.items()}
            elif isinstance(obj, list):
                return [convert_sets_to_lists(item) for item in obj]
            elif isinstance(obj, set):
                return list(obj)
            else:
                return obj

        json_data = convert_sets_to_lists(
            {
                "project_context": context_package.project_context,
                "technical_context": context_package.technical_context,
                "examples": context_package.examples,
                "patterns": context_package.patterns,
                "validation_gates": context_package.validation_gates,
                "references": context_package.references,
                "success_criteria": context_package.success_criteria,
                "generated_at": datetime.now().isoformat(),
            }
        )

        with open(json_file, "w", encoding="utf-8") as f:
            json.dump(json_data, f, indent=2)


def create_context_engineer(workspace_dir: Path) -> ContextEngineer:
    """Factory function to create ContextEngineer instance"""
    return ContextEngineer(workspace_dir)