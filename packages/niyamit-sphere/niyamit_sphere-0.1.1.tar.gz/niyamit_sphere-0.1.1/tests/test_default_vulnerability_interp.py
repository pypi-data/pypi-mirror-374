import pandas as pd
import geopandas as gpd
import numpy as np

from sphere.core.schemas.buildings import Buildings
from sphere.flood.default_vulnerability import DefaultFloodVulnerability


def make_simple_lookup():
    # Create a tiny lookup DataFrame with ft columns that map to depths
    df = pd.DataFrame({
        "InvDmgFnId": [1, 2],
        "ft02m": [0.0, 0.0],
        "ft00": [10.0, 20.0],
        "ft02": [30.0, 40.0],
    }).set_index("InvDmgFnId")
    return df


def test_interpolate_from_lookup_simple(monkeypatch):
    # Build a small gdf with a custom id column matching the lookup
    df = pd.DataFrame({
        "Id": [1, 2, 1],
        # Do not supply computed percent/loss columns; they are created by the analysis.
        # Provide the structural depth column expected by the vulnerability interpolation.
        "Depth_in_Struc": [0.5, 0.0, 2.0],
        # Provide required mapping columns for Buildings
        "OccupancyType": ["IND2", "RES1", "IND2"],
        "NumStories": [1, 1, 1],
        "FoundationType": [7, 7, 7],
        "FirstFloorHt": [0.0, 0.0, 0.0],
        
    })

    gdf = gpd.GeoDataFrame(df, geometry=gpd.points_from_xy([0, 0, 0], [0, 0, 0]), crs="EPSG:4326")

    class DummyBuildings(Buildings):
        def __init__(self, gdf):
            overrides = {
                "id": "Id",
                # inventory_cost and damage percent/loss are computed and not required here
                "iddf_id": "InvDmgFnId",  # Use a dedicated inventory damage function id column
                "depth_in_structure": "Depth_in_Struc",
            }
            super().__init__(gdf, overrides)

    b = DummyBuildings(gdf)

    # Create vulnerability but monkeypatch internal lookup tables
    vf = DefaultFloodVulnerability(buildings=b, flood_type="R")

    # Replace idf with our simple lookup and ensure index is correct
    vf.idf = make_simple_lookup()

    # Also ensure that gdf has the id column named by get_field_name('iddf_id')
    id_col = b.fields.get_field_name('iddf_id')
    # Put matching ids into the gdf (use 1 and 2 as in the lookup index)
    b.gdf[id_col] = [1, 2, 1]

    # Now call _interpolate_from_lookup to populate inventory_damage_percent
    result_col = b.fields.get_field_name('inventory_damage_percent')
    # The id column in gdf should be the name of the index in lookup (InvDmgFnId)
    vf._interpolate_from_lookup(vf.idf, b.fields.get_field_name('depth_in_structure'), result_col, id_col)

    # After interpolation, verify that values were assigned (not NaN)
    values = b.gdf[result_col].to_numpy()
    # We expect numeric values for each row (lookup present for ids 1 and 2)
    assert not np.isnan(values).any()
    # Compare some expected interpolated behaviors: depth 0.5 should be between 0 (ft02m) and 0 (ft00 -> 10)
    # depth 2.0 should be closer to ft02 value
    assert values[0] >= 0.0
    assert values[2] >= values[0]
