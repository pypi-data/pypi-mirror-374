Metadata-Version: 2.4
Name: usbpdpy
Version: 0.1.0
Classifier: Development Status :: 4 - Beta
Classifier: Intended Audience :: Developers
Classifier: Intended Audience :: Science/Research
Classifier: Topic :: System :: Hardware :: Universal Serial Bus (USB)
Classifier: Topic :: Scientific/Engineering :: Electronic Design Automation (EDA)
Classifier: Topic :: Software Development :: Libraries :: Python Modules
Classifier: License :: OSI Approved :: MIT License
Classifier: Programming Language :: Python :: 3
Classifier: Programming Language :: Python :: 3.8
Classifier: Programming Language :: Python :: 3.9
Classifier: Programming Language :: Python :: 3.10
Classifier: Programming Language :: Python :: 3.11
Classifier: Programming Language :: Python :: 3.12
Classifier: Programming Language :: Rust
Classifier: Programming Language :: Python :: Implementation :: CPython
License-File: LICENSE
Summary: Python bindings for the usbpd Rust crate - fast USB Power Delivery message parsing
Keywords: usb,usb-pd,power-delivery,protocol,parsing,hardware
Home-Page: https://github.com/okhsunrog/usbpdpy
Author-email: Danila Gornushko <me@okhsunrog.dev>
License: MIT
Requires-Python: >=3.8
Description-Content-Type: text/markdown; charset=UTF-8; variant=GFM
Project-URL: Homepage, https://github.com/okhsunrog/usbpdpy
Project-URL: Repository, https://github.com/okhsunrog/usbpdpy
Project-URL: Issues, https://github.com/okhsunrog/usbpdpy/issues
Project-URL: Documentation, https://github.com/okhsunrog/usbpdpy#readme

# usbpdpy

Python bindings for the [`usbpd`](https://crates.io/crates/usbpd) Rust crate.

## Installation

```bash
pip install usbpdpy
```

## Usage

```python
import usbpdpy

# Parse message from bytes
message = usbpdpy.parse_pd_message(b'\x61\x11')
print(f"Type: {message.header.message_type}")
print(f"Name: {usbpdpy.get_message_type_name(message.header.message_type)}")

# Convert hex to bytes
data = usbpdpy.hex_to_bytes("1161")
message = usbpdpy.parse_pd_message(data)
```

## API

### Functions

- `parse_pd_message(data: bytes) -> PyPdMessage`
- `parse_pd_messages(messages: List[bytes]) -> List[PyPdMessage]`
- `get_message_type_name(msg_type: int) -> str`
- `hex_to_bytes(hex_str: str) -> bytes`
- `bytes_to_hex(data: bytes) -> str`

### Classes

**PyPdMessage**
- `header: PyPdHeader`
- `data_objects: List[PyPdDataObject]` 
- `raw_bytes: List[int]`
- `get_hex() -> str`

**PyPdHeader**
- `message_type: int`
- `port_data_role: str` ("UFP"/"DFP")
- `port_power_role: str` ("Sink"/"Source")
- `message_id: int`
- `number_of_data_objects: int`
- `extended: bool`

**PyPdDataObject**
- `raw: int`
- `object_type: str`
- `parsed_data: Optional[str]`

## Requirements

- Python 3.8+
- No runtime dependencies

## License

MIT
