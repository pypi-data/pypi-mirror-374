"""
The Model-Context Protocol (MCP) module for Pentest-Tools.com. It uses the ptt API to provide tools, resources and prompts
to LLM agents that implement MCP.
"""

try:
    from mcp.server.fastmcp import Context, FastMCP
except ImportError:
    # We use this as a guard, in case `pentesttools` was not installed with mcp support
    FastMCP = None


import asyncio
from copy import deepcopy
import json
import os
import sys
import time
import logging
from typing import Literal

import pentesttools as ptt

os.environ["PTT_USER_AGENT"] = "ptt-cli-mcp"

API_URL = "https://app.pentest-tools.com/api/v2/"
MCP_METHOD = "stdio"
HEADERS = {
    "User-Agent": "ptt-cli-mcp",
    "Accept": "*/*",
}


def get_authentication_headers(context: Context) -> dict[str, str]:
    """A function that gives the headers for the request. We need this to get the PTT-API-KEY header

    Returns the headers necessary for a request, with the authentication added. If the key is not found, return an empty dict.
    """
    global HEADERS

    # For stdio, we get the api key from `ptt.api.api_key`
    if MCP_METHOD == "stdio":
        HEADERS["Authorization"] = f"Bearer {ptt.api.api_key}"
        return HEADERS

    # For http, we get the api key from the `Context` object
    elif MCP_METHOD == "http":
        request_object = context.request_context.request
        if request_object is None:
            return {}

        if not hasattr(request_object, "headers"):
            return {}

        headers: dict[str, str] = request_object.headers

        ptt_api_key = headers.get("ptt_api_key")
        if ptt_api_key is not None:
            headers = deepcopy(HEADERS)
            headers["Authorization"] = f"Bearer {ptt_api_key}"

            return headers

    return {}


def run_tool(
    tool_id: int,
    target: str,
    tool_params: dict,
    scan_params: dict,
    context: Context,
    raw: bool = False,
):
    """The main way of running a scanning tool"""

    # `HEADERS` + authentication
    headers = get_authentication_headers(context)
    if not headers:
        return "The api key is missing."

    res = ptt.api.start_scan(target, tool_id, tool_params, scan_params, headers=headers)
    res_json = res.json()

    scan_id = res_json["data"]["created_id"]
    logging.info("Started scan %i, for tool_id %s", scan_id, tool_id)

    while True:
        time.sleep(2)

        # Get the status of our scan
        status = ptt.api.get_scan_status(scan_id, headers=headers)
        status_name = status.json()["data"]["status_name"]

        if status_name == "finished":
            logging.debug("Scan status: %s" % res_json["data"])
            logging.debug("Getting JSON report")

            if raw:
                res = ptt.api.get_raw_output(scan_id, headers=headers)
                return res.text

            res = ptt.api.get_output(scan_id, headers=headers)
            output_json = json.dumps(res.json())
            return output_json


async def run_tool_long_running(
    tool_id: int,
    target: str,
    tool_params: dict,
    scan_params: dict,
    context: Context,
    raw: bool = False,
):
    """
    Run a tool as a long-running MCP task, reporting progress/status updates to the LLM via mcp_task.
    """

    headers = get_authentication_headers(context)

    if not headers:
        return "The api key is missing."

    res = ptt.api.start_scan(target, tool_id, tool_params, scan_params, headers=headers)
    res_json = res.json()

    scan_id = res_json["data"]["created_id"]
    logging.info("Started scan %i, for tool_id %s", scan_id, tool_id)

    # Status groups
    progress_statuses = {"running", "waiting"}
    finished_statuses = {"finished"}
    failed_statuses = {
        "failed to start",
        "stopped",
        "timed out",
        "aborted",
        "VPN connection error",
        "auth failed",
        "connection error",
    }

    while True:
        await asyncio.sleep(2)

        # Get the status of our scan
        status = ptt.api.get_scan_status(scan_id, headers=headers)
        status_data = status.json()["data"]
        status_name = status_data["status_name"]

        # Compose progress message using the provided output structure
        progress_msg = (
            f"Scan {scan_id} is {status_name}.\n"
            f"Progress: {status_data.get('progress', 0.0)}\n"
            f"Status message: {status_data.get('status_message', '')}\n"
            f"Critical: {status_data.get('result_summary', {}).get('critical', 0)}, "
            f"High: {status_data.get('result_summary', {}).get('high', 0)}, "
            f"Medium: {status_data.get('result_summary', {}).get('medium', 0)}, "
            f"Low: {status_data.get('result_summary', {}).get('low', 0)}, "
            f"Info: {status_data.get('result_summary', {}).get('info', 0)}"
        )

        # Report progress if running or waiting
        if context is not None and status_name in progress_statuses:
            await context.report_progress(
                float(status_data.get("progress", 0.0)),
                total=100.0,
                message="Scan id " + str(scan_id) + " Status: " + str(status_name),
            )

        if status_name in finished_statuses:
            logging.debug("Scan status: %s" % status_data)
            logging.debug("Getting JSON report")

            if raw:
                res = ptt.api.get_raw_output(scan_id, headers=headers)
                return res.text

            res = ptt.api.get_output(scan_id, headers=headers)
            output_json = json.dumps(res.json())
            return output_json

        elif status_name in failed_statuses:
            # Report failure to the LLM
            if context is not None:
                await context.info(
                    f"Scan {scan_id} failed with status: {status_name}. Status message: {status_data.get('status_message', '')}"
                )
            return json.dumps(
                {
                    "error": f"Scan failed with status: {status_name}",
                    "details": status_data,
                }
            )

        # Otherwise, keep waiting and reporting progress


if FastMCP is not None:
    mcp = FastMCP("ptt-http", port=9000)

    ### Resources
    # TODO: Resources have not worked in vscode copilot. Try to make them work and test in other MCP clients as well.
    # Resources are generally the GET requests from API
    # @mcp.resource("scans://")
    # def get_scans() -> str:
    #     """Get the current running scans"""
    #     res = ptt.api.get_scans(headers=HEADERS)

    #     # TODO: json data may not be suitable for LLMs, at least for the less powerful ones.
    #     # Make the data more LLM friendly
    #     return json.dumps(res.json())

    # @mcp.resource("targets://")
    # def get_targets() -> str:
    #     """Get the current targets available"""
    #     res = ptt.api.get_targets(headers=HEADERS)

    #     return json.dumps(res.json())

    ### Prompts
    # Prompts should match the intended use-cases for the pentesttools MCP
    @mcp.prompt()
    def pentest(target: str) -> str:
        """Create a pentesting report prompt"""
        return f"Please provide a comprehensive pentesting report for this target: {target}, using the tools at your disposal."

    @mcp.prompt()
    def is_up(target: str) -> str:
        """Create a simple target checking prompt"""
        return f"Please see if this target: {target} is up, using the tools at your disposal."

    @mcp.prompt()
    def subdomains(target: str) -> str:
        """Discover all subdomains for the target domain"""
        return f"Please find all the subdomains that you can for this domain: {target}, using the tools at your disposal."

    @mcp.prompt()
    def translate(target: str) -> str:
        """Translates report findings in another language."""
        return f"Please use the tools at your disposal to extract the latest finding and translate it from English into {target}. Please take extra care not to translate things that should be in English, like URLs, API endpoints or other such resources. Additionally, you may keep the names of the vulnerabilities in English, if you deem that to be better."

    @mcp.prompt()
    def summary(workspace_id: int) -> str:
        """Create an executive summary for scans in a certain time period from workspace `workspace_id`"""
        return f"Please create an executive summary for the latest scans in the workspace {workspace_id}, using the tools at your disposal."

    ### Tools
    # These are the actual pentesting tools, with some added management tools, available through `ptt.api`

    # Pentesting tools
    @mcp.tool()
    async def run_website_scanner(target: str, context: Context) -> str:
        """
        Run a website scanner on the target URL.
        If you need to run a general website scan, this is the tool to use.
        If you need more information from a website under test, use this tool and tell the user you'll use this tool to accomplish your goal.

        Args:
            target: The target URL to scan.
        """
        return run_tool(
            ptt.api.Tool.WEBSITE_SCANNER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_website_scanner_long(target: str, context: Context) -> str:
        """
        Run a long-running website scanner on the target URL, reporting progress/status updates.

        Args:
            target: The target URL to scan.
            mcp_task: (optional) The MCP task object for reporting progress.
        """
        return await run_tool_long_running(
            ptt.api.Tool.WEBSITE_SCANNER,
            target,
            {"scan_type": "deep"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_icmp_ping(target: str, context: Context) -> str:
        """
        Run an icmp ping on the target URL.
        If you need to check that a target is reachable by ping or live, in general, this is the tool to use.

        Args:
            target: The target URL to ping.
        """

        return run_tool(
            ptt.api.Tool.ICMP_PING,
            target,
            {"scan_type": "light"},
            {},
            context,
            raw=True,
        )

    @mcp.tool()
    async def run_subdomain_finder(target: str, context: Context) -> str:
        """
        Run a subdomain finder scan on the target domain name.
        If you want to see all the findable subdomains on the target domain, this is the domain to use.

        It can be paired with website scans or api scans on the most important subdomains found.

        Args:
            target: The target domain to scan.
        """

        return run_tool(
            ptt.api.Tool.SUBDOMAIN_FINDER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_network_scanner(target: str, context: Context) -> str:
        """
        Run a network scanner on the target hostname.
        If you need to run a general network scan, something like nmap, this is the tool to use.
        If you need more information about the target network, use this tool and tell the user you'll use this tool to accomplish your goal.

        Args:
            target: The target hostname to scan.
        """

        return run_tool(
            ptt.api.Tool.NETWORK_SCANNER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_url_fuzzer(target: str, context: Context) -> str:
        """
        This tool, The URL Fuzzer, can be used to find hidden files and directories on a web server by fuzzing.

        This is a discovery activity that allows you to discover resources that were not meant to be publicly accessible (e.g. /backups, /index.php.old, /archive.tgz, /source_code.zip, etc.).
        Since 'security by obscurity' is not a good practice, you can often find sensitive information in the hidden locations identified by the URL Fuzzer.

        Args:
            target: The target path to scan
            It has the following format: https://example.com/test?id=FUZZ
        """

        return run_tool(
            ptt.api.Tool.URL_FUZZER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_whois_lookup(target: str, context: Context) -> str:
        """This tool allows you to perform Whois lookups online and extract information about domain names and IP addresses.

        Args:
            target: The internet resource that you want to find information about. This parameter can be an IP address or a domain name
        """
        return run_tool(
            ptt.api.Tool.WHOIS_LOOKUP,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_port_scanner(target: str, context: Context) -> str:
        """
        This tool can easily give you a quick overview of the network attack surface that includes all open TCP/UDP ports and services.

        Args:
            target: This is the hostname or the IP address to scan.
        """
        return run_tool(
            ptt.api.Tool.PORT_SCANNER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_vhosts_finder(target: str, context: Context) -> str:
        """This tool discovers the virtual hosts configured on a given IP address.
        This identifies the server on which you search for virtual hosts.
        If a hostname is given, DNS resolution will be attempted first to find its IP address.

        Args:
            target: IP address or Hostname.
        """
        return run_tool(
            ptt.api.Tool.VIRTUAL_HOSTS_FINDER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_sharepoint_scanner(target: str, context: Context) -> str:
        """
        This tool discovers various security weaknesses and vulnerabilities in web applications built on top of Microsoft SharePoint and FrontPage.

        Args:
            target: This is the URL of the SharePoint website that will be scanned. All URLs must start with 'http' or 'https'.
        """
        return run_tool(
            ptt.api.Tool.SHARE_POINT_SCANNER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_wordpress_scanner(target: str, context: Context) -> str:
        """
        This tool helps you discover security issues and vulnerabilities in the target WordPress website using the most advanced WordPress scanner: WPScan.

        Args:
            target: This is the URL of the WordPress website that will be scanned. All URLs must start with http or https. Don't forget to specify the complete path to the base directory of the WordPress installation. Ex. http://targetwp.com/blog/.
        """
        return run_tool(
            ptt.api.Tool.WORDPRESS_SCANNER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_drupal_scanner(target: str, context: Context) -> str:
        """
        This tool finds Drupal version, modules, theme, and their vulnerabilities. Checks for common Drupal misconfigurations and weak server settings.

        Args:
            target: This is the URL of the Drupal website that will be scanned. All URLs must start with http or https. Don't forget to specify the complete path to the base directory of the Drupal installation (if exists). Ex. http://targetdrupal.com/path/.
        """
        return run_tool(
            ptt.api.Tool.DRUPAL_SCANNER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_joomla_scanner(target: str, context: Context) -> str:
        """
        This tool performs a Joomla security assessment by finding vulnerabilities in Joomla core, components, modules, and templates.

        Args:
            target: This is the URL of the Joomla website that will be scanned. All URLs must start with http or https. Don't forget to specify the complete path to the base directory of the Joomla installation. Ex. http://targetjoomla.com/cms/.
        """
        return run_tool(
            ptt.api.Tool.JOOMLA_SCANNER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_website_recon(target: str, context: Context) -> str:
        """
        This tool allows you to discover the technologies used by a target web application - server-side and client-side. It can also scan multiple virtual hosts on the same IP.

        Args:
            target: Is the address of the website which will be searched for known technologies. Must start with http:// or https://
        """
        return run_tool(
            ptt.api.Tool.WEBSITE_RECON,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_sqli_exploiter(target: str, context: Context) -> str:
        """
        This tool allows you to confirm SQL Injection vulnerabilities in your site, to see the vulnerable parameters, and also to demonstrate the business risk by extracting data from the database. Powered by SQLMap.

        Args:
            target: This is the URL of the website that will be scanned. All URLs must start with http or https.
        """
        return run_tool(
            ptt.api.Tool.SQLI_EXPLOITER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_domain_finder(target: str, context: Context) -> str:
        """
        This tool discovers the domain names owned by a company and map its attack surface.

        Args:
            target: The target domain name (e.g. oracle.com, yahoo.com, etc.) that will be searched for associated domains
        """
        return run_tool(
            ptt.api.Tool.DOMAIN_FINDER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_password_auditor(target: str, context: Context) -> str:
        """
        This tool scans an URL, IP address, or hostname for network services that require authentication (ex. HTTP web forms, SSH, FTP, MYSQL, PostgreSQL, RDP, etc) and detects weak credentials by trying to log in using the usernames and passwords from the input wordlists.

        Args:
            target: This is the hostname or IP address to scan.
        """
        return run_tool(
            ptt.api.Tool.PASSWORD_AUDITOR,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_ssl_scanner(target: str, context: Context) -> str:
        """
        This tool connects to the target port and attempts to negotiate various cipher suites and multiple SSL/TLS versions to determine weak configurations and common vulnerabilities (ex. POODLE, Heartbleed, DROWN, ROBOT, etc.). The full version of the SSL Scanner scans multiple ports and services (HTTPS, SMTPs, IMAPs, etc.).

        Args:
            target: This specifies the target that will be scanned. It can be a single IP address or a hostname (ex. 8.8.8.8 or www.example.com)
        """
        return run_tool(
            ptt.api.Tool.SSL_SCANNER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_sniper(target: str, context: Context) -> str:
        """
        This tool automatically exploits known, widespread vulnerabilities in high-profile software. The tool gains remote command execution on the vulnerable targets and automatically runs post-exploitation modules to extract interesting data (artefacts) as solid proof for vulnerability validation.

        Args:
            target: Specifies the system that will be scanned. Target can be an IP address, hostname or an URL.
        """
        return run_tool(
            ptt.api.Tool.SNIPER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_waf_detector(target: str, context: Context) -> str:
        """
        This tool discovers if a website is protected by a web application firewall (WAF).

        Args:
            target: This is the URL of the website that will be scanned. All URLs must start with http:// or https://.
        """
        return run_tool(
            ptt.api.Tool.WAF_DETECTOR,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_api_scanner(target: str, context: Context) -> str:
        """
        This tool is a custom tool designed to assess the security of REST and GraphQL APIs quickly.

        Args:
            target: This is the URL of the API that will be scanned.
        """
        return run_tool(
            ptt.api.Tool.API_SCANNER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_cloud_scanner(target: str, context: Context) -> str:
        """
        This tool evaluates multi-cloud environments (Amazon Web Services - AWS and Google Cloud Platform - GCP) to identify misconfigurations, vulnerabilities, weak access controls, interesting files, and other security issues.
        A penetration tester can use the tool to discover and confirm security vulnerabilities in cloud infrastructure and report them.

        Args:
            target: Specifies the system to be scanned. Target can be an IP address, hostname or URL. If you want to scan an AWS S3 bucket, you can input it in the URL form: http(s)://<bucket_name>.s3.amazonaws.com. If you want to scan a Google Cloud Storage bucket, you can input it in the URL form: https://storage.googleapis.com/<bucket_name>
        """
        return run_tool(
            ptt.api.Tool.CLOUD_SCANNER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_people_hunter(target: str, context: Context) -> str:
        """
        This tool discovers email addresses and social media profiles from a web application.

        Args:
            target: Specifies the system to be scanned. Target can be an IP address or a hostname.
        """
        return run_tool(
            ptt.api.Tool.PEOPLE_HUNTER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    @mcp.tool()
    async def run_kubernetes_scanner(target: str, context: Context) -> str:
        """
        This tool automates the search for security vulnerabilities and misconfigurations in Kubernetes clusters. Its findings vary from reconnaissance to initial access vulnerabilities.

        Args:
            target: Specifies the target that will be scanned. It can be a single IP address or a hostname (ex. www.example.com)
        """
        return run_tool(
            ptt.api.Tool.KUBERNETES_SCANNER,
            target,
            {"scan_type": "light"},
            {"max_scan_time": "5"},
            context,
        )

    # Administrative tools
    @mcp.tool()
    async def get_scan_output_by_id(scan_id: str, context: Context) -> str:
        """Get the scan report as json output, by scan_id"""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"

        res = ptt.api.get_output(scan_id, headers=headers)

        return json.dumps(res.json())

    @mcp.tool()
    async def get_findings(context: Context) -> str:
        """Get all the findings that you have"""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.get_findings(headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def get_all_reports(context: Context) -> str:
        """Get all the reports that you have"""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.get_all_reports(headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def get_targets(context: Context) -> str:
        """Get the current targets available."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.get_targets(headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def get_scans(context: Context) -> str:
        """Get the current running scans."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.get_scans(headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def get_scan_status(scan_id: str, context: Context) -> str:
        """Get the status of a scan by scan_id."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.get_scan_status(scan_id, headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def get_raw_output(scan_id: str, context: Context) -> str:
        """Get the raw output of a scan by scan_id."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.get_raw_output(scan_id, headers=headers)
        return res.text

    @mcp.tool()
    async def get_output(scan_id: str, context: Context) -> str:
        """Get the parsed output of a scan by scan_id."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.get_output(scan_id, headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def start_scan_by_targetid(
        target_id: int, tool_id: int, tool_params: dict, context: Context
    ) -> str:
        """Start a scan using the given target_id."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.start_scan_by_targetid(
            target_id, tool_id, tool_params, headers=headers
        )
        return json.dumps(res.json())

    @mcp.tool()
    async def stop_scan(scan_id: int, context: Context) -> str:
        """Stop a running scan."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.stop_scan(scan_id, headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def delete_scan(scan_id: int, context: Context) -> str:
        """Delete a scan."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.delete_scan(scan_id, headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def add_target(
        name: str,
        description: str = "",
        workspace_id: int = None,
        context: Context = None,
    ) -> str:
        """Add a new target."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.add_target(name, description, workspace_id, headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def delete_target(target_id: int, context: Context) -> str:
        """Delete a target and its scans."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.delete_target(target_id, headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def create_report(
        format: Literal["pdf", "html", "json", "csv", "xlsx", "docx"],
        group_by: Literal["target", "vulnerability"],
        source: Literal["scans", "findings"],
        resources: list[int],
        context: Context,
        filters: dict = None,
        webhook_url: str = None,
    ) -> str:
        """Create a pentesting report, based on the findings already present in the platform.

        Args:
            format: The format in which to create the report. Possible values: pdf, html, json, csv, xlsx, docx.
            group_by: What key is used to create the report. Possible values: target, vulnerability.
            source: This is the source that is used to create the report. Possible values: scans, findings.
            resources: A list of ids, depeding on which source was chosen. If `scans` was chosed, then it's a list of scan_ids. If `findings` was chosed, then it's a list of finding_ids.
        """
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.create_report(
            format, group_by, source, resources, filters, webhook_url, headers=headers
        )
        return json.dumps(res.json())

    @mcp.tool()
    async def delete_report(report_id: int, context: Context) -> str:
        """Delete a report by its ID."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.delete_report(report_id, headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def download_report(report_id: int, context: Context) -> str:
        """Download a report by its ID."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.download_report(report_id, headers=headers)
        return res.text

    @mcp.tool()
    async def create_http_logger(
        label: str, context: Context, workspace_id: int = None
    ) -> str:
        """Create a new HTTP request logger."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.create_http_logger(label, workspace_id, headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def delete_logger(logger_id: int, context: Context) -> str:
        """Delete an HTTP logger by its ID."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.delete_logger(logger_id, headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def clear_data_for_logger(logger_id: int, context: Context) -> str:
        """Clear all data captured by a specific HTTP logger."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.clear_data_for_logger(logger_id, headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def create_workspace(
        name: str, context: Context, description: str = ""
    ) -> str:
        """Create a new workspace."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.create_workspace(name, description, headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def delete_workspace(workspace_id: int, context: Context) -> str:
        """Delete a workspace by its ID."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.delete_workspace(workspace_id, headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def edit_workspace(
        workspace_id: int, context: Context, name: str = None, description: str = None
    ) -> str:
        """Edit an existing workspace."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.edit_workspace(workspace_id, name, description, headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def get_workspaces(context: Context) -> str:
        """Get all workspaces."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.get_workspaces(headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def get_workspace_by_id(workspace_id: int, context: Context) -> str:
        """Get information about a specific workspace by its ID."""
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"
        res = ptt.api.get_workspace_by_id(workspace_id, headers=headers)
        return json.dumps(res.json())

    @mcp.tool()
    async def import_findings(
        target_name: str, finding_name: str, context: Context, workspace_id: int = 1
    ) -> str:
        """This tools is used to add new findings, in addition to the existing ones that come from scans.

        This is the only tool you can use to create new findings. If your tasks include creating new findings, you have to use this tool.

        Args:
            target_name: the name of the target for which we wish to add the findings.
            finding_name: the name of the finding we want to create.
            workspace_id: the workspace for which you want to add findings. Default: 1.
        """
        headers = get_authentication_headers(context)
        if not headers:
            return "The api key was not set"

        res = ptt.api.import_findings(
            target_name, finding_name, workspace_id, headers=headers
        )
        return json.dumps(res.json())


def entrypoint(mcp_method: str = "stdio"):
    """Entrypoint for ptt-mcp"""
    global MCP_METHOD

    logging.basicConfig(
        level=logging.DEBUG,
        format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    )

    if FastMCP is None:
        logging.error(
            "PentestTools has been installed without MCP support. Install with pip install PentestTools[mcp] if you want MCP support."
        )
        return

    logging.info("Starting the PentestTools MCP server")
    if mcp_method == "stdio":
        logging.info("Using the `stdio` mcp type")
        MCP_METHOD = "stdio"

        # Get the api key for stdio
        if not getattr(ptt.api, "api_key", False):
            api_key = os.getenv("PTT_KEY", "")
            if not api_key:
                sys.exit(
                    "API key not found. Please provide it using the --key flag or set the PTT_KEY environment variable."
                )

            ptt.api.api_key = api_key

        ptt.api.init()  # This call sets the given key

        return mcp.run(transport="stdio")
    elif mcp_method == "http":
        logging.info("Using the `http` mcp type")
        MCP_METHOD = "http"
        return mcp.run(transport="streamable-http")
