#!/usr/bin/env python3
from __future__ import annotations

import json
import re
from collections import defaultdict
from pathlib import Path

IN = Path("mimeData.json")
OUT = Path("src/mime_enum/mimetype.py")

# ---- helpers ---------------------------------------------------------------


def sanitize_member_name(mime: str) -> str:
    # "application/vnd.hp-jlyt" -> "APPLICATION_VND_HP_JLYT"
    name = re.sub(r"[^A-Za-z0-9]+", "_", mime.upper()).strip("_")
    if not name or name[0].isdigit():
        name = "MIME_" + name
    return name


def strip_dot(ext: str) -> str:
    return ext.lstrip(".").lower()


def is_vendor(mime: str) -> bool:
    # prefer non-vendor when deciding extension conflicts
    # (vendor types start with application/vnd., model/vnd., etc.)
    return "/vnd." in mime


def choose_canonical_for_ext(candidates: list[str]) -> str:
    # Prefer non-vendor; otherwise first
    non_vendor = [m for m in candidates if not is_vendor(m)]
    return (non_vendor or candidates)[0]


def py_tuple_str(items: list[str]) -> str:
    """Render a Python tuple literal from a list of strings."""
    if not items:
        return "()"
    if len(items) == 1:
        return f"('{items[0]}',)"  # note the trailing comma
    return "(" + ", ".join(f"'{e}'" for e in items) + ")"


# ---- load ------------------------------------------------------------------

db = json.loads(IN.read_text())  # expect a list of entries

# normalize input: {mime: {"exts":[...], "aliases":[...]}}
entries: dict[str, dict] = {}
alias_map: dict[str, set[str]] = defaultdict(set)

for item in db:
    mime = item.get("name")
    if not mime:
        continue
    mime = mime.strip().lower()
    exts = [strip_dot(e) for e in item.get("fileTypes") or [] if e]
    entries.setdefault(mime, {"exts": set(), "aliases": set()})
    entries[mime]["exts"].update(exts)

    links = item.get("links") or {}
    for key in ("deprecates", "alternativeTo"):
        for alias in links.get(key, []) or []:
            a = str(alias).strip().lower()
            if a and a != mime:
                alias_map[mime].add(a)

# also invert alias_map into alias -> target
alias_to_target: dict[str, str] = {}
for target, aliases in alias_map.items():
    for a in aliases:
        # keep first winner if dup appears
        alias_to_target.setdefault(a, target)

# Build extension → canonical mime (resolve conflicts)
ext_to_mimes: dict[str, list[str]] = defaultdict(list)
for m, data in entries.items():
    for ext in data["exts"]:
        if ext:
            ext_to_mimes[ext].append(m)

ext_to_mime: dict[str, str] = {ext: choose_canonical_for_ext(mimes) for ext, mimes in ext_to_mimes.items()}

# ---- emit ------------------------------------------------------------------

# Define simple aliases for commonly used MIME types with long names
SIMPLE_ALIASES = {
    # Microsoft Office formats
    "APPLICATION_DOCX": "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    "APPLICATION_XLSX": "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
    "APPLICATION_PPTX": "application/vnd.openxmlformats-officedocument.presentationml.presentation",
    "APPLICATION_DOTX": "application/vnd.openxmlformats-officedocument.wordprocessingml.template",
    "APPLICATION_XLTX": "application/vnd.openxmlformats-officedocument.spreadsheetml.template",
    "APPLICATION_POTX": "application/vnd.openxmlformats-officedocument.presentationml.template",
    "APPLICATION_PPSX": "application/vnd.openxmlformats-officedocument.presentationml.slideshow",
    "APPLICATION_SLDX": "application/vnd.openxmlformats-officedocument.presentationml.slide",
}

lines = []
lines.append("# Auto-generated by scripts/generate_mimetypes.py — DO NOT EDIT.")
lines.append("# Data source: mimetype-io (https://github.com/patrickmccallum/mimetype-io)")
lines.append("")
lines.append("from __future__ import annotations")
lines.append("from enum import StrEnum")
lines.append("")
lines.append("")
lines.append("class MimeType(StrEnum):")
lines.append('    """MIME type enumeration with associated file extensions.')
lines.append("    ")
lines.append("    Auto-generated enum containing standard MIME types as string values.")
lines.append("    Each enum member has an associated `.extensions` attribute containing")
lines.append("    a tuple of common file extensions for that MIME type.")
lines.append("    ")
lines.append("    The enum values are the official MIME type strings (e.g., 'application/json'),")
lines.append("    and can be used directly as strings in HTTP headers, content-type detection,")
lines.append("    and other applications.")
lines.append("    ")
lines.append("    Attributes:")
lines.append("        extensions: Tuple of file extensions associated with this MIME type")
lines.append("        ")
lines.append("    Examples:")
lines.append("        >>> MimeType.APPLICATION_JSON")
lines.append("        'application/json'")
lines.append("        >>> MimeType.APPLICATION_JSON.extensions")
lines.append("        ('json',)")
lines.append("        >>> str(MimeType.TEXT_HTML)")
lines.append("        'text/html'")
lines.append('    """')
lines.append("")
lines.append("    def __new__(cls, value: str, extensions: tuple[str, ...] = ()):  # type: ignore[override]")
lines.append("        obj = str.__new__(cls, value)")
lines.append("        obj._value_ = value")
lines.append("        obj.extensions = extensions")
lines.append("        return obj")
lines.append("")

# members
for mime, data in sorted(entries.items()):
    member = sanitize_member_name(mime)
    exts_sorted = sorted(data["exts"])
    exts_tuple = py_tuple_str(exts_sorted)
    lines.append(f"    {member} = ('{mime}', {exts_tuple})")
lines.append("")

# Add simple aliases as class attributes
lines.append("    # Convenient aliases for commonly used MIME types with verbose names")
for alias_name, target_mime in sorted(SIMPLE_ALIASES.items()):
    if target_mime in entries:  # Only add aliases for MIME types that exist in our data
        target_member = sanitize_member_name(target_mime)
        # Avoid self-referential aliases (where alias name == target member name)
        if alias_name != target_member:
            lines.append(f"    {alias_name} = {target_member}")
lines.append("")

# alias dict
lines.append("_ALIASES: dict[str, MimeType] = {")
for alias, target in sorted(alias_to_target.items()):
    lines.append(f"    '{alias}': MimeType('{target}'),")
lines.append("}")
lines.append("")

# ext map
lines.append("_EXT_TO_MIME: dict[str, MimeType] = {")
for ext, mime in sorted(ext_to_mime.items()):
    lines.append(f"    '{ext}': MimeType('{mime}'),")
lines.append("}")
lines.append("")

OUT.write_text("\n".join(lines) + "\n")
print(f"Wrote {OUT}")
