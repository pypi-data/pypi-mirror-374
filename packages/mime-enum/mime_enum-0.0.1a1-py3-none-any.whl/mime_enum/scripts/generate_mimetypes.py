#!/usr/bin/env python3
from __future__ import annotations

import json
import re
from collections import defaultdict
from pathlib import Path

IN = Path("mimeData.json")
OUT = Path("src/mime_enum/mimetype.py")

# ---- helpers ---------------------------------------------------------------


def sanitize_member_name(mime: str) -> str:
    # "application/vnd.hp-jlyt" -> "APPLICATION_VND_HP_JLYT"
    name = re.sub(r"[^A-Za-z0-9]+", "_", mime.upper()).strip("_")
    if not name or name[0].isdigit():
        name = "MIME_" + name
    return name


def strip_dot(ext: str) -> str:
    return ext.lstrip(".").lower()


def is_vendor(mime: str) -> bool:
    # prefer non-vendor when deciding extension conflicts
    # (vendor types start with application/vnd., model/vnd., etc.)
    return "/vnd." in mime


def choose_canonical_for_ext(candidates: list[str]) -> str:
    # Prefer non-vendor; otherwise first
    non_vendor = [m for m in candidates if not is_vendor(m)]
    return (non_vendor or candidates)[0]


def py_tuple_str(items: list[str]) -> str:
    """Render a Python tuple literal from a list of strings."""
    if not items:
        return "()"
    if len(items) == 1:
        return f"('{items[0]}',)"  # note the trailing comma
    return "(" + ", ".join(f"'{e}'" for e in items) + ")"


# ---- load ------------------------------------------------------------------

db = json.loads(IN.read_text())  # expect a list of entries

# normalize input: {mime: {"exts":[...], "aliases":[...]}}
entries: dict[str, dict] = {}
alias_map: dict[str, set[str]] = defaultdict(set)

for item in db:
    mime = item.get("name")
    if not mime:
        continue
    mime = mime.strip().lower()
    exts = [strip_dot(e) for e in item.get("fileTypes") or [] if e]
    entries.setdefault(mime, {"exts": set(), "aliases": set()})
    entries[mime]["exts"].update(exts)

    links = item.get("links") or {}
    for key in ("deprecates", "alternativeTo"):
        for alias in links.get(key, []) or []:
            a = str(alias).strip().lower()
            if a and a != mime:
                alias_map[mime].add(a)

# also invert alias_map into alias -> target
alias_to_target: dict[str, str] = {}
for target, aliases in alias_map.items():
    for a in aliases:
        # keep first winner if dup appears
        alias_to_target.setdefault(a, target)

# Build extension → canonical mime (resolve conflicts)
ext_to_mimes: dict[str, list[str]] = defaultdict(list)
for m, data in entries.items():
    for ext in data["exts"]:
        if ext:
            ext_to_mimes[ext].append(m)

ext_to_mime: dict[str, str] = {ext: choose_canonical_for_ext(mimes) for ext, mimes in ext_to_mimes.items()}

# ---- emit ------------------------------------------------------------------

lines = []
lines.append("# Auto-generated by scripts/generate_mimetypes.py — DO NOT EDIT.")
lines.append("from __future__ import annotations")
lines.append("from enum import StrEnum")
lines.append("")
lines.append("")
lines.append("class MimeType(StrEnum):")
lines.append('    """Generated MIME type enum with extension tuples on `.extensions`."""')
lines.append("")
lines.append("    def __new__(cls, value: str, extensions: tuple[str, ...] = ()):  # type: ignore[override]")
lines.append("        obj = str.__new__(cls, value)")
lines.append("        obj._value_ = value")
lines.append("        obj.extensions = extensions")
lines.append("        return obj")
lines.append("")

# members
for mime, data in sorted(entries.items()):
    member = sanitize_member_name(mime)
    exts_sorted = sorted(data["exts"])
    exts_tuple = py_tuple_str(exts_sorted)
    lines.append(f"    {member} = ('{mime}', {exts_tuple})")
lines.append("")

# alias dict
lines.append("_ALIASES: dict[str, MimeType] = {")
for alias, target in sorted(alias_to_target.items()):
    lines.append(f"    '{alias}': MimeType('{target}'),")
lines.append("}")
lines.append("")

# ext map
lines.append("_EXT_TO_MIME: dict[str, MimeType] = {")
for ext, mime in sorted(ext_to_mime.items()):
    lines.append(f"    '{ext}': MimeType('{mime}'),")
lines.append("}")
lines.append("")

OUT.write_text("\n".join(lines) + "\n")
print(f"Wrote {OUT}")
