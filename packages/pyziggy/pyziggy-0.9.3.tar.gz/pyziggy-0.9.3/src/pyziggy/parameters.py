# pyziggy - Run automation scripts that interact with zigbee2mqtt.
# Copyright (C) 2025 Attila Szarvas
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""
Contains the parameter classes that your code can interact with in order to query and
modify the device states observable through MQTT.

You are not expected to directly instantiate any of these classes. The main feature of
pyziggy is its code generator. The generator will query device information from the MQTT
broker and generate the ``pyziggy_autogenerate.available_devices.AvailableDevices``
class in your home automation project directory. The public members of this class are
all the devices that your MQTT broker knows of. The public members of each device are
parameter objects, which are instances of the classes in this module.

You are expected to only instantiate an AvailableDevices object, and access the
autogenerated parameters of its autogenerated devices.

Zigbee2MQTT has access flags for each parameter. A parameter may be either queryable or
not, and it may either be read-only or writeable as well. Accordingly, each
autogenerated parameter object will have the parameter type determined by the access
flags.

Example:
    Your automation code should access the autogenerated parameters under the devices::

        from pyziggy_autogenerate.available_devices import AvailableDevices

        devices = AvailableDevices()

        devices.kitchen_light.brightness.set(100)

    You can add listeners to be notified of parameter changes::

        kitchen_brightness = devices.kitchen_light.brightness
        kitchen_brightness.add_listener(lambda: print(f"Brightness: {kitchen_brightness.get()}"))
"""

from __future__ import annotations

import logging
from abc import abstractmethod
from enum import Enum
from typing import Dict, Union, List, Any, final, override
from typing import Type, TypeVar

from . import message_loop as ml
from .broadcasters import Broadcaster, AnyBroadcaster

logger = logging.getLogger(__name__)


class ParameterBase(Broadcaster):
    """
    A base class for all other parameter types.

    This type inherits from :class:`pyziggy.broadcasters.Broadcaster`, so you can call
    :meth:`pyziggy.broadcasters.Broadcaster.add_listener` on all parameter objects to be
    notified when their value changes.
    """

    def __init__(self, property: str):
        super().__init__()
        self._property: str = property
        self._wants_to_call_listeners_broadcaster = Broadcaster()
        self._wants_to_call_listeners_synchronously_broadcaster = AnyBroadcaster()
        self._wants_to_query_device_boradcaster = Broadcaster()
        self._should_call_listeners = False

        # Setting this to True is only allowed for gettable devices.
        # See zigbee2mqtt access property
        self._should_query_device: bool = False

        # Setting this to True is only allowed for settable devices.
        # See zigbee2mqtt access property
        self._should_send_to_device: bool = False

        self._use_synchronous_callbacks: bool = False

    @final
    def get_property_name(self):
        """
        Used internally. You generally shouldn't need to call this function, as the
        property name isn't used anywhere on the pyziggy public APIs.

        :return: The name of the parameter as it's known by MQTT.
        """
        return self._property

    @final
    def _query_device(self):
        self._should_query_device = True
        self._wants_to_query_device_boradcaster._call_listeners()

    @abstractmethod
    def _set_reported_value(self, value: Any) -> None:
        pass

    @abstractmethod
    def _append_dictionary_sent_to_device(
        self, out_dict: Dict[str, Union[bool, int, str]]
    ) -> None:
        pass

    @abstractmethod
    def _should_device_be_queryied(self) -> bool:
        pass

    @abstractmethod
    def _call_listeners_if_necessary(self):
        pass


class NumericParameter(ParameterBase):
    """
    A parameter stored as a single floating point number, and limited to between a
    minimum and maximum value.

    This value is used to represent Z2M parameters whether they have an integral or
    floating point representation and granularity.

    The minimum and maximum values are determined by the pyziggy generator based on the
    parameter information shared by Z2M. Sometimes Z2M fails to report these values,
    specifically I've seen them missing for members of CompositeParameters.
    In this case the generator will choose a very large default range to avoid
    accidentally clamping the values exchanged with Z2M.
    """

    def __init__(self, property: str, min_value: float, max_value: float):
        super().__init__(property)
        self._report_delay_tolerance: float = 1.0
        self._requested_value: float = 0
        self._requested_timestamp: float = 0
        self._reported_value: float = 0
        self._reported_timestamp: float = 0
        self._min_value: float = min_value
        self._max_value: float = max_value
        self._always_call_listeners_on_report = False

    def get_minimum(self) -> float:
        """
        :return: The lower limit (inclusive) of this parameter's permitted range.
        """
        return self._min_value

    def get_maximum(self) -> float:
        """
        :return: The upper limit (inclusive) of this parameter's permitted range.
        """
        return self._min_value

    def set_call_listeners_synchronously(self, value: bool) -> None:
        """
        Sets whether the parameter's listeners should be called synchronously when the
        value changes.

        The default setting is False.

        The pyziggy framework has a workarounds module that tries to ensure that this
        value is set to True whenever it makes sense, so you generally shouldn't need to
        call this function.

        **Default parameter listener callback behavior**:

            Parameter callbacks are called asynchronously by default. A practical
            consequence of this, is that ``callback`` in the following example will
            only be called at most once after ``event_handler`` has run. It will only
            happen if the parameter value has changed since the last time the listeners
            were called.

            Example::

                def callback():
                    print(f"Brightness changed to: {devices.light.brightness.get()}")

                devices.light.brightness.add_listener(callback)

                def event_handler():
                    devices.light.brightness.set(20)
                    devices.light.brightness.set(30)
                    devices.light.brightness.set(40)

            This also means that ``callback`` cannot observe the transient values during
            the execution of ``event_handler``. This behavior is intentional and is
            meant to avoid cascading event callback storms in callback heavy projects.

        **Discussion**:

            Calling this function with True is useful for parameters where transient
            values are significant. For example, it's possible that we receive multiple
            consecutive changes to a parameter's value in a single sub-second message
            window, but we still need to to observe and serve them all. An *action*
            parameter of a rotary dial, or brightness increasing switch could be such a
            parameter.

            As a counter example, if the brightness of a bulb changes in quick succession
            from 0 to 40 in 0.1 seconds, we probably don't want to take action on all the
            intermediate values, but only on the final value at the end of the 0.1 second
            period.
        """
        self._use_synchronous_callbacks = value

    def set_always_call_listeners_on_report(self, value: bool) -> None:
        """
        Call this function with a True value to always call listeners whenever an
        update is received from Z2M for the parameter.

        The default setting is False.

        By default, listeners are only called if the update received from Z2M changes
        the value compared to the last time when the listeners were called.

        The pyziggy framework has a workarounds module that tries to ensure that this
        value is set to True whenever it makes sense, so you generally shouldn't need to
        call this function.

        For example the True setting is useful for *action* parameters in general.
        Certain light switches for example will send a parameter update for the *action*
        parameter with a *brightness_up* value, whenever the brightness increase button
        is pressed.
        """
        self._always_call_listeners_on_report = value

    def _reported_value_is_probably_up_to_date(self):
        if self._should_send_to_device:
            return False

        if self._reported_timestamp == 0:
            return False

        if self._reported_timestamp - self._requested_timestamp > 0.2:
            return True

        if ml.time_source.perf_counter() - self._reported_timestamp > 1.0:
            return True

        return False

    @final
    def get(self) -> float:
        """
        :return: The parameter's raw value as it is known by Z2M.
        """
        if self._reported_value_is_probably_up_to_date():
            return self._reported_value

        return self._requested_value

    @final
    def get_normalized(self) -> float:
        """
        :return: The parameter's value mapped to the range [0.0, 1.0].
                 The range's start and end represent the values returned by
                 :func:`get_minimum()` and :func:`get_maximum()` and the mapping is
                 linear.
        """
        return (self.get() - self._min_value) / (self._max_value - self._min_value)

    @final
    @override
    def _set_reported_value(self, value: Any) -> None:
        old_value = self.get()
        new_value = self._transform_mqtt_to_internal_value(value)
        old_reported_timestamp = self._reported_timestamp
        new_reported_timestamp = ml.time_source.perf_counter()

        if old_value != new_value or self._always_call_listeners_on_report:
            if self._use_synchronous_callbacks:
                self._wants_to_call_listeners_synchronously_broadcaster._call_listeners(
                    lambda callback: callback(self)
                )
            else:
                self._should_call_listeners = True
                self._wants_to_call_listeners_broadcaster._call_listeners()

        self._reported_value = new_value
        self._reported_timestamp = new_reported_timestamp

    @final
    @override
    def _append_dictionary_sent_to_device(
        self, out_dict: Dict[str, Union[bool, int, str]]
    ) -> None:
        if not self._should_send_to_device:
            return

        out_dict[self._property] = self._transform_internal_to_mqtt_value(self.get())
        self._should_send_to_device = False

    @final
    @override
    def _should_device_be_queryied(self) -> bool:
        if self._should_query_device:
            self._should_query_device = False
            return True

        return False

    @final
    @override
    def _call_listeners_if_necessary(self):
        if self._should_call_listeners:
            self._should_call_listeners = False
            self._call_listeners()

    def _transform_internal_to_mqtt_value(self, value: float) -> Any:
        return value

    def _transform_mqtt_to_internal_value(self, value: Any) -> float:
        return value


class SettableNumericParameter(NumericParameter):
    """
    A parameter representing a Z2M *numeric* parameter with a *flags* property that is
    *settable*.
    """

    def __init__(self, property: str, min_value: float, max_value: float):
        super().__init__(property, min_value, max_value)
        self._stale = True

    def mark_as_stale(self):
        """
        Use this function to mark the parameter as stale, if for whatever reason,
        we can't assume that the parameter's value correctly reflects the physical
        device's state.

        This will override the default logic where the :func:`set` and
        :func:`set_normalized` functions only emit MQTT messages if the parameter's
        stored state is different from the new one.

        This way you can practically force emitting an MQTT message that requires the
        device parameter to be set to the required value. The first :func:`set` or
        :func:`set_normalized` call clears the stale state, returning the parameter
        logic to follow the default behavior.
        """
        self._stale = True

    def set(self, value: float) -> None:
        """
        Set the parameter's desired value. This will instruct Z2M to change the
        corresponding device's parameter to this value.

        The provided value should be in the MQTT parameter's original range
        e.g. a typical *brightness* parameter will have raw values between 0 and 254,
        and a *color_temp* parameter between 250 and 454.

        The passed in value will be clamped to the permitted range.

        **MQTT communication behavior**:

            The pyziggy framework keeps track of parameter values sent and received and has
            logic to avoid unnecessarily sending MQTT messages. Calling :func:`set` with
            the same value that the parameter already has will not emit any MQTT messages,
            unless :func:`mark_as_stale` has been called on the parameter prior to
            :func:`set`.

            The logic that determines whether a parameter value changed runs
            asynchronously, and this is responsible for sending the MQTT messages as
            well. This means that it can only happen after the entire call stack has
            been unwound on which :func:`set` has been called. A practical consequence
            of this, is that the callback in the following example can emit at most a
            single MQTT message. It will do so if the final value of the parameter is
            different from what Z2M thinks it is.

            Example::

                def callback():
                    devices.light_bulb.brightness.set(10)
                    devices.light_bulb.brightness.set(20)
                    devices.light_bulb.brightness.set(30)
                    devices.light_bulb.brightness.set(40)

                devices.light_switch.action.add_listener(callback)

            This behavior is intentional and is meant to eliminate unnecessary MQTT
            communication in callback heavy projects.
        """
        value = min(self._max_value, max(self._min_value, value))

        if value != self.get() or self._stale:
            self._requested_value = min(self._max_value, max(self._min_value, value))
            self._requested_timestamp = ml.time_source.perf_counter()
            self._should_send_to_device = True
            self._should_call_listeners = True

            if self._use_synchronous_callbacks:
                self._wants_to_call_listeners_synchronously_broadcaster._call_listeners(
                    lambda listener: listener(self)
                )
            else:
                self._wants_to_call_listeners_broadcaster._call_listeners()

        self._stale = False

    def set_normalized(self, value: float) -> None:
        """
        Set the parameter's desired value by passing a number between 0.0 and 1.0.

        This value will be automatically converted to the range of the MQTT parameter
        e.g. a typical *brightness* parameter will have raw values between 0 and 254,
        and a *color_temp* parameter between 250 and 454. Calling ``set_normalized(0.0)``
        or ``set_normalized(1.0)`` will set both to their respective minimum or maximum
        values.

        The passed in value will be clamped to the permitted range.

        This function internally calls :func:`set`, consequently its *MQTT
        communication behavior* is the same.
        """
        self.set(
            float(round(value * (self._max_value - self._min_value) + self._min_value))
        )

    def add(self, value: float) -> None:
        """
        Equivalent to calling ``set(get() + value)``.

        The resulting value will be clamped to the permitted range.
        """
        self.set(self.get() + value)

    def add_normalized(self, value: float) -> None:
        """
        Equivalent to calling ``set_normalized(get_normalized() + value)``.

        The resulting value will be clamped to the permitted range.
        """
        self.set_normalized(self.get_normalized() + value)


class QueryableNumericParameter(NumericParameter):
    """
    A parameter representing a Z2M *numeric* parameter with a *flags* property that is
    *queryable*.
    """

    def query_device(self) -> None:
        """
        Instructs Z2M to query the device for the current value of this parameter.

        This can typically be available for battery powered devices that don't update
        their actual parameter values frequently.

        If the query procedure is successful Z2M will send a value update, which updates
        the parameter value and fires any added listeners.
        """
        self._query_device()


class SettableAndQueryableNumericParameter(
    QueryableNumericParameter, SettableNumericParameter
):
    """
    A parameter representing a Z2M *numeric* parameter with a *flags* property that is
    *settable* and *queryable*.
    """

    pass


class BinaryParameter(NumericParameter):
    """
    A two state parameter that can have a valid value of 0 or 1.

    Represents MQTT parameters whose *definition.features.type* property is *binary*.
    """

    def __init__(self, property: str):
        super().__init__(property, 0, 1)

    def _transform_internal_to_mqtt_value(self, value: float) -> Any:
        return True if value == 1 else False

    def _transform_mqtt_to_internal_value(self, value: Any) -> float:
        return 1 if value == True else 0


class QueryableBinaryParameter(BinaryParameter, QueryableNumericParameter):
    """
    A BinaryParameter representing a Z2M parameter with a *flags* property that is *queryable*
    """

    pass


class SettableBinaryParameter(BinaryParameter, SettableNumericParameter):
    """
    A parameter representing a Z2M *binary* parameter with a *flags* property that is
    *settable*.
    """

    pass


class SettableAndQueryableBinaryParameter(
    BinaryParameter, SettableAndQueryableNumericParameter
):
    """
    A parameter representing a Z2M *binary* parameter with a *flags* property that is
    *settable* and *queryable*.
    """

    pass


class ToggleParameter(NumericParameter):
    """
    A two state parameter that can have a valid value of 0 or 1.

    Represents MQTT parameters whose *definition.features.type* property is *toggle*.
    """

    def __init__(self, property: str):
        super().__init__(property, 0, 1)

    def _transform_internal_to_mqtt_value(self, value: float) -> Any:
        return "ON" if value == 1 else "OFF"

    def _transform_mqtt_to_internal_value(self, value: Any) -> float:
        return 1 if value == "ON" else 0


class QueryableToggleParameter(ToggleParameter, QueryableNumericParameter):
    """
    A parameter representing a Z2M *toggle* parameter with a *flags* property that is
    *queryable*.
    """

    pass


class SettableToggleParameter(ToggleParameter, SettableNumericParameter):
    """
    A parameter representing a Z2M *toggle* parameter with a *flags* property that is
    *settable*.
    """

    pass


class SettableAndQueryableToggleParameter(
    ToggleParameter, SettableAndQueryableNumericParameter
):
    """
    A parameter representing a Z2M *toggle* parameter with a *flags* property that is
    *settable* and *queryable*.
    """

    pass


class EnumParameter(NumericParameter):
    """
    Base class for parameters that have a corresponding Z2M parameter with a *type* of
    *enum*.

    The pyziggy autogenerator generates derived classes that return and take concrete
    enum types also autogenerated based on Z2M parameter information. These derived
    classes will all have a public ``enum_type`` member to provide type safety and code
    completion.

    Example::

        def light_switch_handler():
            action_enum = devices.light_switch.action.enum_type
            action = devices.light_switch.action.get_enum_value()

            if action == action_enum.brightness_move_up:
                kitchen_light.brightness.add_normalized(0.075)
            elif action == action_enum.brightness_move_down:
                kitchen_light.brightness.add_normalized(-0.075)

        devices.light_switch.action.add_listener(light_switch_handler)
    """

    def __init__(self, property: str, enum_values: List[str]):
        super().__init__(property, 0, len(enum_values))
        self._enum_values = enum_values

    def _transform_internal_to_mqtt_value(self, value: float) -> Any:
        return self._enum_values[int(value)]

    def _transform_mqtt_to_internal_value(self, value: Any) -> float:
        for i in range(0, len(self._enum_values)):
            if self._enum_values[i] == value:
                return i

        return 0


class SettableEnumParameter(EnumParameter, SettableNumericParameter):
    """
    A parameter representing a Z2M *enum* parameter with a *flags* property that is
    *settable*.
    """

    pass


T = TypeVar("T", bound=Enum)


def _int_to_enum(enum_type: Type[T], index: int) -> T:
    return list(enum_type)[index]


class CompositeParameter(ParameterBase):
    """
    Base class for Z2M parameters with a *type* property of *composite*.

    Such parameters are made up of multiple simple parameters. These will be added by
    the pyziggy autogenerator as public members to a derived CompositeParameter class.

    Example::

        composite_param = devices.color_bulb.color_hs
        composite_param.hue.set(120)
        composite_param.saturation.set(50)
    """

    def __init__(self, property: str):
        super().__init__(property)
        self._parameters: Dict[str, ParameterBase] = {}

        self._hook_into_subparameters()

    def _hook_into_subparameters(self):
        for param in self._get_subparameters():
            self._parameters[param.get_property_name()] = param

            param._wants_to_call_listeners_broadcaster.add_listener(
                lambda: self._wants_to_call_listeners_broadcaster._call_listeners()
            )
            param._wants_to_query_device_boradcaster.add_listener(
                lambda: self._wants_to_query_device_boradcaster._call_listeners()
            )
            param._wants_to_call_listeners_synchronously_broadcaster.add_listener(
                lambda _: self._wants_to_call_listeners_synchronously_broadcaster._call_listeners(
                    lambda callback: callback(self)
                )
            )

    def _get_subparameters(self):
        return [
            param for _, param in vars(self).items() if isinstance(param, ParameterBase)
        ]

    @final
    def mark_as_stale(self):
        """
        Use this function to mark the parameter as stale, if for whatever reason,
        we can't assume that the parameter's value correctly reflects the physical
        device's state.

        This will override the default logic where the
        :meth:`SettableNumericParameter.set` and
        :meth:`SettableNumericParameter.set_normalized` functions only emit MQTT
        messages if the parameter's stored state is different from the new one.

        This way you can practically force emitting an MQTT message that requires the
        device parameter to be set to the required value. The first
        ::meth:`SettableNumericParameter.set` or
        :meth:`SettableNumericParameter.set_normalized` call clears the stale state,
        returning the parameter logic to follow the default behavior.
        """
        for param in self._get_subparameters():
            if isinstance(param, SettableNumericParameter):
                param.mark_as_stale()

    @final
    @override
    def _call_listeners_if_necessary(self):
        for param in self._get_subparameters():
            param._call_listeners_if_necessary()

    @final
    @override
    def _append_dictionary_sent_to_device(self, out_dict) -> None:
        sub_dict: Dict[str, Any] = {}

        for param in self._get_subparameters():
            param._append_dictionary_sent_to_device(sub_dict)

        if sub_dict:
            out_dict[self._property] = sub_dict

    @final
    @override
    def _set_reported_value(self, value: Any) -> None:
        if not isinstance(value, Dict):
            logger.warning(
                f"{self.get_property_name()} received {value}. I didn't think this was possible."
            )
            return

        for k, v in value.items():
            if k in self._parameters:
                self._parameters[k]._set_reported_value(v)

    @final
    @override
    def _should_device_be_queryied(self) -> bool:
        should_device_be_queryied = self._should_query_device
        self._should_query_device = False

        for param in self._get_subparameters():
            should_device_be_queryied = (
                should_device_be_queryied or param._should_device_be_queryied()
            )

        return should_device_be_queryied
