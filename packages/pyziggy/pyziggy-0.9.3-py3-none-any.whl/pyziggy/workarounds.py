# pyziggy - Run automation scripts that interact with zigbee2mqtt.
# Copyright (C) 2025 Attila Szarvas
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <https://www.gnu.org/licenses/>.

"""
Contains somewhat generally applicable modifications to the autogenerated parameter
data and behavior.

The workaround functions are applied to the AvailableDevices before connecting to the
MQTT broker.

These are modifications that I've found necessary to have unsurprising behavior when
implementing common automations such as various smart switches controlling lights. The
modifications are enabled by default, but it's easy to turn them off. I'm
not sure how generally applicable they are, and I suspect changes to Zigbee2MQTT
behavior might affect the necessity of these changes, hence the name, workarounds.

For example one of the changes set the minimum and maximum values for hue and saturation
sub-parameters in LightWithColor devices. These should ideally be reported by
Zigbee2MQTT, but in my testing, they seem to be missing for all sub-parameters of
composite parameters. After some experimentation, one can discover that the effective
limits are [0, 360] for hue, and [0, 100] for saturation. I wouldn't be surprised if
Zigbee2MQTT eventually started reporting these limits, at which point they would
automatically show up in the autogenerated LightWithColor devices.

You can disable these workarounds by accessing the
:data:`pyziggy.workarounds.applied_workarounds` singleton object in your automation
script.

Example::

    import pyziggy.workarounds
    pyziggy.workarounds.fix_light_with_color_min_max_values.set_enabled(False)
"""
from typing import Callable

from .device_bases import LightWithColor, LightWithColorTemp
from .devices_client import DevicesClient
from .parameters import EnumParameter
from .parser import NumericParameterDefinition


class Workaround:
    """
    Class that wraps a function that's called prior to starting MQTT communication. This
    way the function has a chance to apply modifications to the DevicesClient.
    """

    def __init__(self, callable: Callable[[DevicesClient], None], description: str):
        self._enabled = True
        self._callable = callable
        self._description = description

    def set_enabled(self, enabled: bool) -> None:
        """
        Sets whether a workaround gets applied to your DevicesClient object.

        The default setting is True.
        """
        self._enabled = enabled


def _fix_light_with_color_min_max_values(dc: DevicesClient):
    for device in dc.get_devices():
        if isinstance(device, LightWithColor):
            if (
                device.color_hs.hue._min_value
                == NumericParameterDefinition.MISSING_VALUE_MIN
            ):
                device.color_hs.hue._min_value = 0
            if (
                device.color_hs.hue._max_value
                == NumericParameterDefinition.MISSING_VALUE_MAX
            ):
                device.color_hs.hue._max_value = 360
            if (
                device.color_hs.saturation._min_value
                == NumericParameterDefinition.MISSING_VALUE_MIN
            ):
                device.color_hs.saturation._min_value = 0
            if (
                device.color_hs.saturation._max_value
                == NumericParameterDefinition.MISSING_VALUE_MAX
            ):
                device.color_hs.saturation._max_value = 100


def _make_action_enum_parameters_use_sync_callbacks(dc: DevicesClient):
    for device in dc.get_devices():
        for parameter in device.get_parameters():
            if (
                isinstance(parameter, EnumParameter)
                and parameter.get_property_name() == "action"
            ):
                parameter.set_call_listeners_synchronously(True)


def _make_action_enum_parameters_always_call_listeners(dc: DevicesClient):
    for device in dc.get_devices():
        for parameter in device.get_parameters():
            if (
                isinstance(parameter, EnumParameter)
                and parameter.get_property_name() == "action"
            ):
                parameter.set_always_call_listeners_on_report(True)


def _make_setting_color_invalidate_color(dc: DevicesClient):
    def hs_was_set(device: LightWithColor):
        device.color_temp.mark_as_stale()
        device.color_xy.mark_as_stale()

    def xy_was_set(device: LightWithColor):
        device.color_hs.mark_as_stale()
        device.color_temp.mark_as_stale()

    def color_temp_was_set(device: LightWithColor):
        device.color_hs.mark_as_stale()
        device.color_xy.mark_as_stale()

    for device in dc.get_devices():
        if isinstance(device, LightWithColor):
            device.color_hs.hue.add_listener(lambda d=device: hs_was_set(d), -1)  # type: ignore
            device.color_hs.saturation.add_listener(lambda d=device: hs_was_set(d), -1)  # type: ignore
            device.color_xy.x.add_listener(lambda d=device: xy_was_set(d), -1)  # type: ignore
            device.color_xy.y.add_listener(lambda d=device: xy_was_set(d), -1)  # type: ignore
            device.color_temp.add_listener(lambda d=device: color_temp_was_set(d), -1)  # type: ignore


def _make_setting_state_invalidate_color_temp(dc: DevicesClient):
    """
    If we send color parameter changes to a device that is turned off, it will
    likely ignore it. Z2M however will send the info to the device, and
    even in its internal state, Z2M will believe that the light has this new
    color value.

    So it can happen that the device is turned on, has the wrong color, but both
    Z2M and pyziggy thinks it has the right color, hence it won't even send a
    new parameter change with the same value.

    Marking the parameters stale ensures, that whatever color we set after the
    device turns on, will be sent to it.
    """
    for device in dc.get_devices():
        if isinstance(device, LightWithColorTemp):
            device.state.add_listener(lambda d=device: d.color_temp.mark_as_stale(), -1)  # type: ignore


class Workarounds:
    """
    Class aggregating all :class:`pyziggy.workarounds.Workaround` objects. You can
    access the public members to change their enabled state.
    """

    def __init__(self):
        #: Modifies LightWithColor devices. Changes hue limits to [0, 360] and saturation
        #: limits to [0, 100].
        self.fix_light_with_color_min_max_values = Workaround(
            _fix_light_with_color_min_max_values,
            "Modifying LightWithColor devices. Changing hue limits to [0, 360] and saturation limits to [0, 100].",
        )
        #: Modifies LightWithColor device behavior: setting hs, xy or color_temp will
        #: mark the other two parameters as stale.
        self.make_setting_color_invalidate_color = Workaround(
            _make_setting_color_invalidate_color,
            "Modifying LightWithColor devices. Setting hs, xy or color_temp will invalidate the other two.",
        )
        #: Modifies LightWithColorTemp device behaviour: marks all color related params
        #: as stale when the device is turned on.
        #:
        #: If we send color parameter changes to a device that is turned off, it will
        #: likely ignore it. Z2M however will send the info to the device, and
        #: even in its internal state, Z2M will believe that the light has this new
        #: color value.
        #:
        #: So it can happen that the device is turned on, has the wrong color, but both
        #: Z2M and pyziggy thinks it has the right color, hence it won't even send a
        #: new parameter change with the same value.
        #:
        #: Marking the parameters stale ensures, that whatever color we set after the
        #: device turns on, will be sent to it.
        self.make_setting_state_invalidate_color_temp = Workaround(
            _make_setting_state_invalidate_color_temp,
            "Modifying LightWithColorTemp devices. Marking all color related params stale when the device is turned on.",
        )
        #: Modifies EnumParameters with the "action" property to use synchronous
        #: callbacks.
        self.make_action_enum_parameters_use_sync_callbacks = Workaround(
            _make_action_enum_parameters_use_sync_callbacks,
            'Modifying EnumParameters with the "action" property to use synchronous callbacks.',
        )
        #: Modifies EnumParameters with the "action" property to call listeners on MQTT
        #: messages even if the action is unchanged.
        self.make_action_enum_parameters_always_call_listeners = Workaround(
            _make_action_enum_parameters_always_call_listeners,
            'Modifying EnumParameters with the "action" property to call listeners on MQTT messages even if the action is unchanged',
        )

    def _get_workarounds(self) -> list[Workaround]:
        workarounds: list[Workaround] = []

        for k, v in vars(self).items():
            if isinstance(v, Workaround):
                workarounds.append(v)

        return workarounds

    def _apply(self, dc: DevicesClient):
        if not any([wa._enabled for wa in self._get_workarounds()]):
            return

        print(
            "Applying workarounds. See the documentation in the pyziggy.workarounds module if you want to disable them."
        )

        for wa in self._get_workarounds():
            if not wa._enabled:
                continue

            print(f"* {wa._description}")
            wa._callable(dc)


#: This is the object that contains the active workarounds that will be applied to the
#: :class:`pyziggy.devices_client.DevicesClient` object before starting the MQTT
#: operations.
#:
#: The public members of this object are the "workarounds" that modify the default
#: behaviour for certain parameters. You can import this object in your automation code,
#: and call :meth:`pyziggy.workarounds.Workaround.set_enabled` with a False parameter
#: for a workaround that doesn't play well with your own Zigbee devices.
applied_workarounds = Workarounds()
