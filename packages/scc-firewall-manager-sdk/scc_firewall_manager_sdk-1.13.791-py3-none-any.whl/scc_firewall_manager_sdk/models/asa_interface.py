# coding: utf-8

"""
    Cisco Security Cloud Control Firewall Manager API

    Use the documentation to explore the endpoints Security Cloud Control Firewall Manager has to offer

    The version of the OpenAPI document: 1.13.0
    Contact: cdo.tac@cisco.com
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from scc_firewall_manager_sdk.models.duplex_type import DuplexType
from scc_firewall_manager_sdk.models.interface_ipv4_address import InterfaceIpv4Address
from scc_firewall_manager_sdk.models.interface_ipv6_address import InterfaceIpv6Address
from scc_firewall_manager_sdk.models.interface_mode import InterfaceMode
from scc_firewall_manager_sdk.models.interface_runtime_data import InterfaceRuntimeData
from scc_firewall_manager_sdk.models.interface_type import InterfaceType
from scc_firewall_manager_sdk.models.speed_type import SpeedType
from scc_firewall_manager_sdk.models.switch_port_config import SwitchPortConfig
from scc_firewall_manager_sdk.models.vlan_id_range import VlanIdRange
from typing import Optional, Set
from typing_extensions import Self

class AsaInterface(BaseModel):
    """
    AsaInterface
    """ # noqa: E501
    description: Optional[StrictStr] = Field(default=None, description="The description of the interface.")
    device_uid: Optional[StrictStr] = Field(default=None, description="The unique identifier, represented as a UUID, of the device associated with the interface.", alias="deviceUid")
    duplex_type: Optional[DuplexType] = Field(default=None, alias="duplexType")
    enabled: Optional[StrictBool] = Field(default=None, description="Indicates whether the interface is enabled.")
    ether_channel_group_uid: Optional[StrictStr] = Field(default=None, description="The unique identifier, represented as a UUID, of the EtherChannel group this interface belong to.", alias="etherChannelGroupUid")
    ether_channel_id: Optional[StrictInt] = Field(default=None, description="The identifier of the EtherChannel interface in the scope of the device.", alias="etherChannelId")
    hardware_name: Optional[StrictStr] = Field(default=None, description="The interface hardware name. It is usually structured from the type, speed, slot and port number.", alias="hardwareName")
    interface_type: Optional[InterfaceType] = Field(default=None, alias="interfaceType")
    ipv4: Optional[InterfaceIpv4Address] = None
    ipv6: Optional[InterfaceIpv6Address] = None
    lacp_mode: Optional[StrictStr] = Field(default=None, description="The Link Aggregation Control Protocol (LACP) mode of the EtherChannel interface.", alias="lacpMode")
    mac_address: Optional[StrictStr] = Field(default=None, description="The interface Media Access Control (MAC) address, a unique hardware identifier assigned to each physical interface. it is used for Layer 2 communication within a network segment.", alias="macAddress")
    management_interface: Optional[StrictBool] = Field(default=None, description="Indicates whether the interface is used for device management purposes.", alias="managementInterface")
    management_only: Optional[StrictBool] = Field(default=None, description="Indicates whether the interface is exclusively used for management traffic and does not carry regular user or data traffic", alias="managementOnly")
    member_interfaces: Optional[List[StrictStr]] = Field(default=None, description="The set of unique identifiers, represented as UUIDs, of the member interfaces that are part of the EtherChannel group.", alias="memberInterfaces")
    mode: Optional[InterfaceMode] = None
    monitor_interface: Optional[StrictBool] = Field(default=None, description="Indicates if the interface is actively monitored for checking its operational status and health as part of an HA setup. It helps determine if the interface is functioning correctly and whether a failover to a standby device should be triggered in case of failure.", alias="monitorInterface")
    mtu: Optional[StrictInt] = Field(default=None, description="The interface MTU (Maximum Transmission Unit), the largest size, in bytes, of a packet or frame that can be sent over a network interface without needing to be fragmented. It defines the maximum payload size that the interface can handle in a single transmission. Range is 64 - 9198.")
    name: Optional[StrictStr] = Field(default=None, description="The logical name of the interface. Interface names are unique in the scope of the device.")
    parent_interface_uid: Optional[StrictStr] = Field(default=None, description="The unique identifier, represented as a UUID, of the parent interface for sub-interfaces.", alias="parentInterfaceUid")
    runtime_data: Optional[InterfaceRuntimeData] = Field(default=None, alias="runtimeData")
    security_level: Optional[StrictInt] = Field(default=None, description="Indicates the interface trust level, ranging from 0 (lowest) to 100 (highest).", alias="securityLevel")
    speed_type: Optional[SpeedType] = Field(default=None, alias="speedType")
    standby_mac_address: Optional[StrictStr] = Field(default=None, description="The standby interface Media Access Control (MAC) address, for use in a high-availability (HA) pair.", alias="standbyMacAddress")
    sub_interface_id: Optional[StrictInt] = Field(default=None, description="The unique identifier of the sub-interface in the scope of the parent interface. It is used to differentiate between multiple sub-interfaces on the same parent interface. Range is 1 - 4294967295.", alias="subInterfaceId")
    switch_port_config: Optional[SwitchPortConfig] = Field(default=None, alias="switchPortConfig")
    uid: Optional[StrictStr] = Field(default=None, description="The unique identifier, represented as a UUID, of the interface in Security Cloud Control.")
    vlan_id: Optional[StrictInt] = Field(default=None, description="The unique identifier of the VLAN associated with the VLAN interface. Range is 1 - 4070.", alias="vlanId")
    vlan_primary_id: Optional[StrictInt] = Field(default=None, description="The primary unique identifier of the VLAN associated with the sub-interface. Range is 1 - 4094.", alias="vlanPrimaryId")
    vlan_secondary_ids: Optional[List[VlanIdRange]] = Field(default=None, description="The secondary identifiers of the VLAN associated with the sub-interface. Each range is defined by a start and end value, allowing for multiple VLANs to be associated with the sub-interface. Ranges are inclusive.", alias="vlanSecondaryIds")
    __properties: ClassVar[List[str]] = ["description", "deviceUid", "duplexType", "enabled", "etherChannelGroupUid", "etherChannelId", "hardwareName", "interfaceType", "ipv4", "ipv6", "lacpMode", "macAddress", "managementInterface", "managementOnly", "memberInterfaces", "mode", "monitorInterface", "mtu", "name", "parentInterfaceUid", "runtimeData", "securityLevel", "speedType", "standbyMacAddress", "subInterfaceId", "switchPortConfig", "uid", "vlanId", "vlanPrimaryId", "vlanSecondaryIds"]

    @field_validator('lacp_mode')
    def lacp_mode_validate_enum(cls, value):
        """Validates the enum"""
        if value is None:
            return value

        if value not in set(['ACTIVE', 'PASSIVE', 'ON']):
            raise ValueError("must be one of enum values ('ACTIVE', 'PASSIVE', 'ON')")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of AsaInterface from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        # override the default output from pydantic by calling `to_dict()` of ipv4
        if self.ipv4:
            _dict['ipv4'] = self.ipv4.to_dict()
        # override the default output from pydantic by calling `to_dict()` of ipv6
        if self.ipv6:
            _dict['ipv6'] = self.ipv6.to_dict()
        # override the default output from pydantic by calling `to_dict()` of runtime_data
        if self.runtime_data:
            _dict['runtimeData'] = self.runtime_data.to_dict()
        # override the default output from pydantic by calling `to_dict()` of switch_port_config
        if self.switch_port_config:
            _dict['switchPortConfig'] = self.switch_port_config.to_dict()
        # override the default output from pydantic by calling `to_dict()` of each item in vlan_secondary_ids (list)
        _items = []
        if self.vlan_secondary_ids:
            for _item in self.vlan_secondary_ids:
                if _item:
                    _items.append(_item.to_dict())
            _dict['vlanSecondaryIds'] = _items
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of AsaInterface from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "description": obj.get("description"),
            "deviceUid": obj.get("deviceUid"),
            "duplexType": obj.get("duplexType"),
            "enabled": obj.get("enabled"),
            "etherChannelGroupUid": obj.get("etherChannelGroupUid"),
            "etherChannelId": obj.get("etherChannelId"),
            "hardwareName": obj.get("hardwareName"),
            "interfaceType": obj.get("interfaceType"),
            "ipv4": InterfaceIpv4Address.from_dict(obj["ipv4"]) if obj.get("ipv4") is not None else None,
            "ipv6": InterfaceIpv6Address.from_dict(obj["ipv6"]) if obj.get("ipv6") is not None else None,
            "lacpMode": obj.get("lacpMode"),
            "macAddress": obj.get("macAddress"),
            "managementInterface": obj.get("managementInterface"),
            "managementOnly": obj.get("managementOnly"),
            "memberInterfaces": obj.get("memberInterfaces"),
            "mode": obj.get("mode"),
            "monitorInterface": obj.get("monitorInterface"),
            "mtu": obj.get("mtu"),
            "name": obj.get("name"),
            "parentInterfaceUid": obj.get("parentInterfaceUid"),
            "runtimeData": InterfaceRuntimeData.from_dict(obj["runtimeData"]) if obj.get("runtimeData") is not None else None,
            "securityLevel": obj.get("securityLevel"),
            "speedType": obj.get("speedType"),
            "standbyMacAddress": obj.get("standbyMacAddress"),
            "subInterfaceId": obj.get("subInterfaceId"),
            "switchPortConfig": SwitchPortConfig.from_dict(obj["switchPortConfig"]) if obj.get("switchPortConfig") is not None else None,
            "uid": obj.get("uid"),
            "vlanId": obj.get("vlanId"),
            "vlanPrimaryId": obj.get("vlanPrimaryId"),
            "vlanSecondaryIds": [VlanIdRange.from_dict(_item) for _item in obj["vlanSecondaryIds"]] if obj.get("vlanSecondaryIds") is not None else None
        })
        return _obj


