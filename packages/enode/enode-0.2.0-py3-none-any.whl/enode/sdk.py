"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from .basesdk import BaseSDK
from .httpclient import AsyncHttpClient, ClientOwner, HttpClient, close_clients
from .sdkconfiguration import SDKConfiguration
from .utils.logger import Logger, get_default_logger
from .utils.retries import RetryConfig
from enode import models, utils
from enode._hooks import SDKHooks
from enode.types import OptionalNullable, UNSET
import httpx
import importlib
import sys
from typing import Callable, Dict, Optional, TYPE_CHECKING, Union, cast
import weakref

if TYPE_CHECKING:
    from enode.batteries import Batteries
    from enode.chargers import Chargers
    from enode.experimental import Experimental
    from enode.hem_systems import HemSystems
    from enode.hems import Hems
    from enode.hvac import Hvac
    from enode.hvacs import Hvacs
    from enode.interventions import Interventions
    from enode.locations import Locations
    from enode.meters import Meters
    from enode.schedules import Schedules
    from enode.servicehealth import ServiceHealth
    from enode.solar_inverters import SolarInverters
    from enode.statistics import Statistics
    from enode.tariffs import Tariffs
    from enode.user_management import UserManagement
    from enode.vehicles import Vehicles
    from enode.webhooks import Webhooks


class Enode(BaseSDK):
    r"""Enode API: The Enode API is designed to make smart charging applications easy to develop. We provide an abstraction layer that reduces the complexity when extracting vehicle data and sending commands to vehicles from a variety of manufacturers.
    The API has a RESTful architecture and utilizes OAuth2 authorization.
    """

    batteries: "Batteries"
    r"""The `Battery` object represents a residential energy storage unit, like a Tesla Powerwall or Enphase IQ. It offers detailed insights into the battery's operation and allows you to instruct the battery on handling its stored energy."""
    chargers: "Chargers"
    r"""EV Chargers provide charging data and can be controlled via [Control Charging](/api/reference#controlChargerCharging) and [Schedules](/docs/scheduling)"""
    hvac: "Hvac"
    r"""HVAC units (heaters, heat pumps, air conditioning, thermostats, etc.) are controlled by altering the mode & target setpoints. This can be done directly using the [Set Permanent Hold](/api/reference#postSetHvacPermanentHold) endpoint, [Return to Schedule](/api/reference#postSetHvacFollowSchedule), or via [Schedules](/docs/scheduling)."""
    hvacs: "Hvacs"
    interventions: "Interventions"
    r"""Endpoints that return information about interventions. More information and examples are available in the [Interventions](/docs/interventions) guide."""
    solar_inverters: "SolarInverters"
    locations: "Locations"
    r"""Locations are used to assign devices to a geographical group. This is useful when running schedules, smart charging, or smart heating, as target behavior usually depends on a common locality of demand (charging, heating, cooling, etc.) and supply (tariff, battery, inverter, etc.) of energy."""
    meters: "Meters"
    r"""The `Meter` object represents a unit responsible for measuring energy usage. It provides detailed information about the meter itself and the energy consumption data it records."""
    schedules: "Schedules"
    r"""Endpoints to manage schedules for Vehicles, Chargers and HVACs.

    More information and examples are available in the [Scheduling](/docs/scheduling) guide.
    """
    statistics: "Statistics"
    r"""Endpoints returning timeseries data collected from linked devices."""
    tariffs: "Tariffs"
    r"""Use the Tariffs API to submit pricing information to Enode. These prices will be preferred over market prices in Enode's smart products, like [Smart Charging](https://developers.enode.com/api/reference#updateVehicleSmartChargingPolicy), and will be used to calculate costs in [Statistics](https://developers.enode.com/api/reference#getChargingStatistics)."""
    user_management: "UserManagement"
    vehicles: "Vehicles"
    r"""EVs provide charge, location, and odometer data. Vehicles can be controlled either directly using the [Control Charging](/api/reference#postVehiclesVehicleidCharging) endpoint, or through [Smart Charging](/docs/smart-charging/introduction) and [Schedules](/docs/scheduling)."""
    experimental: "Experimental"
    r"""Endpoint is not stable and may change without notice. Do not use in production applications."""
    webhooks: "Webhooks"
    r"""Webhooks are a mechanism that allows your server to receive notifications of events from the Enode system.

    See the related guide for more information about timeouts, failures, and retry logic: [Using Webhooks](/docs/webhooks)
    """
    service_health: "ServiceHealth"
    hems: "Hems"
    hem_systems: "HemSystems"
    _sub_sdk_map = {
        "batteries": ("enode.batteries", "Batteries"),
        "chargers": ("enode.chargers", "Chargers"),
        "hvac": ("enode.hvac", "Hvac"),
        "hvacs": ("enode.hvacs", "Hvacs"),
        "interventions": ("enode.interventions", "Interventions"),
        "solar_inverters": ("enode.solar_inverters", "SolarInverters"),
        "locations": ("enode.locations", "Locations"),
        "meters": ("enode.meters", "Meters"),
        "schedules": ("enode.schedules", "Schedules"),
        "statistics": ("enode.statistics", "Statistics"),
        "tariffs": ("enode.tariffs", "Tariffs"),
        "user_management": ("enode.user_management", "UserManagement"),
        "vehicles": ("enode.vehicles", "Vehicles"),
        "experimental": ("enode.experimental", "Experimental"),
        "webhooks": ("enode.webhooks", "Webhooks"),
        "service_health": ("enode.servicehealth", "ServiceHealth"),
        "hems": ("enode.hems", "Hems"),
        "hem_systems": ("enode.hem_systems", "HemSystems"),
    }

    def __init__(
        self,
        security: Optional[
            Union[models.Security, Callable[[], models.Security]]
        ] = None,
        server_idx: Optional[int] = None,
        server_url: Optional[str] = None,
        url_params: Optional[Dict[str, str]] = None,
        client: Optional[HttpClient] = None,
        async_client: Optional[AsyncHttpClient] = None,
        retry_config: OptionalNullable[RetryConfig] = UNSET,
        timeout_ms: Optional[int] = None,
        debug_logger: Optional[Logger] = None,
    ) -> None:
        r"""Instantiates the SDK configuring it with the provided parameters.

        :param security: The security details required for authentication
        :param server_idx: The index of the server to use for all methods
        :param server_url: The server URL to use for all methods
        :param url_params: Parameters to optionally template the server URL with
        :param client: The HTTP client to use for all synchronous methods
        :param async_client: The Async HTTP client to use for all asynchronous methods
        :param retry_config: The retry configuration to use for all supported methods
        :param timeout_ms: Optional request timeout applied to each operation in milliseconds
        """
        client_supplied = True
        if client is None:
            client = httpx.Client()
            client_supplied = False

        assert issubclass(
            type(client), HttpClient
        ), "The provided client must implement the HttpClient protocol."

        async_client_supplied = True
        if async_client is None:
            async_client = httpx.AsyncClient()
            async_client_supplied = False

        if debug_logger is None:
            debug_logger = get_default_logger()

        assert issubclass(
            type(async_client), AsyncHttpClient
        ), "The provided async_client must implement the AsyncHttpClient protocol."

        if server_url is not None:
            if url_params is not None:
                server_url = utils.template_url(server_url, url_params)

        BaseSDK.__init__(
            self,
            SDKConfiguration(
                client=client,
                client_supplied=client_supplied,
                async_client=async_client,
                async_client_supplied=async_client_supplied,
                security=security,
                server_url=server_url,
                server_idx=server_idx,
                retry_config=retry_config,
                timeout_ms=timeout_ms,
                debug_logger=debug_logger,
            ),
            parent_ref=self,
        )

        hooks = SDKHooks()

        # pylint: disable=protected-access
        self.sdk_configuration.__dict__["_hooks"] = hooks

        self.sdk_configuration = hooks.sdk_init(self.sdk_configuration)

        weakref.finalize(
            self,
            close_clients,
            cast(ClientOwner, self.sdk_configuration),
            self.sdk_configuration.client,
            self.sdk_configuration.client_supplied,
            self.sdk_configuration.async_client,
            self.sdk_configuration.async_client_supplied,
        )

    def dynamic_import(self, modname, retries=3):
        for attempt in range(retries):
            try:
                return importlib.import_module(modname)
            except KeyError:
                # Clear any half-initialized module and retry
                sys.modules.pop(modname, None)
                if attempt == retries - 1:
                    break
        raise KeyError(f"Failed to import module '{modname}' after {retries} attempts")

    def __getattr__(self, name: str):
        if name in self._sub_sdk_map:
            module_path, class_name = self._sub_sdk_map[name]
            try:
                module = self.dynamic_import(module_path)
                klass = getattr(module, class_name)
                instance = klass(self.sdk_configuration, parent_ref=self)
                setattr(self, name, instance)
                return instance
            except ImportError as e:
                raise AttributeError(
                    f"Failed to import module {module_path} for attribute {name}: {e}"
                ) from e
            except AttributeError as e:
                raise AttributeError(
                    f"Failed to find class {class_name} in module {module_path} for attribute {name}: {e}"
                ) from e

        raise AttributeError(
            f"'{type(self).__name__}' object has no attribute '{name}'"
        )

    def __dir__(self):
        default_attrs = list(super().__dir__())
        lazy_attrs = list(self._sub_sdk_map.keys())
        return sorted(list(set(default_attrs + lazy_attrs)))

    def __enter__(self):
        return self

    async def __aenter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if (
            self.sdk_configuration.client is not None
            and not self.sdk_configuration.client_supplied
        ):
            self.sdk_configuration.client.close()
        self.sdk_configuration.client = None

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        if (
            self.sdk_configuration.async_client is not None
            and not self.sdk_configuration.async_client_supplied
        ):
            await self.sdk_configuration.async_client.aclose()
        self.sdk_configuration.async_client = None
