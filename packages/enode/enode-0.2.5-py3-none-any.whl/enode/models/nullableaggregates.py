"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from enode.types import BaseModel, Nullable, UNSET_SENTINEL
from pydantic import model_serializer
from typing_extensions import TypedDict


class NullableAggregatesTypedDict(TypedDict):
    r"""If Smart Charging has actively stopped the charging session from happening at another time; these fields show the aggregate per kWh price statistics that would have occurred without Smart Charging. This can be used to show the potential price if Smart Charging had not been active. Currency is `NOK` for Norway, Sweden, Denmark, Finland, Estonia, Latvia, Lithuania; and `EUR` for Austria, Belgium, Germany, France, Netherlands, Poland, Spain. Unless different price data has been provided via the Tariffs endpoints"""

    min: Nullable[float]
    r"""The minimum amount for this period."""
    max: Nullable[float]
    r"""The maximum amount for this period."""
    mean: Nullable[float]
    r"""The average for this period."""


class NullableAggregates(BaseModel):
    r"""If Smart Charging has actively stopped the charging session from happening at another time; these fields show the aggregate per kWh price statistics that would have occurred without Smart Charging. This can be used to show the potential price if Smart Charging had not been active. Currency is `NOK` for Norway, Sweden, Denmark, Finland, Estonia, Latvia, Lithuania; and `EUR` for Austria, Belgium, Germany, France, Netherlands, Poland, Spain. Unless different price data has been provided via the Tariffs endpoints"""

    min: Nullable[float]
    r"""The minimum amount for this period."""

    max: Nullable[float]
    r"""The maximum amount for this period."""

    mean: Nullable[float]
    r"""The average for this period."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["min", "max", "mean"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
