"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from datetime import datetime
from enode.types import BaseModel, Nullable, UNSET_SENTINEL
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class ChargeScheduleResponseTargetType(str, Enum):
    VEHICLE = "vehicle"
    CHARGER = "charger"


class ChargeScheduleResponseHourMinuteTypedDict(TypedDict):
    r"""An interval composed of two clock times during which this rule applies each day. `to` always resolves to a timestamp after `from`, and thus may span across midnight and fall on the next day."""

    from_: str
    r"""Clock time from which this rule should apply each day."""
    to: str
    r"""Clock time until which this rule should apply each day."""


class ChargeScheduleResponseHourMinute(BaseModel):
    r"""An interval composed of two clock times during which this rule applies each day. `to` always resolves to a timestamp after `from`, and thus may span across midnight and fall on the next day."""

    from_: Annotated[str, pydantic.Field(alias="from")]
    r"""Clock time from which this rule should apply each day."""

    to: str
    r"""Clock time until which this rule should apply each day."""


class ChargeScheduleResponseWeekday(int, Enum):
    ZERO = 0
    ONE = 1
    TWO = 2
    THREE = 3
    FOUR = 4
    FIVE = 5
    SIX = 6


class ChargeScheduleResponseRuleTypedDict(TypedDict):
    should_charge: bool
    r"""Whether a chargeable asset should want to charge while this rule is active."""
    hour_minute: NotRequired[ChargeScheduleResponseHourMinuteTypedDict]
    r"""An interval composed of two clock times during which this rule applies each day. `to` always resolves to a timestamp after `from`, and thus may span across midnight and fall on the next day."""
    from_timestamp: NotRequired[datetime]
    r"""UTC timestamp from which this rule should apply."""
    to_timestamp: NotRequired[datetime]
    r"""UTC timestamp until which this rule should apply."""
    weekdays: NotRequired[List[ChargeScheduleResponseWeekday]]
    r"""An array of weekdays to which this rule should apply. A weekday starts with 0 for Monday and ends with 6 for Sunday."""


class ChargeScheduleResponseRule(BaseModel):
    should_charge: Annotated[bool, pydantic.Field(alias="shouldCharge")]
    r"""Whether a chargeable asset should want to charge while this rule is active."""

    hour_minute: Annotated[
        Optional[ChargeScheduleResponseHourMinute], pydantic.Field(alias="hourMinute")
    ] = None
    r"""An interval composed of two clock times during which this rule applies each day. `to` always resolves to a timestamp after `from`, and thus may span across midnight and fall on the next day."""

    from_timestamp: Annotated[
        Optional[datetime], pydantic.Field(alias="fromTimestamp")
    ] = None
    r"""UTC timestamp from which this rule should apply."""

    to_timestamp: Annotated[Optional[datetime], pydantic.Field(alias="toTimestamp")] = (
        None
    )
    r"""UTC timestamp until which this rule should apply."""

    weekdays: Optional[List[ChargeScheduleResponseWeekday]] = None
    r"""An array of weekdays to which this rule should apply. A weekday starts with 0 for Monday and ends with 6 for Sunday."""


class ChargeScheduleResponseTypedDict(TypedDict):
    target_id: str
    r"""ID of the asset (Vehicle/Charger) to which this schedule applies"""
    location_id: Nullable[str]
    r"""ID of the Location to which this schedule applies. The behavior of a null value differs based on the `targetType`. For chargers, a null value is essentially ignored and the schedule is applied even if the charger isn't at a location. This is designed to prevent schedules from controlling vehicles at public chargers where the user doesn't pay for electricity."""
    target_type: ChargeScheduleResponseTargetType
    default_should_charge: bool
    r"""When no rule is active, the default charge state for the target."""
    rules: List[ChargeScheduleResponseRuleTypedDict]
    r"""Each rule sets a value for `shouldCharge`, either `true` or `false`. All other properties of the rule are optional filters that limit the times to which this rule applies."""
    id: str
    is_enabled: NotRequired[bool]
    r"""Whether this Schedule should be attempting to control the target's charge state."""


class ChargeScheduleResponse(BaseModel):
    target_id: Annotated[str, pydantic.Field(alias="targetId")]
    r"""ID of the asset (Vehicle/Charger) to which this schedule applies"""

    location_id: Annotated[Nullable[str], pydantic.Field(alias="locationId")]
    r"""ID of the Location to which this schedule applies. The behavior of a null value differs based on the `targetType`. For chargers, a null value is essentially ignored and the schedule is applied even if the charger isn't at a location. This is designed to prevent schedules from controlling vehicles at public chargers where the user doesn't pay for electricity."""

    target_type: Annotated[
        ChargeScheduleResponseTargetType, pydantic.Field(alias="targetType")
    ]

    default_should_charge: Annotated[bool, pydantic.Field(alias="defaultShouldCharge")]
    r"""When no rule is active, the default charge state for the target."""

    rules: List[ChargeScheduleResponseRule]
    r"""Each rule sets a value for `shouldCharge`, either `true` or `false`. All other properties of the rule are optional filters that limit the times to which this rule applies."""

    id: str

    is_enabled: Annotated[Optional[bool], pydantic.Field(alias="isEnabled")] = True
    r"""Whether this Schedule should be attempting to control the target's charge state."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = ["isEnabled"]
        nullable_fields = ["locationId"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
