"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .temperaturetargetstate import (
    TemperatureTargetState,
    TemperatureTargetStateTypedDict,
)
from datetime import datetime
from enode.types import BaseModel
from enum import Enum
import pydantic
from typing import List, Optional
from typing_extensions import Annotated, NotRequired, TypedDict


class PartialTemperatureScheduleTargetType(str, Enum):
    HVAC = "hvac"


class PartialTemperatureScheduleHourMinuteTypedDict(TypedDict):
    r"""An interval composed of two clock times during which this rule applies each day. `to` always resolves to a timestamp after `from`, and thus may span across midnight and fall on the next day."""

    from_: str
    r"""Clock time from which this rule should apply each day."""
    to: str
    r"""Clock time until which this rule should apply each day."""


class PartialTemperatureScheduleHourMinute(BaseModel):
    r"""An interval composed of two clock times during which this rule applies each day. `to` always resolves to a timestamp after `from`, and thus may span across midnight and fall on the next day."""

    from_: Annotated[str, pydantic.Field(alias="from")]
    r"""Clock time from which this rule should apply each day."""

    to: str
    r"""Clock time until which this rule should apply each day."""


class PartialTemperatureScheduleWeekday(int, Enum):
    ZERO = 0
    ONE = 1
    TWO = 2
    THREE = 3
    FOUR = 4
    FIVE = 5
    SIX = 6


class PartialTemperatureScheduleRuleTypedDict(TypedDict):
    target_state: TemperatureTargetStateTypedDict
    hour_minute: NotRequired[PartialTemperatureScheduleHourMinuteTypedDict]
    r"""An interval composed of two clock times during which this rule applies each day. `to` always resolves to a timestamp after `from`, and thus may span across midnight and fall on the next day."""
    from_timestamp: NotRequired[datetime]
    r"""UTC timestamp from which this rule should apply."""
    to_timestamp: NotRequired[datetime]
    r"""UTC timestamp until which this rule should apply."""
    weekdays: NotRequired[List[PartialTemperatureScheduleWeekday]]
    r"""An array of weekdays to which this rule should apply. A weekday starts with 0 for Monday and ends with 6 for Sunday."""


class PartialTemperatureScheduleRule(BaseModel):
    target_state: Annotated[TemperatureTargetState, pydantic.Field(alias="targetState")]

    hour_minute: Annotated[
        Optional[PartialTemperatureScheduleHourMinute],
        pydantic.Field(alias="hourMinute"),
    ] = None
    r"""An interval composed of two clock times during which this rule applies each day. `to` always resolves to a timestamp after `from`, and thus may span across midnight and fall on the next day."""

    from_timestamp: Annotated[
        Optional[datetime], pydantic.Field(alias="fromTimestamp")
    ] = None
    r"""UTC timestamp from which this rule should apply."""

    to_timestamp: Annotated[Optional[datetime], pydantic.Field(alias="toTimestamp")] = (
        None
    )
    r"""UTC timestamp until which this rule should apply."""

    weekdays: Optional[List[PartialTemperatureScheduleWeekday]] = None
    r"""An array of weekdays to which this rule should apply. A weekday starts with 0 for Monday and ends with 6 for Sunday."""


class PartialTemperatureScheduleTypedDict(TypedDict):
    is_enabled: NotRequired[bool]
    r"""Whether this Schedule should be attempting to control the HVAC's temperature settings."""
    target_id: NotRequired[str]
    r"""ID of the HVAC asset to which this schedule applies."""
    target_type: NotRequired[PartialTemperatureScheduleTargetType]
    default_target_state: NotRequired[TemperatureTargetStateTypedDict]
    rules: NotRequired[List[PartialTemperatureScheduleRuleTypedDict]]
    r"""Each rule sets a value for `holdType` and associated settings. All other properties of the rule are optional filters that limit the times to which this rule applies."""


class PartialTemperatureSchedule(BaseModel):
    is_enabled: Annotated[Optional[bool], pydantic.Field(alias="isEnabled")] = True
    r"""Whether this Schedule should be attempting to control the HVAC's temperature settings."""

    target_id: Annotated[Optional[str], pydantic.Field(alias="targetId")] = None
    r"""ID of the HVAC asset to which this schedule applies."""

    target_type: Annotated[
        Optional[PartialTemperatureScheduleTargetType],
        pydantic.Field(alias="targetType"),
    ] = None

    default_target_state: Annotated[
        Optional[TemperatureTargetState], pydantic.Field(alias="defaultTargetState")
    ] = None

    rules: Optional[List[PartialTemperatureScheduleRule]] = None
    r"""Each rule sets a value for `holdType` and associated settings. All other properties of the rule are optional filters that limit the times to which this rule applies."""
