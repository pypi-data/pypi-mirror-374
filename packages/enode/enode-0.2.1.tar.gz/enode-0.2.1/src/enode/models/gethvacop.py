"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .capability import Capability, CapabilityTypedDict
from .hvacmode import HvacMode
from .hvacvendor import HvacVendor
from .nullabletemperaturedifferencerange import (
    NullableTemperatureDifferenceRange,
    NullableTemperatureDifferenceRangeTypedDict,
)
from .nullabletemperaturerange import (
    NullableTemperatureRange,
    NullableTemperatureRangeTypedDict,
)
from datetime import datetime
from enode.types import BaseModel, Nullable, UNSET_SENTINEL
from enode.utils import FieldMetadata, PathParamMetadata
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import List
from typing_extensions import Annotated, TypedDict


class GetHVACRequestTypedDict(TypedDict):
    hvac_id: str


class GetHVACRequest(BaseModel):
    hvac_id: Annotated[
        str,
        pydantic.Field(alias="hvacId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]


class GetHVACCategory(str, Enum):
    r"""Classification of the connected HVAC device.

    * `HEATING`: A direct heating device, such as an electric panel heater

    * `COOLING`: A direct cooling device, such as an air conditioner

    * `HEAT_PUMP`: An air-to-air heat pump capable of both heating and cooling

    * `AGGREGATOR`: A device that is capable of controlling various HVAC systems behind it, such as a smart thermostat
    """

    HEATING = "HEATING"
    COOLING = "COOLING"
    HEAT_PUMP = "HEAT_PUMP"
    AGGREGATOR = "AGGREGATOR"


class GetHVACInformationTypedDict(TypedDict):
    r"""Descriptive information about the HVAC unit"""

    brand: str
    r"""A formatted and properly cased OEM brand name, suitable for reading by humans. May contain special characters."""
    model: Nullable[str]
    r"""Device model name"""
    display_name: str
    r"""Name of the device, as set by the user on the device/vendor. If no user-specified name is available, we construct a fallback name using the vendor/device/model names."""
    group_name: Nullable[str]
    r"""Name of the group the device belongs to, as set by the user on the device/vendor. Groups are typically presented as \"rooms\" or \"zones\"."""
    category: GetHVACCategory
    r"""Classification of the connected HVAC device.

    * `HEATING`: A direct heating device, such as an electric panel heater

    * `COOLING`: A direct cooling device, such as an air conditioner

    * `HEAT_PUMP`: An air-to-air heat pump capable of both heating and cooling

    * `AGGREGATOR`: A device that is capable of controlling various HVAC systems behind it, such as a smart thermostat
    """


class GetHVACInformation(BaseModel):
    r"""Descriptive information about the HVAC unit"""

    brand: str
    r"""A formatted and properly cased OEM brand name, suitable for reading by humans. May contain special characters."""

    model: Nullable[str]
    r"""Device model name"""

    display_name: Annotated[str, pydantic.Field(alias="displayName")]
    r"""Name of the device, as set by the user on the device/vendor. If no user-specified name is available, we construct a fallback name using the vendor/device/model names."""

    group_name: Annotated[Nullable[str], pydantic.Field(alias="groupName")]
    r"""Name of the group the device belongs to, as set by the user on the device/vendor. Groups are typically presented as \"rooms\" or \"zones\"."""

    category: GetHVACCategory
    r"""Classification of the connected HVAC device.

    * `HEATING`: A direct heating device, such as an electric panel heater

    * `COOLING`: A direct cooling device, such as an air conditioner

    * `HEAT_PUMP`: An air-to-air heat pump capable of both heating and cooling

    * `AGGREGATOR`: A device that is capable of controlling various HVAC systems behind it, such as a smart thermostat
    """

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["model", "groupName"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetHVACTemperatureStateTypedDict(TypedDict):
    r"""Latest information about temperature. `null` values indicate we are unable to determine a value for the field based on the information coming from the vendor."""

    current_temperature: Nullable[float]
    r"""Current air temperature reported by device in degrees Celsius."""
    is_active: bool
    r"""Whether the HVAC unit is actively heating or cooling."""
    last_updated: Nullable[datetime]
    r"""Time of last temperature state update. Reflects when the OEM reported a change or Enode recorded a change in any field, whichever is newer"""


class GetHVACTemperatureState(BaseModel):
    r"""Latest information about temperature. `null` values indicate we are unable to determine a value for the field based on the information coming from the vendor."""

    current_temperature: Annotated[
        Nullable[float], pydantic.Field(alias="currentTemperature")
    ]
    r"""Current air temperature reported by device in degrees Celsius."""

    is_active: Annotated[bool, pydantic.Field(alias="isActive")]
    r"""Whether the HVAC unit is actively heating or cooling."""

    last_updated: Annotated[Nullable[datetime], pydantic.Field(alias="lastUpdated")]
    r"""Time of last temperature state update. Reflects when the OEM reported a change or Enode recorded a change in any field, whichever is newer"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["currentTemperature", "lastUpdated"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetHVACHoldType(str, Enum):
    r"""The duration the setpoints and mode are expected to be held. If `SCHEDULED`, the device is being controlled by an OEM schedule configured on the device."""

    PERMANENT = "PERMANENT"
    SCHEDULED = "SCHEDULED"


class GetHVACThermostatStateTypedDict(TypedDict):
    r"""Latest information about the thermostat state. `null` values indicate we are unable to determine a value for the field based on the information coming from the vendor."""

    mode: HvacMode
    r"""The current state of the HVAC unit.

    * `UNKNOWN`: The mode of the HVAC unit is currently not available from the vendor or not supported by enode.
    * `OFF`: The HVAC unit is turned off.
    * `AUTO`: The HVAC unit will try to maintain the given setpoint by alternating between cooling and heating based on the ambient temperature
    * `COOL`: The HVAC unit will only cool to the given setpoint.
    * `HEAT`: The HVAC unit will only heat to the given setpoint
    """
    heat_setpoint: Nullable[float]
    r"""If mode allows, heat when `currentTemperature` falls below this point."""
    cool_setpoint: Nullable[float]
    r"""If mode allows, cool when `currentTemperature` rises above this point."""
    hold_type: Nullable[GetHVACHoldType]
    last_updated: Nullable[datetime]
    r"""Time of last thermostat state update. Reflects when the OEM reported a change or Enode recorded a change in any field, whichever is newer."""


class GetHVACThermostatState(BaseModel):
    r"""Latest information about the thermostat state. `null` values indicate we are unable to determine a value for the field based on the information coming from the vendor."""

    mode: HvacMode
    r"""The current state of the HVAC unit.

    * `UNKNOWN`: The mode of the HVAC unit is currently not available from the vendor or not supported by enode.
    * `OFF`: The HVAC unit is turned off.
    * `AUTO`: The HVAC unit will try to maintain the given setpoint by alternating between cooling and heating based on the ambient temperature
    * `COOL`: The HVAC unit will only cool to the given setpoint.
    * `HEAT`: The HVAC unit will only heat to the given setpoint
    """

    heat_setpoint: Annotated[Nullable[float], pydantic.Field(alias="heatSetpoint")]
    r"""If mode allows, heat when `currentTemperature` falls below this point."""

    cool_setpoint: Annotated[Nullable[float], pydantic.Field(alias="coolSetpoint")]
    r"""If mode allows, cool when `currentTemperature` rises above this point."""

    hold_type: Annotated[Nullable[GetHVACHoldType], pydantic.Field(alias="holdType")]

    last_updated: Annotated[Nullable[datetime], pydantic.Field(alias="lastUpdated")]
    r"""Time of last thermostat state update. Reflects when the OEM reported a change or Enode recorded a change in any field, whichever is newer."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["heatSetpoint", "coolSetpoint", "holdType", "lastUpdated"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetHVACCapabilitiesTypedDict(TypedDict):
    r"""An object describing valid states for this HVAC unit."""

    capable_modes: Nullable[List[HvacMode]]
    r"""A list of valid modes for this HVAC unit."""
    cool_setpoint_range: Nullable[NullableTemperatureRangeTypedDict]
    heat_setpoint_range: Nullable[NullableTemperatureRangeTypedDict]
    setpoint_difference_range: Nullable[NullableTemperatureDifferenceRangeTypedDict]
    set_follow_schedule: CapabilityTypedDict
    set_permanent_hold: CapabilityTypedDict


class GetHVACCapabilities(BaseModel):
    r"""An object describing valid states for this HVAC unit."""

    capable_modes: Annotated[
        Nullable[List[HvacMode]], pydantic.Field(alias="capableModes")
    ]
    r"""A list of valid modes for this HVAC unit."""

    cool_setpoint_range: Annotated[
        Nullable[NullableTemperatureRange], pydantic.Field(alias="coolSetpointRange")
    ]

    heat_setpoint_range: Annotated[
        Nullable[NullableTemperatureRange], pydantic.Field(alias="heatSetpointRange")
    ]

    setpoint_difference_range: Annotated[
        Nullable[NullableTemperatureDifferenceRange],
        pydantic.Field(alias="setpointDifferenceRange"),
    ]

    set_follow_schedule: Annotated[
        Capability, pydantic.Field(alias="setFollowSchedule")
    ]

    set_permanent_hold: Annotated[Capability, pydantic.Field(alias="setPermanentHold")]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "capableModes",
            "coolSetpointRange",
            "heatSetpointRange",
            "setpointDifferenceRange",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetHVACLocationTypedDict(TypedDict):
    id: Nullable[str]
    r"""ID of the charging location the HVAC unit is housed at (if any)"""


class GetHVACLocation(BaseModel):
    id: Nullable[str]
    r"""ID of the charging location the HVAC unit is housed at (if any)"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["id"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetHVACResponseTypedDict(TypedDict):
    r"""Successful"""

    id: str
    r"""HVAC unit ID"""
    user_id: str
    r"""The ID of the user that linked this hvac."""
    vendor: HvacVendor
    r"""Machine-friendly name of the vendor. Use this in API requests."""
    last_seen: datetime
    r"""The last time Enode successfully communicated with the vendor or when the HVAC unit was initially linked."""
    is_reachable: bool
    r"""Indicates whether Enode can currently access live data from the HVAC. If the HVAC is not reachable, data updates will be delayed."""
    consumption_rate: Nullable[float]
    r"""The current rate of energy consumption in kW. An inactive HVAC will have a consumption rate of 0. HVACs not supporting consumption rate will report null. This value is currently only supported by a small number of devices."""
    information: GetHVACInformationTypedDict
    r"""Descriptive information about the HVAC unit"""
    temperature_state: GetHVACTemperatureStateTypedDict
    r"""Latest information about temperature. `null` values indicate we are unable to determine a value for the field based on the information coming from the vendor."""
    thermostat_state: GetHVACThermostatStateTypedDict
    r"""Latest information about the thermostat state. `null` values indicate we are unable to determine a value for the field based on the information coming from the vendor."""
    scopes: List[str]
    r"""Scopes that the user has granted for this HVAC unit."""
    capabilities: GetHVACCapabilitiesTypedDict
    r"""An object describing valid states for this HVAC unit."""
    location: GetHVACLocationTypedDict


class GetHVACResponse(BaseModel):
    r"""Successful"""

    id: str
    r"""HVAC unit ID"""

    user_id: Annotated[str, pydantic.Field(alias="userId")]
    r"""The ID of the user that linked this hvac."""

    vendor: HvacVendor
    r"""Machine-friendly name of the vendor. Use this in API requests."""

    last_seen: Annotated[datetime, pydantic.Field(alias="lastSeen")]
    r"""The last time Enode successfully communicated with the vendor or when the HVAC unit was initially linked."""

    is_reachable: Annotated[bool, pydantic.Field(alias="isReachable")]
    r"""Indicates whether Enode can currently access live data from the HVAC. If the HVAC is not reachable, data updates will be delayed."""

    consumption_rate: Annotated[
        Nullable[float], pydantic.Field(alias="consumptionRate")
    ]
    r"""The current rate of energy consumption in kW. An inactive HVAC will have a consumption rate of 0. HVACs not supporting consumption rate will report null. This value is currently only supported by a small number of devices."""

    information: GetHVACInformation
    r"""Descriptive information about the HVAC unit"""

    temperature_state: Annotated[
        GetHVACTemperatureState, pydantic.Field(alias="temperatureState")
    ]
    r"""Latest information about temperature. `null` values indicate we are unable to determine a value for the field based on the information coming from the vendor."""

    thermostat_state: Annotated[
        GetHVACThermostatState, pydantic.Field(alias="thermostatState")
    ]
    r"""Latest information about the thermostat state. `null` values indicate we are unable to determine a value for the field based on the information coming from the vendor."""

    scopes: List[str]
    r"""Scopes that the user has granted for this HVAC unit."""

    capabilities: GetHVACCapabilities
    r"""An object describing valid states for this HVAC unit."""

    location: GetHVACLocation

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["consumptionRate"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
