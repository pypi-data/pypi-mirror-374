"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .batteryvendor import BatteryVendor
from .chargervendor import ChargerVendor
from .hvacvendor import HvacVendor
from .invertervendor import InverterVendor
from .metervendor import MeterVendor
from .vehiclevendor import VehicleVendor
from .vendortype import VendorType
from datetime import datetime
from enode.types import BaseModel, Nullable, UNSET_SENTINEL
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing import Union
from typing_extensions import Annotated, TypeAliasType, TypedDict


InterventionVendor2TypedDict = TypeAliasType(
    "InterventionVendor2TypedDict",
    Union[
        InverterVendor,
        VehicleVendor,
        HvacVendor,
        ChargerVendor,
        BatteryVendor,
        MeterVendor,
    ],
)
r"""A null value indicates that this intervention is not specific to a single brand or device type."""


InterventionVendor2 = TypeAliasType(
    "InterventionVendor2",
    Union[
        InverterVendor,
        VehicleVendor,
        HvacVendor,
        ChargerVendor,
        BatteryVendor,
        MeterVendor,
    ],
)
r"""A null value indicates that this intervention is not specific to a single brand or device type."""


class InterventionVendorType(str, Enum):
    r"""A null value indicates that this intervention is not specific to a single brand or device type."""

    VEHICLE = "vehicle"
    CHARGER = "charger"
    HVAC = "hvac"
    INVERTER = "inverter"
    BATTERY = "battery"
    METER = "meter"


class Domain2(str, Enum):
    r"""The domain the intervention is related to. i.e. Is the intervention related to the vendor service account or a setting on the device."""

    ACCOUNT = "Account"
    DEVICE = "Device"


class Access2(str, Enum):
    r"""Where the intervention needs to be resolved. i.e. remotely using the vendor's app or directly on the device."""

    REMOTE = "Remote"
    PHYSICAL = "Physical"


class Agent2(str, Enum):
    r"""Who can resolve the intervention. i.e. a user can resolve the intervention themselves, or a licensed service retailer is needed."""

    USER = "User"
    THIRD_PARTY = "ThirdParty"


class Action2(str, Enum):
    r"""If non null, the action to be taken by the user to resolve the intervention. See our guide on [resolving interventions](https://developers.enode.com/docs/link-ui/relinking) for more information."""

    LINK = "Link"


class Resolution2TypedDict(TypedDict):
    title: str
    r"""A localized title for the intervention."""
    description: str
    r"""A localized description of how to resolve the intervention. Formatted as Markdown."""
    access: Access2
    r"""Where the intervention needs to be resolved. i.e. remotely using the vendor's app or directly on the device."""
    agent: Agent2
    r"""Who can resolve the intervention. i.e. a user can resolve the intervention themselves, or a licensed service retailer is needed."""
    action: Nullable[Action2]
    r"""If non null, the action to be taken by the user to resolve the intervention. See our guide on [resolving interventions](https://developers.enode.com/docs/link-ui/relinking) for more information."""


class Resolution2(BaseModel):
    title: str
    r"""A localized title for the intervention."""

    description: str
    r"""A localized description of how to resolve the intervention. Formatted as Markdown."""

    access: Access2
    r"""Where the intervention needs to be resolved. i.e. remotely using the vendor's app or directly on the device."""

    agent: Agent2
    r"""Who can resolve the intervention. i.e. a user can resolve the intervention themselves, or a licensed service retailer is needed."""

    action: Nullable[Action2]
    r"""If non null, the action to be taken by the user to resolve the intervention. See our guide on [resolving interventions](https://developers.enode.com/docs/link-ui/relinking) for more information."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["action"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class IntegrationAgnosticInterventionTypedDict(TypedDict):
    id: str
    vendor: Nullable[InterventionVendor2TypedDict]
    r"""A null value indicates that this intervention is not specific to a single brand or device type."""
    vendor_type: Nullable[InterventionVendorType]
    brand: Nullable[str]
    introduced_at: datetime
    r"""ISO8601 UTC timestamp of when the intervention was introduced."""
    domain: Domain2
    r"""The domain the intervention is related to. i.e. Is the intervention related to the vendor service account or a setting on the device."""
    resolution: Resolution2TypedDict


class IntegrationAgnosticIntervention(BaseModel):
    id: str

    vendor: Nullable[InterventionVendor2]
    r"""A null value indicates that this intervention is not specific to a single brand or device type."""

    vendor_type: Annotated[
        Nullable[InterventionVendorType], pydantic.Field(alias="vendorType")
    ]

    brand: Nullable[str]

    introduced_at: Annotated[datetime, pydantic.Field(alias="introducedAt")]
    r"""ISO8601 UTC timestamp of when the intervention was introduced."""

    domain: Domain2
    r"""The domain the intervention is related to. i.e. Is the intervention related to the vendor service account or a setting on the device."""

    resolution: Resolution2

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["vendor", "vendorType", "brand"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


InterventionVendor1TypedDict = TypeAliasType(
    "InterventionVendor1TypedDict",
    Union[
        InverterVendor,
        VehicleVendor,
        HvacVendor,
        ChargerVendor,
        BatteryVendor,
        MeterVendor,
    ],
)
r"""Machine-friendly representation of the OEM's name."""


InterventionVendor1 = TypeAliasType(
    "InterventionVendor1",
    Union[
        InverterVendor,
        VehicleVendor,
        HvacVendor,
        ChargerVendor,
        BatteryVendor,
        MeterVendor,
    ],
)
r"""Machine-friendly representation of the OEM's name."""


class Domain1(str, Enum):
    r"""The domain the intervention is related to. i.e. Is the intervention related to the vendor service account or a setting on the device."""

    ACCOUNT = "Account"
    DEVICE = "Device"


class Access1(str, Enum):
    r"""Where the intervention needs to be resolved. i.e. remotely using the vendor's app or directly on the device."""

    REMOTE = "Remote"
    PHYSICAL = "Physical"


class Agent1(str, Enum):
    r"""Who can resolve the intervention. i.e. a user can resolve the intervention themselves, or a licensed service retailer is needed."""

    USER = "User"
    THIRD_PARTY = "ThirdParty"


class Action1(str, Enum):
    r"""If non null, the action to be taken by the user to resolve the intervention. See our guide on [resolving interventions](https://developers.enode.com/docs/link-ui/relinking) for more information."""

    LINK = "Link"


class Resolution1TypedDict(TypedDict):
    title: str
    r"""A localized title for the intervention."""
    description: str
    r"""A localized description of how to resolve the intervention. Formatted as Markdown."""
    access: Access1
    r"""Where the intervention needs to be resolved. i.e. remotely using the vendor's app or directly on the device."""
    agent: Agent1
    r"""Who can resolve the intervention. i.e. a user can resolve the intervention themselves, or a licensed service retailer is needed."""
    action: Nullable[Action1]
    r"""If non null, the action to be taken by the user to resolve the intervention. See our guide on [resolving interventions](https://developers.enode.com/docs/link-ui/relinking) for more information."""


class Resolution1(BaseModel):
    title: str
    r"""A localized title for the intervention."""

    description: str
    r"""A localized description of how to resolve the intervention. Formatted as Markdown."""

    access: Access1
    r"""Where the intervention needs to be resolved. i.e. remotely using the vendor's app or directly on the device."""

    agent: Agent1
    r"""Who can resolve the intervention. i.e. a user can resolve the intervention themselves, or a licensed service retailer is needed."""

    action: Nullable[Action1]
    r"""If non null, the action to be taken by the user to resolve the intervention. See our guide on [resolving interventions](https://developers.enode.com/docs/link-ui/relinking) for more information."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["action"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class IntegrationInterventionTypedDict(TypedDict):
    id: str
    vendor: InterventionVendor1TypedDict
    r"""Machine-friendly representation of the OEM's name."""
    vendor_type: VendorType
    brand: str
    r"""A formatted and properly cased OEM brand name, suitable for reading by humans. May contain special characters."""
    introduced_at: datetime
    r"""ISO8601 UTC timestamp of when the intervention was introduced."""
    domain: Domain1
    r"""The domain the intervention is related to. i.e. Is the intervention related to the vendor service account or a setting on the device."""
    resolution: Resolution1TypedDict


class IntegrationIntervention(BaseModel):
    id: str

    vendor: InterventionVendor1
    r"""Machine-friendly representation of the OEM's name."""

    vendor_type: Annotated[VendorType, pydantic.Field(alias="vendorType")]

    brand: str
    r"""A formatted and properly cased OEM brand name, suitable for reading by humans. May contain special characters."""

    introduced_at: Annotated[datetime, pydantic.Field(alias="introducedAt")]
    r"""ISO8601 UTC timestamp of when the intervention was introduced."""

    domain: Domain1
    r"""The domain the intervention is related to. i.e. Is the intervention related to the vendor service account or a setting on the device."""

    resolution: Resolution1


InterventionTypedDict = TypeAliasType(
    "InterventionTypedDict",
    Union[IntegrationInterventionTypedDict, IntegrationAgnosticInterventionTypedDict],
)


Intervention = TypeAliasType(
    "Intervention", Union[IntegrationIntervention, IntegrationAgnosticIntervention]
)
