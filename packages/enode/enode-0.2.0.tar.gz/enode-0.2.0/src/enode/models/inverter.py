"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .invertercapabilities import InverterCapabilities, InverterCapabilitiesTypedDict
from .inverterinformation import InverterInformation, InverterInformationTypedDict
from .inverterlocation import InverterLocation, InverterLocationTypedDict
from .inverterproductionstate import (
    InverterProductionState,
    InverterProductionStateTypedDict,
)
from .invertervendor import InverterVendor
from datetime import datetime
from enode.types import BaseModel, Nullable, UNSET_SENTINEL
import pydantic
from pydantic import model_serializer
from typing import List
from typing_extensions import Annotated, TypedDict


class InverterTypedDict(TypedDict):
    r"""Solar inverter object"""

    id: str
    r"""Solar Inverter ID"""
    user_id: str
    r"""The ID of the user that linked this inverter."""
    vendor: InverterVendor
    r"""Machine-friendly name of the vendor. Use this in API requests."""
    last_seen: datetime
    r"""The last time Enode received live data or when the solar inverter was initially linked."""
    is_reachable: bool
    r"""Indicates whether Enode can currently access live data from the inverter. If the inverter is not reachable, data updates will be delayed."""
    production_state: InverterProductionStateTypedDict
    r"""Latest information about solar production. `null` values indicate we are unable to determine a value for the field based on the information coming from the vendor."""
    timezone: Nullable[str]
    r"""IANA TZ database timezone name representing the location of this inverter."""
    capabilities: InverterCapabilitiesTypedDict
    r"""A collection of descriptors that describe the capabilities of this specific inverter.

    Note: [Sample-based statistics](/api/reference#getProductionStatistics) collected by Enode rely on the `productionState` capability and are not affected by this capability.
    """
    scopes: List[str]
    r"""Scopes that the user has granted for this inverter."""
    information: InverterInformationTypedDict
    r"""Descriptive information about the solar inverter"""
    location: InverterLocationTypedDict
    r"""Solar inverter's GPS coordinates"""


class Inverter(BaseModel):
    r"""Solar inverter object"""

    id: str
    r"""Solar Inverter ID"""

    user_id: Annotated[str, pydantic.Field(alias="userId")]
    r"""The ID of the user that linked this inverter."""

    vendor: InverterVendor
    r"""Machine-friendly name of the vendor. Use this in API requests."""

    last_seen: Annotated[datetime, pydantic.Field(alias="lastSeen")]
    r"""The last time Enode received live data or when the solar inverter was initially linked."""

    is_reachable: Annotated[bool, pydantic.Field(alias="isReachable")]
    r"""Indicates whether Enode can currently access live data from the inverter. If the inverter is not reachable, data updates will be delayed."""

    production_state: Annotated[
        InverterProductionState, pydantic.Field(alias="productionState")
    ]
    r"""Latest information about solar production. `null` values indicate we are unable to determine a value for the field based on the information coming from the vendor."""

    timezone: Nullable[str]
    r"""IANA TZ database timezone name representing the location of this inverter."""

    capabilities: InverterCapabilities
    r"""A collection of descriptors that describe the capabilities of this specific inverter.

    Note: [Sample-based statistics](/api/reference#getProductionStatistics) collected by Enode rely on the `productionState` capability and are not affected by this capability.
    """

    scopes: List[str]
    r"""Scopes that the user has granted for this inverter."""

    information: InverterInformation
    r"""Descriptive information about the solar inverter"""

    location: InverterLocation
    r"""Solar inverter's GPS coordinates"""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["timezone"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
