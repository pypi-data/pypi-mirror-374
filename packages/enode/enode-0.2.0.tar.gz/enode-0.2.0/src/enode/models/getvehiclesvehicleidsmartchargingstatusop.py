"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

from __future__ import annotations
from .consideration import Consideration, ConsiderationTypedDict
from .smartchargestate import SmartChargeState
from .vehiclevendor import VehicleVendor
from datetime import datetime
from enode.types import BaseModel, Nullable, UNSET_SENTINEL
from enode.utils import FieldMetadata, PathParamMetadata
from enum import Enum
import pydantic
from pydantic import model_serializer
from typing_extensions import Annotated, TypedDict


class GetVehiclesVehicleidSmartchargingstatusRequestTypedDict(TypedDict):
    vehicle_id: str


class GetVehiclesVehicleidSmartchargingstatusRequest(BaseModel):
    vehicle_id: Annotated[
        str,
        pydantic.Field(alias="vehicleId"),
        FieldMetadata(path=PathParamMetadata(style="simple", explode=False)),
    ]


class FinalState(str, Enum):
    r"""The final state of the Smart Charging Plan when it ended"""

    PLAN_ENDED_FINISHED = "PLAN:ENDED:FINISHED"
    PLAN_ENDED_UNPLUGGED = "PLAN:ENDED:UNPLUGGED"
    PLAN_ENDED_FAILED = "PLAN:ENDED:FAILED"
    PLAN_ENDED_DISABLED = "PLAN:ENDED:DISABLED"
    PLAN_ENDED_DEADLINE_CHANGED = "PLAN:ENDED:DEADLINE_CHANGED"


class FailureCondition(str, Enum):
    r"""If the finalState was `PLAN:ENDED:FAILED`, failureCondition is populated with the condition in which the Smart Charging Plan failed. If the finalState was `PLAN:ENDED:FINISHED`, failureCondition is populated with `FINISHED_LATE` if the plan was more than 15% late."""

    STOP_FAILED = "STOP_FAILED"
    START_FAILED = "START_FAILED"
    FINISHED_LATE = "FINISHED_LATE"
    UNKNOWN = "UNKNOWN"
    CHARGE_INTERRUPTED = "CHARGE_INTERRUPTED"


class PlanTypedDict(TypedDict):
    r"""`null` by default, but during all of the `PLAN:*` states,  the value is populated with a description of the active plan"""

    id: str
    r"""ID of the Smart Charging Plan"""
    vehicle_id: str
    r"""ID of the Vehicle to which the Smart Charging Plan belongs"""
    user_id: str
    r"""ID of the User to which the Smart Charging Plan belongs"""
    location_id: Nullable[str]
    r"""ID of the location at which the Smart Charging Plan is being executed. Null for Smart Charging Plans started before March 2022."""
    vendor: VehicleVendor
    currency: str
    r"""Currency in which monetary amounts are denominated (ISO 4217 3-character Alpha code)"""
    non_smart_cost: float
    smart_cost: Nullable[float]
    stop_at: datetime
    r"""Time at which the current Smart Charging Plan will stop the vehicle's charging. The charging will be resumed when prices are optimal."""
    start_at: Nullable[datetime]
    r"""Time at which the current Smart Charging Plan will resume the vehicle's charging, when prices are optimal."""
    estimated_finish_at: datetime
    r"""Time at which charging is estimated to be complete, due to the current Smart Charging Plan"""
    stop_confirmed_at: Nullable[datetime]
    r"""During a Smart Charging Plan, the first time at which the vehicle's charging was confirmed as stopped. If a vehicle stops charging outside of smart charging's control (e.g., via a 3rd party app), this will be populated with that timestamp."""
    start_confirmed_at: Nullable[datetime]
    r"""During a Smart Charging Plan, the first time at which the vehicle's charging was confirmed as started. If a vehicle starts charging outside of smart charging's control (e.g., via a 3rd party app), this will be populated with that timestamp."""
    ended_at: Nullable[datetime]
    r"""The time at which the Smart Charging Plan ended"""
    final_state: Nullable[FinalState]
    r"""The final state of the Smart Charging Plan when it ended"""
    failure_condition: Nullable[FailureCondition]


class Plan(BaseModel):
    r"""`null` by default, but during all of the `PLAN:*` states,  the value is populated with a description of the active plan"""

    id: str
    r"""ID of the Smart Charging Plan"""

    vehicle_id: Annotated[str, pydantic.Field(alias="vehicleId")]
    r"""ID of the Vehicle to which the Smart Charging Plan belongs"""

    user_id: Annotated[str, pydantic.Field(alias="userId")]
    r"""ID of the User to which the Smart Charging Plan belongs"""

    location_id: Annotated[Nullable[str], pydantic.Field(alias="locationId")]
    r"""ID of the location at which the Smart Charging Plan is being executed. Null for Smart Charging Plans started before March 2022."""

    vendor: VehicleVendor

    currency: str
    r"""Currency in which monetary amounts are denominated (ISO 4217 3-character Alpha code)"""

    non_smart_cost: Annotated[float, pydantic.Field(alias="nonSmartCost")]

    smart_cost: Annotated[Nullable[float], pydantic.Field(alias="smartCost")]

    stop_at: Annotated[datetime, pydantic.Field(alias="stopAt")]
    r"""Time at which the current Smart Charging Plan will stop the vehicle's charging. The charging will be resumed when prices are optimal."""

    start_at: Annotated[Nullable[datetime], pydantic.Field(alias="startAt")]
    r"""Time at which the current Smart Charging Plan will resume the vehicle's charging, when prices are optimal."""

    estimated_finish_at: Annotated[datetime, pydantic.Field(alias="estimatedFinishAt")]
    r"""Time at which charging is estimated to be complete, due to the current Smart Charging Plan"""

    stop_confirmed_at: Annotated[
        Nullable[datetime], pydantic.Field(alias="stopConfirmedAt")
    ]
    r"""During a Smart Charging Plan, the first time at which the vehicle's charging was confirmed as stopped. If a vehicle stops charging outside of smart charging's control (e.g., via a 3rd party app), this will be populated with that timestamp."""

    start_confirmed_at: Annotated[
        Nullable[datetime], pydantic.Field(alias="startConfirmedAt")
    ]
    r"""During a Smart Charging Plan, the first time at which the vehicle's charging was confirmed as started. If a vehicle starts charging outside of smart charging's control (e.g., via a 3rd party app), this will be populated with that timestamp."""

    ended_at: Annotated[Nullable[datetime], pydantic.Field(alias="endedAt")]
    r"""The time at which the Smart Charging Plan ended"""

    final_state: Annotated[Nullable[FinalState], pydantic.Field(alias="finalState")]
    r"""The final state of the Smart Charging Plan when it ended"""

    failure_condition: Annotated[
        Nullable[FailureCondition], pydantic.Field(alias="failureCondition")
    ]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = [
            "locationId",
            "smartCost",
            "startAt",
            "stopConfirmedAt",
            "startConfirmedAt",
            "endedAt",
            "finalState",
            "failureCondition",
        ]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetVehiclesVehicleidSmartchargingstatusTargetType(str, Enum):
    VEHICLE = "vehicle"
    CHARGER = "charger"


class GetVehiclesVehicleidSmartchargingstatusSmartOverrideTypedDict(TypedDict):
    r"""This field populates after using Vehicle [Create Smart Override](/api/reference#vehicleCreateSmartOverride) or Charger [Create Smart Override](/api/reference#chargerCreateSmartOverride). Once populated, the target enters an overridden state, stopping Enode from sending Smart Charging actions. The Smart Override persists until the target ceases charging for any reason or is manually ended via Vehicle [End Smart Override](/api/reference#vehicleEndSmartOverride) or Charger [End Smart Override](/api/reference#chargerEndSmartOverride)."""

    created_at: datetime
    r"""Time at which the smart override was created."""
    ended_at: Nullable[datetime]
    r"""Time at which the smart override was ended. If null, the smart override is still active."""
    target_type: GetVehiclesVehicleidSmartchargingstatusTargetType
    target_id: str
    r"""ID of the target which this smart override is affecting."""
    vendor_action_id: Nullable[str]
    r"""The ID of the Action responsible for starting charging on the target. Use the [Get Vehicle Action](/api/reference#getVehiclesAction) or the [Get Charger Action](/api/reference#getChargersAction) endpoints to monitor action results."""


class GetVehiclesVehicleidSmartchargingstatusSmartOverride(BaseModel):
    r"""This field populates after using Vehicle [Create Smart Override](/api/reference#vehicleCreateSmartOverride) or Charger [Create Smart Override](/api/reference#chargerCreateSmartOverride). Once populated, the target enters an overridden state, stopping Enode from sending Smart Charging actions. The Smart Override persists until the target ceases charging for any reason or is manually ended via Vehicle [End Smart Override](/api/reference#vehicleEndSmartOverride) or Charger [End Smart Override](/api/reference#chargerEndSmartOverride)."""

    created_at: Annotated[datetime, pydantic.Field(alias="createdAt")]
    r"""Time at which the smart override was created."""

    ended_at: Annotated[Nullable[datetime], pydantic.Field(alias="endedAt")]
    r"""Time at which the smart override was ended. If null, the smart override is still active."""

    target_type: Annotated[
        GetVehiclesVehicleidSmartchargingstatusTargetType,
        pydantic.Field(alias="targetType"),
    ]

    target_id: Annotated[str, pydantic.Field(alias="targetId")]
    r"""ID of the target which this smart override is affecting."""

    vendor_action_id: Annotated[Nullable[str], pydantic.Field(alias="vendorActionId")]
    r"""The ID of the Action responsible for starting charging on the target. Use the [Get Vehicle Action](/api/reference#getVehiclesAction) or the [Get Charger Action](/api/reference#getChargersAction) endpoints to monitor action results."""

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["endedAt", "vendorActionId"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m


class GetVehiclesVehicleidSmartchargingstatusResponseTypedDict(TypedDict):
    r"""Successful"""

    updated_at: datetime
    r"""Time when the Smart Charging Status was recalculated, irrespective of whether or not any values changed"""
    vehicle_id: str
    r"""ID of the vehicle to which this Smart Charging Status represents"""
    user_id: str
    r"""ID of the user that owns this vehicle"""
    vendor: VehicleVendor
    state: SmartChargeState
    r"""An enum value that describes the current Smart Charging state of the vehicle. Every vehicle is in exactly one state, at all times. If the returned state is `UNKNOWN`, this might indicate that the vehicle is no longer capable of smart charging. In this case we recommend that you check the capabilities of the vehicle to determine what should be communicated to users. If we don't have pricing data or tariffs for the location of the vehicle, the state will also be `UNKNOWN`. In this case, we recommend that you contact Enode staff."""
    state_changed_at: datetime
    r"""Time when the `state` property transitioned to its current value"""
    consideration: Nullable[ConsiderationTypedDict]
    plan: Nullable[PlanTypedDict]
    smart_override: Nullable[
        GetVehiclesVehicleidSmartchargingstatusSmartOverrideTypedDict
    ]


class GetVehiclesVehicleidSmartchargingstatusResponse(BaseModel):
    r"""Successful"""

    updated_at: Annotated[datetime, pydantic.Field(alias="updatedAt")]
    r"""Time when the Smart Charging Status was recalculated, irrespective of whether or not any values changed"""

    vehicle_id: Annotated[str, pydantic.Field(alias="vehicleId")]
    r"""ID of the vehicle to which this Smart Charging Status represents"""

    user_id: Annotated[str, pydantic.Field(alias="userId")]
    r"""ID of the user that owns this vehicle"""

    vendor: VehicleVendor

    state: SmartChargeState
    r"""An enum value that describes the current Smart Charging state of the vehicle. Every vehicle is in exactly one state, at all times. If the returned state is `UNKNOWN`, this might indicate that the vehicle is no longer capable of smart charging. In this case we recommend that you check the capabilities of the vehicle to determine what should be communicated to users. If we don't have pricing data or tariffs for the location of the vehicle, the state will also be `UNKNOWN`. In this case, we recommend that you contact Enode staff."""

    state_changed_at: Annotated[datetime, pydantic.Field(alias="stateChangedAt")]
    r"""Time when the `state` property transitioned to its current value"""

    consideration: Nullable[Consideration]

    plan: Nullable[Plan]

    smart_override: Annotated[
        Nullable[GetVehiclesVehicleidSmartchargingstatusSmartOverride],
        pydantic.Field(alias="smartOverride"),
    ]

    @model_serializer(mode="wrap")
    def serialize_model(self, handler):
        optional_fields = []
        nullable_fields = ["consideration", "plan", "smartOverride"]
        null_default_fields = []

        serialized = handler(self)

        m = {}

        for n, f in type(self).model_fields.items():
            k = f.alias or n
            val = serialized.get(k)
            serialized.pop(k, None)

            optional_nullable = k in optional_fields and k in nullable_fields
            is_set = (
                self.__pydantic_fields_set__.intersection({n})
                or k in null_default_fields
            )  # pylint: disable=no-member

            if val is not None and val != UNSET_SENTINEL:
                m[k] = val
            elif val != UNSET_SENTINEL and (
                not k in optional_fields or (optional_nullable and is_set)
            ):
                m[k] = val

        return m
