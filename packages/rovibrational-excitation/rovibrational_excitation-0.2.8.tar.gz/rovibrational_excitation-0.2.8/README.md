# rovibrational-excitation

<!-- Core Information -->
[![PyPI version](https://img.shields.io/pypi/v/rovibrational-excitation.svg)](https://pypi.org/project/rovibrational-excitation/)
[![Python](https://img.shields.io/pypi/pyversions/rovibrational-excitation.svg)](https://pypi.org/project/rovibrational-excitation/)
[![Downloads](https://img.shields.io/pypi/dm/rovibrational-excitation.svg)](https://pypi.org/project/rovibrational-excitation/)
[![License](https://img.shields.io/github/license/1160-hrk/rovibrational-excitation.svg)](https://github.com/1160-hrk/rovibrational-excitation/blob/main/LICENSE)

<!-- Quality Assurance -->
[![Tests](https://github.com/1160-hrk/rovibrational-excitation/actions/workflows/tests.yml/badge.svg)](https://github.com/1160-hrk/rovibrational-excitation/actions/workflows/tests.yml)
[![Coverage](https://codecov.io/gh/1160-hrk/rovibrational-excitation/branch/main/graph/badge.svg)](https://codecov.io/gh/1160-hrk/rovibrational-excitation)
[![Code Quality](https://github.com/1160-hrk/rovibrational-excitation/actions/workflows/ci.yml/badge.svg)](https://github.com/1160-hrk/rovibrational-excitation/actions/workflows/ci.yml)

Python package for **time-dependent quantum dynamics** of
linear molecules (rotation √ó vibration) driven by femtosecond‚Äìpicosecond
laser pulses.

<div align="center">

| CPU / GPU (CuPy) | Numba-JIT RK4 propagator | Lazy, cached dipole matrices |
|------------------|--------------------------|------------------------------|

</div>

---

## Key features

### üîß High-Performance Time Evolution Engine
* **Runge‚ÄìKutta 4 (RK-4)** propagators for the Schr√∂dinger and Liouville‚Äìvon Neumann equations (`complex128`, cache-friendly).
* **Split-operator method** with CPU/GPU backends for efficient propagation.

### ‚ö° High-Speed Dipole Matrix Construction
* **Lazy, high-speed construction** of transition-dipole matrices (`rovibrational_excitation.dipole.*`)  
  * rigid-rotor + harmonic / Morse vibration  
  * Numba (CPU) or CuPy (GPU) backend
* **Lazy evaluation & caching** for fast computation

### üåä Flexible Electric Field Control
* **Vector electric-field objects** with Gaussian envelopes, chirp, optional sinusoidal and binned modulation.
* Gaussian envelope, chirp functionality
* Sinusoidal and binned modulation options
* Vector field support

### üìä Batch Processing & Analysis
* **Batch runner** for pump‚Äìprobe / parameter sweeps with automatic directory creation, progress-bar and compressed output (`.npz`).
* Pump-probe experiment simulation
* Parameter sweep capabilities
* Automatic directory creation
* Progress bar display
* Compressed output (`.npz`)

### üî¨ Supported Molecules
* Currently, only **linear molecules** are supported; that is, only the rotational quantum numbers J and M are taken into account.
* Future extension to non-linear molecules is planned.

### üèóÔ∏è Pure Python Implementation
* 100 % pure-Python, **no compiled extension to ship** (Numba compiles at runtime).

---

## Testing & Coverage

The package includes a comprehensive test suite with **63% code coverage** across all modules.

- üü¢ **Basis classes**: 100% coverage (LinMol, TwoLevel, VibLadder)
- üü° **Core physics**: 55% overall coverage
  - States: 98% coverage  
  - Propagator: 83% coverage
  - Hamiltonian: 67% coverage
- üü° **Electric field**: 53% coverage
- üü° **Dipole matrices**: 52-96% coverage (varies by subsystem)
- üî¥ **Low-level propagators**: 25-38% coverage (ongoing development)
- üü° **Simulation runner**: 62% coverage

See [`tests/README.md`](tests/README.md) for detailed coverage reports and test instructions.

```bash
# Run tests
cd tests/ && python -m pytest -v

# Generate coverage report
coverage run -m pytest && coverage report
```

---

## Installation

### Stable Release (PyPI)
```bash
# From PyPI  (stable)
pip install rovibrational-excitation          # installs sub-packages as well
```

### Development Version (GitHub)
```bash
# Or from GitHub (main branch, bleeding-edge)
pip install git+https://github.com/1160-hrk/rovibrational-excitation.git
```

### GPU Acceleration (Optional)
> **CuPy (optional)** ‚Äì for GPU acceleration
>
> ```bash
> pip install cupy-cuda12x     # pick the wheel that matches your CUDA
> ```

---

## Requirements

### Python Environment
- **Python**: 3.10+
- **NumPy**: Array operations & numerical computing
- **SciPy**: Scientific computing library
- **Numba**: JIT compilation (CPU acceleration)

### Optional Dependencies
- **CuPy**: GPU computing (requires CUDA)
- **Matplotlib**: Graph plotting
- **tqdm**: Progress bars

---

## üìö Documentation

For detailed usage instructions and parameter reference:

| Document | Description | Audience |
|----------|-------------|----------|
| **[docs/PARAMETER_REFERENCE.md](docs/PARAMETER_REFERENCE.md)** | **Complete parameter reference** | All users |
| [docs/SWEEP_SPECIFICATION.md](docs/SWEEP_SPECIFICATION.md) | Parameter sweep specification | Intermediate |
| [docs/README.md](docs/README.md) | Documentation index & quick guides | All users |
| [examples/params_template.py](examples/params_template.py) | Parameter file template | Beginners |

### üöÄ Getting Started

1. **Read the parameter reference**: [docs/PARAMETER_REFERENCE.md](docs/PARAMETER_REFERENCE.md)
2. **Copy the template**: `cp examples/params_template.py my_params.py`
3. **Edit parameters** according to your system
4. **Run simulation**: `python -m rovibrational_excitation.simulation.runner my_params.py`

---

## Quick start : library API

```python
import numpy as np
import rovibrational_excitation as rve

# --- 1. Basis & dipole matrices ----------------------------------
c_vacuum = 299792458 * 1e2 / 1e15  # cm/fs
debye_unit = 3.33564e-30                       # 1 D ‚Üí C¬∑m
Omega01_rad_phz = 2349*2*np.pi*c_vacuum
Delta_omega_rad_phz = 25*2*np.pi*c_vacuum
B_rad_phz = 0.39e-3*2*np.pi*c_vacuum
Mu0_Cm = 0.3 * debye_unit                      # 0.3 Debye Áõ∏ÂΩì
Potential_type = "harmonic"  # or "morse"
V_max = 2
J_max = 4

basis = rve.LinMolBasis(
            V_max=V_max,
            J_max=J_max,
            use_M = True,
            omega_rad_phz = Omega01_rad_phz,
            delta_omega_rad_phz = Delta_omega_rad_phz
            )           # |v J M‚ü© direct-product

dip   = rve.LinMolDipoleMatrix(
            basis, mu0=Mu0_Cm, potential_type=Potential_type,
            backend="numpy", dense=True)            # CSR on GPU

mu_x  = dip.mu_x            # lazy-built, cached thereafter
mu_y  = dip.mu_y
mu_z  = dip.mu_z

# --- 2. Hamiltonian ----------------------------------------------
H0 = rve.generate_H0_LinMol(
        basis,
        omega_rad_phz       = Omega01_rad_phz,
        delta_omega_rad_phz = Delta_omega_rad_phz,
        B_rad_phz           = B_rad_phz,
)

# --- 3. Electric field -------------------------------------------
t  = np.linspace(-200, 200, 4001)                   # fs
E  = rve.ElectricField(tlist=t)
E.add_dispersed_Efield(
        envelope_func=rve.core.electric_field.gaussian_fwhm,
        duration=50.0,             # FWHM (fs)
        t_center=0.0,
        carrier_freq=2349*2*np.pi*c_vacuum,   # rad/fs
        amplitude=1.0,
        polarization=[1.0, 0.0],   # x-pol.
)

# --- 4. Initial state |v=0,J=0,M=0‚ü© ------------------------------
from rovibrational_excitation.core.states import StateVector
psi0 = StateVector(basis)
psi0.set_state((0,0,0), 1.0)
psi0.normalize()

# --- 5. Time propagation (Schr√∂dinger) ---------------------------
psi_t = rve.schrodinger_propagation(
            H0, E, dip,
            psi0.data,
            axes="xy",              # Ex‚ÜíŒºx, Ey‚ÜíŒºy
            sample_stride=10,
            backend="numpy")        # or "cupy"

population = np.abs(psi_t)**2
print(population.shape)            # (Nt, dim)
```

---

## Quick start : batch runner

1. **Create a parameter file** (`params_CO2.py`)

```python
# description is used in results/<timestamp>_<description>/
description = "CO2_antisymm_stretch"

# --- time axis (fs) ---------------------------------------------
t_start, t_end, dt = -200.0, 200.0, 0.1       # Unit is fs

# --- electric-field scan ----------------------------------------
duration       = [50.0, 80.0]                 # Gaussian FWHM (fs)
polarization   = [[1,0], [1/2**0.5,1j/2**0.5]]
t_center       = [0.0, 100.0]

carrier_freq   = 2349*2*np.pi*1e12*1e-15      # rad/fs
amplitude      = 1.0e9                        # V/m

# --- molecular constants ----------------------------------------
V_max, J_max   = 2, 4
omega_rad_phz   = carrier_freq * 2 * np.pi
mu0_Cm         = 0.3 * 3.33564e-30            # 0.3 D
```

2. **Run**

```bash
python -m rovibrational_excitation.simulation.runner \
       examples/params_CO2.py     -j 4      # 4 processes
```

* Creates `results/YYYY-MM-DD_hh-mm-ss_CO2_antisymm_stretch/‚Ä¶`
* For each case a folder with `result.npz`, `parameters.json`
* Top-level `summary.csv` (final populations etc.)

> Add `--dry-run` to just list cases without running.

---

## Applications

### CO2 Antisymmetric Stretch Vibration Excitation
- **Molecule**: CO2 (linear triatomic molecule)
- **Excitation mode**: Antisymmetric stretch vibration (ŒΩ‚ÇÉ ‚âà 2349 cm‚Åª¬π)
- **Laser**: Femtosecond pulse
- **Analysis**: Population transfer between vibrational levels

### Pump-Probe Experiments
- **Pump pulse**: Molecular excitation
- **Probe pulse**: State exploration after time delay
- **Measurements**: Time-resolved spectra, population dynamics

---

## Directory layout

```
rovibrational_excitation/
‚îú‚îÄ‚îÄ src/rovibrational_excitation/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py          # public re-export
‚îÇ   ‚îú‚îÄ‚îÄ core/                # low-level numerics
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ basis/           # quantum basis classes
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ base.py      # abstract base class
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ linmol.py    # linear molecule basis
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ twolevel.py  # two-level system
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ viblad.py    # vibrational ladder
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ propagator.py    # time evolution
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ electric_field.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ hamiltonian.py   # DEPRECATED
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ states.py        # quantum state vectors
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _rk4_schrodinger.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ _rk4_lvne.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ _splitop_schrodinger.py
‚îÇ   ‚îú‚îÄ‚îÄ dipole/              # transition dipole matrices
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ linmol/          # linear molecules
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ builder.py   # matrix construction
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cache.py     # caching system
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ twolevel/        # two-level systems
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ viblad/          # vibrational ladder
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rot/             # rotational elements
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ j.py         # J quantum number
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ jm.py        # J,M quantum numbers
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ vib/             # vibrational elements
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ harmonic.py  # harmonic oscillator
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ morse.py     # Morse oscillator
‚îÇ   ‚îú‚îÄ‚îÄ plots/               # visualization helpers
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plot_electric_field.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ plot_electric_field_vector.py
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ plot_population.py
‚îÇ   ‚îî‚îÄ‚îÄ simulation/          # batch runner & CLI
‚îÇ       ‚îú‚îÄ‚îÄ runner.py        # main execution engine
‚îÇ       ‚îú‚îÄ‚îÄ manager.py       # execution management
‚îÇ       ‚îî‚îÄ‚îÄ config.py        # configuration handling
‚îú‚îÄ‚îÄ tests/                   # unit tests (pytest)
‚îú‚îÄ‚îÄ validation/              # physics validation scripts
‚îÇ   ‚îú‚îÄ‚îÄ core/                # core physics validation
‚îÇ   ‚îú‚îÄ‚îÄ dipole/              # dipole matrix validation
‚îÇ   ‚îî‚îÄ‚îÄ simulation/          # integration validation
‚îú‚îÄ‚îÄ examples/                # usage examples
‚îî‚îÄ‚îÄ docs/                    # documentation
```

### Validation vs Testing

- **`tests/`**: Unit tests for code correctness (fast, comprehensive)
- **`validation/`**: Physics validation for scientific accuracy (slower, focused on physical laws)

```bash
# Run unit tests
pytest tests/ -v

# Run physics validation
python validation/core/check_core_basis.py
find validation/ -name "check_*.py" -exec python {} \;
```

---

## Development

```bash
git clone https://github.com/1160-hrk/rovibrational-excitation.git
cd rovibrational-excitation
python -m venv .venv && source .venv/bin/activate
pip install -r requirements-dev.txt
pytest -v
```

### Development Tools
- **Black**: Code formatter
- **Ruff**: High-speed linter  
- **MyPy**: Static type checking
- **pytest**: Testing framework

Black + Ruff + MyPy configs are in *pyproject.toml*.

---

## Contributing

1. **Issue Reports**: Bug reports & feature requests
2. **Pull Requests**: Code improvements & new features
3. **Documentation**: Usage examples & tutorials

### Development Guidelines
- PEP8-compliant code style
- Type hints required
- Maintain test coverage
- Detailed docstrings

---

## References

1. **Quantum Mechanics**: Griffiths, "Introduction to Quantum Mechanics"
2. **Molecular Spectroscopy**: Herzberg, "Molecular Spectra and Molecular Structure"
3. **Numerical Methods**: Press et al., "Numerical Recipes"

---

## License

[MIT](LICENSE)

¬© 2025 Hiroki Tsusaka. All rights reserved.

---

## Contact

- **GitHub Issues**: [Repository](https://github.com/1160-hrk/rovibrational-excitation)
- **Email**: Please check the project page

---

*Last updated: January 2025*
