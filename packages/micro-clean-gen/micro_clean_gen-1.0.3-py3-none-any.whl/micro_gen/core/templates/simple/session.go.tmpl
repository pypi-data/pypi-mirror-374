package session

import (
	"context"
	"errors"
	"sync"
	"time"
)

// Session 简洁的会话结构
type Session struct {
	ID     string                 `json:"id"`
	Data   map[string]interface{} `json:"data"`
	Expiry time.Time              `json:"expiry"`
}

// NewSession 创建新会话
func NewSession(id string, ttl time.Duration) *Session {
	return &Session{
		ID:     id,
		Data:   make(map[string]interface{}),
		Expiry: time.Now().Add(ttl),
	}
}

// IsExpired 检查是否过期
func (s *Session) IsExpired() bool {
	return time.Now().After(s.Expiry)
}

// Store 会话存储接口
type Store interface {
	Get(ctx context.Context, id string) (*Session, error)
	Set(ctx context.Context, session *Session) error
	Delete(ctx context.Context, id string) error
}

// Manager 会话管理器
type Manager struct {
	store Store
	ttl   time.Duration
}

func NewManager(store Store, ttl time.Duration) *Manager {
	return &Manager{store: store, ttl: ttl}
}

func (m *Manager) Create(ctx context.Context, id string) (*Session, error) {
	session := NewSession(id, m.ttl)
	return session, m.store.Set(ctx, session)
}

func (m *Manager) Get(ctx context.Context, id string) (*Session, error) {
	session, err := m.store.Get(ctx, id)
	if err != nil {
		return nil, err
	}
	if time.Now().After(session.Expiry) {
		m.store.Delete(ctx, id)
		return nil, errors.New("session expired")
	}
	return session, nil
}

func (m *Manager) Delete(ctx context.Context, id string) error {
	return m.store.Delete(ctx, id)
}

// MemoryStore 内存存储
type MemoryStore struct {
	data map[string]*Session
	mu   sync.RWMutex
}

func NewMemoryStore() *MemoryStore {
	return &MemoryStore{
		data: make(map[string]*Session),
	}
}

func (m *MemoryStore) Get(ctx context.Context, id string) (*Session, error) {
	m.mu.RLock()
	defer m.mu.RUnlock()
	
	session, ok := m.data[id]
	if !ok {
		return nil, errors.New("session not found")
	}
	return session, nil
}

func (m *MemoryStore) Set(ctx context.Context, session *Session) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	
	m.data[session.ID] = session
	return nil
}

func (m *MemoryStore) Delete(ctx context.Context, id string) error {
	m.mu.Lock()
	defer m.mu.Unlock()
	
	delete(m.data, id)
	return nil
}