{"title":"Aligner","markdown":{"headingText":"Aligner","headingAttr":{"id":"brdr.aligner.Aligner","classes":[],"keyvalue":[]},"containsRefs":false,"markdown":"\n```python\naligner.Aligner(\n    feedback=None,\n    relevant_distance=1,\n    relevant_distances=[(round(k, RELEVANT_DISTANCE_DECIMALS)) for k in (np.arange(0, 310, 10, dtype=int) / 100)],\n    threshold_overlap_percentage=50,\n    od_strategy=OpenDomainStrategy.SNAP_ALL_SIDE,\n    crs=DEFAULT_CRS,\n    multi_as_single_modus=True,\n    preserve_topology=False,\n    snap_strategy=SNAP_STRATEGY,\n    snap_max_segment_length=SNAP_MAX_SEGMENT_LENGTH,\n    partial_snapping=PARTIAL_SNAPPING,\n    partial_snap_strategy=PARTIAL_SNAP_STRATEGY,\n    partial_snap_max_segment_length=PARTIAL_SNAP_MAX_SEGMENT_LENGTH,\n    threshold_exclusion_area=0,\n    threshold_exclusion_percentage=0,\n    threshold_inclusion_percentage=100,\n    buffer_multiplication_factor=BUFFER_MULTIPLICATION_FACTOR,\n    threshold_circle_ratio=0.98,\n    correction_distance=0.01,\n    diff_metric=DIFF_METRIC,\n    mitre_limit=10,\n    area_limit=None,\n    max_workers=None,\n)\n```\n\nThis class is used to compare and align the thematic data with the reference data.\nThe reference data can be loaded in different ways, for example by using the GRB\ndata.\nThe thematic data can be loaded by using different Loaders: DictLoader, GeojsonLoader,...\nThe class can be used to compare and aligne the thematic data with the reference data.\n\n## Methods\n\n| Name | Description |\n| --- | --- |\n| [evaluate](#brdr.aligner.Aligner.evaluate) | Compares and evaluate input-geometries (with formula). Attributes are added to evaluate and decide if new |\n| [get_brdr_formula](#brdr.aligner.Aligner.get_brdr_formula) | Calculates formula-related information based on the input geometry. |\n| [get_diff_metrics](#brdr.aligner.Aligner.get_diff_metrics) | Calculates a dictionary containing difference metrics for thematic elements based on a distance series. |\n| [get_input_as_geojson](#brdr.aligner.Aligner.get_input_as_geojson) | get a geojson of the input polygons (thematic or reference-polygons) |\n| [get_results_as_geojson](#brdr.aligner.Aligner.get_results_as_geojson) | get a geojson of a dictionary containing the resulting geometries for all |\n| [get_thematic_union](#brdr.aligner.Aligner.get_thematic_union) | returns a unary_unioned geometry from all the thematic geometries |\n| [load_reference_data](#brdr.aligner.Aligner.load_reference_data) | Loads the reference features into the aligner, and prepares the reference-data for processing |\n| [load_thematic_data](#brdr.aligner.Aligner.load_thematic_data) | Loads the thematic features into the aligner |\n| [predictor](#brdr.aligner.Aligner.predictor) | Predicts the 'most interesting' relevant distances for changes in thematic |\n| [process](#brdr.aligner.Aligner.process) | Calculates the resulting dictionaries for thematic data based on a series of |\n| [process_geometry](#brdr.aligner.Aligner.process_geometry) | method to align a geometry to the reference layer |\n| [save_results](#brdr.aligner.Aligner.save_results) | Exports analysis results (as geojson) to path. |\n\n### evaluate { #brdr.aligner.Aligner.evaluate }\n\n```python\naligner.Aligner.evaluate(\n    ids_to_evaluate=None,\n    base_formula_field=FORMULA_FIELD_NAME,\n    relevant_distances=[(round(k, RELEVANT_DISTANCE_DECIMALS)) for k in (np.arange(0, 310, 10, dtype=int) / 100)],\n    full_strategy=FullStrategy.NO_FULL,\n    max_predictions=-1,\n    multi_to_best_prediction=True,\n)\n```\n\nCompares and evaluate input-geometries (with formula). Attributes are added to evaluate and decide if new\nproposals can be used\nids_to_evaluate: list with all IDs to evaluate. all other IDs will be unchanged. If None (default), all self.dict_thematic will be evaluated.\nbase_formula_field: name of the field where the base_formula is found in the data\nmax_predictions: integer that indicates how many predictions are maximally returned. (-1 indicates all predictions are returned)\nrelevant_distances: relevant distances to evaluate\nfull_strategy: enum, decided which predictions are kept or prefered based on full-ness of the prediction\nmulti_to_best_prediction (default True): Only usable in combination with max_predictions=1. If True (and max_predictions=1), the prediction with highest score will be taken.If False, the original geometry is returned.\n\n### get_brdr_formula { #brdr.aligner.Aligner.get_brdr_formula }\n\n```python\naligner.Aligner.get_brdr_formula(geometry, with_geom=False)\n```\n\nCalculates formula-related information based on the input geometry.\n\nArgs:\n    geometry (shapely.geometry object): The input geometry.\n    with_geom (bool, optional): Whether to include geometry information in the\n        output. Defaults to False.\n\nReturns:\n    dict: A dictionary containing formula-related data:\n\n    - \"alignment_date\": datetime.now().strftime(DATE_FORMAT),\n    - \"brdr_version\": str(__version__),\n    - \"reference_source\": self.dict_reference_source,\n    - \"full\": True if the geometry exists out of all full reference-polygons, else False.\n    - \"area\": Area of the geometry.\n    - \"reference_features\": {\n        array of all the reference features the geometry is composed of:\n            -   'full': True if the intersection is the same as the reference\n                geometry, else False.\n            -   'area': Area of the intersection or reference geometry.\n            -   'percentage': Percentage of intersection area relative to the\n                reference geometry.\n            -   'geometry': GeoJSON representation of the intersection (if\n                with_geom is True).},\n    - \"reference_od\": Discription of the OD-part of the geometry (= not covered by reference-features),\n\n### get_diff_metrics { #brdr.aligner.Aligner.get_diff_metrics }\n\n```python\naligner.Aligner.get_diff_metrics(\n    dict_processresults=None,\n    dict_thematic=None,\n    diff_metric=DiffMetric.CHANGES_AREA,\n)\n```\n\nCalculates a dictionary containing difference metrics for thematic elements based on a distance series.\n\nParameters:\ndict_series (dict): A dictionary where keys are thematic IDs and values are dictionaries mapping relative distances to ProcessResult objects.\ndict_thematic (dict): A dictionary where keys are thematic IDs and values are BaseGeometry objects representing the original geometries.\ndiff_metric (DiffMetric, optional): The metric to use for calculating differences. Default is DiffMetric.CHANGES_AREA.\n\nReturns:\ndict: A dictionary where keys are thematic IDs and values are dictionaries mapping relative distances to calculated difference metrics.\n\n### get_input_as_geojson { #brdr.aligner.Aligner.get_input_as_geojson }\n\n```python\naligner.Aligner.get_input_as_geojson(inputtype=AlignerInputType.REFERENCE)\n```\n\nget a geojson of the input polygons (thematic or reference-polygons)\n\n### get_results_as_geojson { #brdr.aligner.Aligner.get_results_as_geojson }\n\n```python\naligner.Aligner.get_results_as_geojson(\n    resulttype=AlignerResultType.PROCESSRESULTS,\n    formula=False,\n    attributes=False,\n)\n```\n\nget a geojson of a dictionary containing the resulting geometries for all\n    'serial' relevant distances. The resulttype can be chosen.\nformula (boolean, Optional): The descriptive formula is added as an attribute to the result\nattributes (boolean, Optional): The original attributes/properties are added to the result\n\n### get_thematic_union { #brdr.aligner.Aligner.get_thematic_union }\n\n```python\naligner.Aligner.get_thematic_union()\n```\n\nreturns a unary_unioned geometry from all the thematic geometries\n:return:\n\n### load_reference_data { #brdr.aligner.Aligner.load_reference_data }\n\n```python\naligner.Aligner.load_reference_data(loader)\n```\n\nLoads the reference features into the aligner, and prepares the reference-data for processing\n:param loader:\n:return:\n\n### load_thematic_data { #brdr.aligner.Aligner.load_thematic_data }\n\n```python\naligner.Aligner.load_thematic_data(loader)\n```\n\nLoads the thematic features into the aligner\n:param loader:\n:return:\n\n### predictor { #brdr.aligner.Aligner.predictor }\n\n```python\naligner.Aligner.predictor(\n    dict_thematic=None,\n    relevant_distances=[(round(k, RELEVANT_DISTANCE_DECIMALS)) for k in (np.arange(0, 310, 10, dtype=int) / 100)],\n    od_strategy=OpenDomainStrategy.SNAP_ALL_SIDE,\n    threshold_overlap_percentage=50,\n    diff_metric=None,\n)\n```\n\nPredicts the 'most interesting' relevant distances for changes in thematic\nelements based on a distance series.\n\nThis function analyzes a set of thematic geometries (`self.dict_thematic`) to\nidentify potentially interesting distances where changes occur. It performs\nthe following steps:\n\n1. **Process Distance Series:**\n    - Calculates a series of results for different distances specified by\n      `relevant_distances`.\n    - This calculation might involve functions like `self.process_series`\n      (implementation details likely depend on your specific code).\n\n2. **Calculate Difference Metrics:**\n    - Analyzes the results from the distance series to compute difference\n      metrics between thematic elements at each distance (using\n      `diffs_from_dict_series`).\n\n3. **Identify Breakpoints and Zero-Streaks:**\n    - For each thematic geometry, it identifies potential \"breakpoints\" where\n      the difference metric changes sign (from positive to negative or vice\n      versa).\n    - It also identifies \"zero-streaks\" which are consecutive distances with a\n      difference metric close to zero (potentially indicating minimal change).\n\n4. **Predict Interesting Distances:**\n    - The function considers distances corresponding to breakpoints and\n      zero-streaks as potentially interesting for further analysis.\n    - These distances are stored in a dictionary (`dict_predictions`) with the\n      thematic element key as the outer key.\n    - Additionally, the corresponding results from the distance series for\n      those distances are included.\n\nArgs:\n    dict_thematic: the dictionary with the thematic geometries to 'predict'. Default is None, so all thematic geometries inside the aligner will be processed.\n    relevant_distances (np.ndarray, optional): A series of relevant distances\n        (in meters) to process. : A NumPy array of distances to\n      be analyzed.\n    od_strategy (int, optional): The strategy to determine how to handle\n        information outside the reference polygons (Open Domain)\n        (default: SNAP_FULL_AREA_ALL_SIDE)\n    threshold_overlap_percentage (int, optional): Threshold (%) to determine\n        from which overlapping-percentage a reference-polygon has to be included\n        when there aren't relevant intersections or relevant differences\n        (default 50%).\n        When setting this parameter to '-1' the original border for will be returned for cases where nor relevant intersections and relevant differences are found\n\n    relevant_distances (np.ndarray, optional): A NumPy array of distances to\n      be analyzed. Defaults to np.arange(0.1, 5.05, 0.1).\n    od_strategy (OpenDomainStrategy, optional): A strategy for handling\n      open data in the processing (implementation specific). Defaults to\n     OpenDomainStrategy.SNAP_ALL_SIDE.\n    threshold_overlap_percentage (int, optional): A percentage threshold for\n      considering full overlap in the processing (implementation specific).\n     Defaults to 50.\n    diff_metric (enum, optional): A enum thjat determines the method how differences are measured to determine the 'predictions'\n\nReturns:\n    dict_series: A dictionary containing the resultset for all relevant distances for each thematic element.\n    dict_predictions: A dictionary containing predicted interesting distances for each\n    thematic element.\n        - Keys: Thematic element identifiers from `self.dict_thematic`.\n        - Values: Dictionaries with the following structure for each\n           thematic element:\n            - Keys: Distances identified as interesting (breakpoints or\n            zero-streaks).\n            - Values: dicts containing results (likely specific to\n            your implementation) from the distance series for the\n            corresponding distance.\n    diffs_dict: a dictionary with the differences for each relevant distance\n\n### process { #brdr.aligner.Aligner.process }\n\n```python\naligner.Aligner.process(\n    dict_thematic=None,\n    relevant_distances=None,\n    relevant_distance=1,\n    od_strategy=OpenDomainStrategy.SNAP_ALL_SIDE,\n    threshold_overlap_percentage=50,\n)\n```\n\nCalculates the resulting dictionaries for thematic data based on a series of\n    relevant distances.\n\nArgs:\n    relevant_distances (Iterable[float]): A series of relevant distances\n        (in meters) to process\n    od_strategy (int, optional): The strategy to determine how to handle\n        information outside the reference polygons (Open Domain)\n        (default: SNAP_FULL_AREA_ALL_SIDE)\n    threshold_overlap_percentage (int, optional): Threshold (%) to determine\n        from which overlapping-percentage a reference-polygon has to be included\n        when there aren't relevant intersections or relevant differences\n        (default 50%).\n        When setting this parameter to '-1' the original border for will be returned for cases where nor relevant intersections and relevant differences are found\n\n\nReturns:\n    dict: A dictionary, for every thematic ID a dictionary with the results for all distances\n\n        {\n            'theme_id_1': {0: (ProcessResult), 0.1:\n                (ProcessResult), ...},\n            'theme_id_2': {0: (ProcessResult), 0.1:\n                (ProcessResult), ...},\n            ...\n        }\n\n### process_geometry { #brdr.aligner.Aligner.process_geometry }\n\n```python\naligner.Aligner.process_geometry(\n    input_geometry,\n    relevant_distance=1,\n    od_strategy=OpenDomainStrategy.SNAP_ALL_SIDE,\n    threshold_overlap_percentage=50,\n)\n```\n\nmethod to align a geometry to the reference layer\n\nArgs:\n    input_geometry (BaseGeometry): The input geometric object.\n    relevant_distance: The relevant distance (in meters) for processing\n    od_strategy (int, optional): The strategy to determine how to handle\n        information outside the reference polygons (Open Domain)\n        (default: SNAP_FULL_AREA_ALL_SIDE)\n    threshold_overlap_percentage (int, optional): Threshold (%) to determine\n        from which overlapping-percentage a reference-polygon has to be included\n        when there aren't relevant intersections or relevant differences\n        (default 50%).\n        When setting this parameter to '-1' the original border for will be returned for cases where nor relevant intersections and relevant differences are found\n\n\nReturns:\n    ProcessResult : A dict containing the resulting geometries:\n\n    *   result (BaseGeometry): The resulting output geometry\n    *   result_diff (BaseGeometry): The resulting difference output geometry\n    *   result_diff_plus (BaseGeometry): The resulting positive difference\n        output geometry\n    *   result_diff_min (BaseGeometry): The resulting negative difference output\n        geometry\n    *   relevant_intersection (BaseGeometry): The relevant_intersection\n    *   relevant_difference (BaseGeometry): The relevant_difference\n    *   remark (str): remarks collected when processing the geometry\n\n### save_results { #brdr.aligner.Aligner.save_results }\n\n```python\naligner.Aligner.save_results(\n    path,\n    resulttype=AlignerResultType.PROCESSRESULTS,\n    formula=True,\n)\n```\n\nExports analysis results (as geojson) to path.\n\nThis function exports 6 GeoJSON files containing the analysis results to the\nspecified `path`.\n\nArgs:\npath (str): The path to the directory where the GeoJSON files will be saved.\nformula (bool, optional): Whether to include formula-related information\n    in the output. Defaults to True.\n\nDetails of exported files:\n- result.geojson: Contains the original thematic data from `\n  self.dict_result`.\n- result_diff.geojson: Contains the difference between the original\n  and predicted data from `self.dict_result_diff`.\n- result_diff_plus.geojson: Contains results for areas that are\n  added (increased area).\n- result_diff_min.geojson: Contains results for areas that are\n  removed (decreased area).\n- result_relevant_intersection.geojson: Contains the areas with\n  relevant intersection that has to be included in the result.\n- result_relevant_difference.geojson: Contains the areas with\n  relevant difference that has to be excluded from the result.","srcMarkdownNoYaml":""},"formats":{"html":{"identifier":{"display-name":"HTML","target-format":"html","base-format":"html"},"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"ipynb-shell-interactivity":null,"plotly-connected":true,"engine":"markdown"},"render":{"keep-tex":false,"keep-typ":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"inline-includes":false,"preserve-yaml":false,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-min-runs":1,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[],"notebook-links":true},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","toc":true,"css":["../reference/_styles-quartodoc.css"],"output-file":"Aligner.html"},"language":{"toc-title-document":"Table of contents","toc-title-website":"On this page","related-formats-title":"Other Formats","related-notebooks-title":"Notebooks","source-notebooks-prefix":"Source","other-links-title":"Other Links","code-links-title":"Code Links","launch-dev-container-title":"Launch Dev Container","launch-binder-title":"Launch Binder","article-notebook-label":"Article Notebook","notebook-preview-download":"Download Notebook","notebook-preview-download-src":"Download Source","notebook-preview-back":"Back to Article","manuscript-meca-bundle":"MECA Bundle","section-title-abstract":"Abstract","section-title-appendices":"Appendices","section-title-footnotes":"Footnotes","section-title-references":"References","section-title-reuse":"Reuse","section-title-copyright":"Copyright","section-title-citation":"Citation","appendix-attribution-cite-as":"For attribution, please cite this work as:","appendix-attribution-bibtex":"BibTeX citation:","appendix-view-license":"View License","title-block-author-single":"Author","title-block-author-plural":"Authors","title-block-affiliation-single":"Affiliation","title-block-affiliation-plural":"Affiliations","title-block-published":"Published","title-block-modified":"Modified","title-block-keywords":"Keywords","callout-tip-title":"Tip","callout-note-title":"Note","callout-warning-title":"Warning","callout-important-title":"Important","callout-caution-title":"Caution","code-summary":"Code","code-tools-menu-caption":"Code","code-tools-show-all-code":"Show All Code","code-tools-hide-all-code":"Hide All Code","code-tools-view-source":"View Source","code-tools-source-code":"Source Code","tools-share":"Share","tools-download":"Download","code-line":"Line","code-lines":"Lines","copy-button-tooltip":"Copy to Clipboard","copy-button-tooltip-success":"Copied!","repo-action-links-edit":"Edit this page","repo-action-links-source":"View source","repo-action-links-issue":"Report an issue","back-to-top":"Back to top","search-no-results-text":"No results","search-matching-documents-text":"matching documents","search-copy-link-title":"Copy link to search","search-hide-matches-text":"Hide additional matches","search-more-match-text":"more match in this document","search-more-matches-text":"more matches in this document","search-clear-button-title":"Clear","search-text-placeholder":"","search-detached-cancel-button-title":"Cancel","search-submit-button-title":"Submit","search-label":"Search","toggle-section":"Toggle section","toggle-sidebar":"Toggle sidebar navigation","toggle-dark-mode":"Toggle dark mode","toggle-reader-mode":"Toggle reader mode","toggle-navigation":"Toggle navigation","crossref-fig-title":"Figure","crossref-tbl-title":"Table","crossref-lst-title":"Listing","crossref-thm-title":"Theorem","crossref-lem-title":"Lemma","crossref-cor-title":"Corollary","crossref-prp-title":"Proposition","crossref-cnj-title":"Conjecture","crossref-def-title":"Definition","crossref-exm-title":"Example","crossref-exr-title":"Exercise","crossref-ch-prefix":"Chapter","crossref-apx-prefix":"Appendix","crossref-sec-prefix":"Section","crossref-eq-prefix":"Equation","crossref-lof-title":"List of Figures","crossref-lot-title":"List of Tables","crossref-lol-title":"List of Listings","environment-proof-title":"Proof","environment-remark-title":"Remark","environment-solution-title":"Solution","listing-page-order-by":"Order By","listing-page-order-by-default":"Default","listing-page-order-by-date-asc":"Oldest","listing-page-order-by-date-desc":"Newest","listing-page-order-by-number-desc":"High to Low","listing-page-order-by-number-asc":"Low to High","listing-page-field-date":"Date","listing-page-field-title":"Title","listing-page-field-description":"Description","listing-page-field-author":"Author","listing-page-field-filename":"File Name","listing-page-field-filemodified":"Modified","listing-page-field-subtitle":"Subtitle","listing-page-field-readingtime":"Reading Time","listing-page-field-wordcount":"Word Count","listing-page-field-categories":"Categories","listing-page-minutes-compact":"{0} min","listing-page-category-all":"All","listing-page-no-matches":"No matching items","listing-page-words":"{0} words","listing-page-filter":"Filter","draft":"Draft"},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.7.31","quartodoc":{"package":"brdr","sidebar":"../reference/_sidebar.yml","css":"../reference/_styles-quartodoc.css","sections":[{"title":"Aligner","package":"brdr.aligner","desc":"Aligner class of the brdr package.","contents":["Aligner"]},{"title":"Loaders","package":"brdr.loader","desc":"Loaders to load data","contents":["Loader","DictLoader","GeoJsonLoader","GeoJsonFileLoader","GeoJsonUrlLoader"]},{"title":"GRB","package":"brdr.grb","desc":"GRB specific loaders - grb.GRBActualLoader - grb.GRBFiscalParcelLoader - grb.GRBSpecificDateParcelLoader"}]},"theme":"cosmo"},"extensions":{"book":{"multiFile":true}}}},"projectFormats":["html"]}