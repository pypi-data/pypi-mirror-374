import json
import logging
import re
import urllib.request
from pathlib import Path
from textwrap import dedent, indent

log = logging.getLogger()

REGISTER_AS_MCP_TOOLS = False

ROOT_DIR = Path(__file__).parent.parent
GENERATED_TOOLS_DIR = ROOT_DIR / "src" / "tapir_archicad_mcp" / "tools" / "generated"

COMMAND_DETAILS_URL = "https://raw.githubusercontent.com/SzamosiMate/multiconn_archicad/main/code_generation/tapir/schema/_command_details.json"
COMMAND_MODEL_NAMES_URL = "https://raw.githubusercontent.com/SzamosiMate/multiconn_archicad/main/code_generation/tapir/schema/_command_model_names.json"

COMMANDS_TO_EXCLUDE = {
    "GetProjectInfo", "GetArchicadLocation", "QuitArchicad", "GenerateDocumentation",
}

PAGINATED_COMMANDS = {
    "GetAllElements": "elements",
    "GetSelectedElements": "elements",
    "GetElementsByType": "elements",
    "GetAllProperties": "properties",
    "GetAttributesByType": "attributes",
    "GetIssues": "issues"
}

FILE_HEADER = "# This file is auto-generated by generate_tools.py. DO NOT EDIT."
PAGINATED_DOCSTRING_ADDENDUM = """
    This response is paginated. If 'next_page_token' is returned, call this function
    again with that token to get the next page of results."""

GROUP_NAME_MAPPING = {
    "Application Commands": "app", "Project Commands": "project", "Element Commands": "elements",
    "Favorites Commands": "favorites", "Property Commands": "properties", "Attribute Commands": "attributes",
    "Library Commands": "library", "Navigator Commands": "navigator", "Issue Management Commands": "issues",
    "Revision Management Commands": "revisions", "Teamwork Commands": "teamwork", "Developer Commands": "dev",
}


def camel_to_snake(name: str) -> str:
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    return re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1).lower()


def get_command_model_names(command_name: str) -> tuple[str, str]:
    return f"{command_name}Parameters", f"{command_name}Result"


def fetch_json_data(url: str, description: str) -> list | dict:
    log.info(f"Fetching {description} from {url}...")
    try:
        with urllib.request.urlopen(url) as response:
            if response.status == 200:
                log.info(f"Successfully fetched {description}.")
                return json.loads(response.read().decode("utf-8"))
            raise ConnectionError(f"Failed to fetch file: HTTP {response.status}")
    except urllib.request.HTTPError as e:
        log.error(f"Failed to fetch {description}: {e}")
        return []


def group_commands_by_category(command_details: list[dict]) -> dict[str, list[dict]]:
    grouped = {}
    for cmd in command_details:
        group_key = cmd["group"].replace(" ", "_").lower()
        grouped.setdefault(group_key, []).append(cmd)
    log.info(f"Grouped {len(command_details)} commands into {len(grouped)} categories.")
    return grouped


def prepare_output_directory(path: Path):
    if path.exists():
        log.warning(f"Output directory {path} exists. Cleaning...")
        for f in path.glob("*.py"):
            f.unlink()
    else:
        path.mkdir(parents=True)
    log.info(f"Prepared generation directory: {path}")


def _generate_imports_for_group(commands: list[dict], valid_model_names: set[str]) -> str:
    imports = set()
    for cmd in commands:
        p_model, r_model = get_command_model_names(cmd["name"])
        if p_model in valid_model_names:
            imports.add(p_model)
        if r_model in valid_model_names:
            imports.add(r_model)
    if not imports:
        return ""
    import_statements = ",\n".join(f"    {imp}" for imp in sorted(list(imports)))
    return dedent(f"""
    from multiconn_archicad.models.tapir.commands import (
    {import_statements}
    )
    """)


def _generate_paginated_model_code(original_result_model: str, paginated_result_model: str,
                                   list_attribute_name: str) -> str:
    return dedent(f'''
class {paginated_result_model}({original_result_model}):
    """A paginated version of the {original_result_model}."""
    {list_attribute_name}: list[Any]
    next_page_token: str | None = None
''')


def _generate_standard_call_block(command_name_camel: str, result_model: str, has_params: bool,
                                  has_result: bool) -> str:
    params_for_api_call = "params.model_dump(mode='json')" if has_params else "{}"
    if has_result:
        return dedent(f'''
            result_dict = conn_header.core.post_tapir_command(
                command="{command_name_camel}",
                parameters={params_for_api_call}
            )
            return {result_model}.model_validate(result_dict)
        ''')
    else:
        return dedent(f'''
            conn_header.core.post_tapir_command(
                command="{command_name_camel}",
                parameters={params_for_api_call}
            )
            return None
        ''')


def _generate_paginated_call_block(command_name_camel: str, original_result_model: str, paginated_result_model: str,
                                   list_attribute_name: str, has_params: bool) -> str:
    params_for_api_call = "params.model_dump(mode='json')" if has_params else "{}"
    cache_key_params_part = f':{{params.model_dump_json()}}' if has_params else ''

    return dedent(f'''
        cache_key = f"{{port}}:{command_name_camel}{cache_key_params_part}"

        if not page_token:
            full_response_dict = conn_header.core.post_tapir_command(
                command="{command_name_camel}",
                parameters={params_for_api_call}
            )
            full_response_model = {original_result_model}.model_validate(full_response_dict)
            PAGINATION_CACHE[cache_key] = (full_response_model, time.time())

        if cache_key not in PAGINATION_CACHE:
            raise ValueError("Pagination session expired or invalid. Please start a new request.")

        full_response_model, timestamp = PAGINATION_CACHE[cache_key]
        if time.time() - timestamp > CACHE_LIFETIME_SECONDS:
            del PAGINATION_CACHE[cache_key]
            raise ValueError("Pagination session expired. Please start a new request.")

        list_to_paginate = getattr(full_response_model, "{list_attribute_name}")
        paginated_result = handle_paginated_request(list_to_paginate, page_token)

        response_data = full_response_model.model_dump()
        response_data["{list_attribute_name}"] = paginated_result.items
        response_data["next_page_token"] = paginated_result.next_page_token

        return {paginated_result_model}.model_validate(response_data)
    ''')


def _generate_tool_function_code(command: dict, valid_model_names: set[str]) -> str:
    command_name_camel = command["name"]
    command_name_snake = camel_to_snake(command_name_camel)
    short_group_name = GROUP_NAME_MAPPING.get(command["group"], "dev")
    tool_name = f"{short_group_name}_{command_name_snake}"

    params_model, result_model = get_command_model_names(command_name_camel)
    has_params = params_model in valid_model_names
    has_result = result_model in valid_model_names
    is_paginated = command_name_camel in PAGINATED_COMMANDS

    param_signature = f", params: {params_model}" if has_params else ""

    docstring_addendum = ""
    model_code = ""

    if is_paginated:
        list_attribute_name = PAGINATED_COMMANDS[command_name_camel]
        paginated_result_model = f"Paginated{result_model}"
        param_signature += ", page_token: str | None = None"
        return_annotation = paginated_result_model
        docstring_addendum = PAGINATED_DOCSTRING_ADDENDUM
        model_code = _generate_paginated_model_code(result_model, paginated_result_model, list_attribute_name)
        call_block = _generate_paginated_call_block(command_name_camel, result_model,
                                                    paginated_result_model, list_attribute_name, has_params)
        param_reg_arg = params_model if has_params else "None"
        result_reg_arg = paginated_result_model
    else:
        return_annotation = result_model if has_result else "None"
        call_block = _generate_standard_call_block(command_name_camel, result_model, has_params, has_result)
        param_reg_arg = params_model if has_params else "None"
        result_reg_arg = result_model if has_result else "None"

    docstring = f'''"""\n{command["description"]}{docstring_addendum}\n"""'''

    decorator = ""
    if REGISTER_AS_MCP_TOOLS:
        decorator = dedent(f'''
        @mcp.tool(
            name="{tool_name}",
            title="{command_name_camel}",
            description="{command["description"]}"
        )
        ''')

    function_code = f'''{decorator}def {command_name_snake}(port: int{param_signature}) -> {return_annotation}:
{indent(docstring, "    ")}
    multi_conn = multi_conn_instance.get()
    target_port = Port(port)
    if target_port not in multi_conn.active:
        raise ValueError(f"Port {{port}} is not an active Archicad connection.")
    conn_header = multi_conn.active[target_port]
    try:
{indent(call_block, "        ")}
    except ValidationError as e:
        log.error(f"Validation error for {command_name_camel} result: {{e}}")
        raise ValueError(f"Received an invalid response from the Archicad API: {{e}}")
    except Exception as e:
        log.error(f"Error executing {command_name_camel} on port {{port}}: {{e}}")
        raise e
'''

    registration_call = dedent(f"""
    register_tool_for_dispatch(
        {command_name_snake},
        name="{tool_name}",
        title="{command_name_camel}",
        description="{command["description"]}",
        params_model={param_reg_arg},
        result_model={result_reg_arg}
    )
    """)

    full_code = f"{model_code}\n\n{function_code}\n{registration_call}"
    return full_code.strip() + "\n"


def generate_tool_files(grouped_commands: dict[str, list[dict]], out_dir: Path, valid_model_names: set[str]):
    for group_name, commands in grouped_commands.items():
        file_path = out_dir / f"{group_name}.py"

        is_any_paginated = any(cmd["name"] in PAGINATED_COMMANDS for cmd in commands)

        imports_block = _generate_imports_for_group(commands, valid_model_names)

        common_imports = [
            FILE_HEADER,
            "import logging",
            "from pydantic import ValidationError",
            "from multiconn_archicad.basic_types import Port",
            "from tapir_archicad_mcp.context import multi_conn_instance",
            "from tapir_archicad_mcp.tools.tool_registry import register_tool_for_dispatch",
        ]
        if is_any_paginated:
            common_imports.extend([
                "import time",
                "from typing import Any",
                "from tapir_archicad_mcp.pagination import handle_paginated_request, PAGINATION_CACHE, CACHE_LIFETIME_SECONDS",
            ])
        if imports_block:
            common_imports.append(imports_block)

        if REGISTER_AS_MCP_TOOLS:
            common_imports.extend([
                "from tapir_archicad_mcp.app import mcp",
            ])

        common_imports.append("\nlog = logging.getLogger()")

        file_content = ["\n".join(common_imports)]
        for cmd in commands:
            file_content.append(_generate_tool_function_code(cmd, valid_model_names))

        with open(file_path, "w", encoding="utf-8") as f:
            f.write("\n\n".join(file_content))
        log.info(f"Generated tool file: {file_path}")


def generate_init_file(grouped_commands: dict[str, list[dict]], out_dir: Path):
    init_path = out_dir / "__init__.py"
    content = [
        FILE_HEADER,
        "# This file makes the 'generated' directory a package and allows for easy importing.", ""
    ]
    for group_name in sorted(grouped_commands.keys()):
        content.append(f"from .{group_name} import *")
    with open(init_path, "w", encoding="utf-8") as f:
        f.write("\n".join(content))
    log.info(f"Generated __init__.py file at {init_path}")


def main():
    """Main execution function to run the entire generation process."""
    log.info("--- Starting Archicad MCP Tool Generator ---")

    command_details_all = fetch_json_data(COMMAND_DETAILS_URL, "command details")
    valid_model_names_list = fetch_json_data(COMMAND_MODEL_NAMES_URL, "valid model names")

    if not command_details_all or not valid_model_names_list:
        log.critical("Could not fetch necessary data. Aborting generation.")
        return

    log.info(f"Excluding {len(COMMANDS_TO_EXCLUDE)} commands from generation.")
    command_details_filtered = [
        cmd for cmd in command_details_all if cmd["name"] not in COMMANDS_TO_EXCLUDE
    ]
    log.info(f"Generating tools for {len(command_details_filtered)} commands.")

    valid_model_names = set(valid_model_names_list)
    grouped_commands = group_commands_by_category(command_details_filtered)

    prepare_output_directory(GENERATED_TOOLS_DIR)
    generate_tool_files(grouped_commands, GENERATED_TOOLS_DIR, valid_model_names)
    generate_init_file(grouped_commands, GENERATED_TOOLS_DIR)

    log.info("--- Tool Generation Completed Successfully ---")


if __name__ == "__main__":
    logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
    main()