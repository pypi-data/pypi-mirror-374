# 自动生成指定包目录下的 __init__.py（懒加载格式：lazy_loader.attach）

import ast
from pathlib import Path
from typing import Dict, List, Set


def _extract_exports_from_module(py_file: Path) -> List[str]:
    """
    优先读取模块内显式定义的 __all__，否则收集顶层的类与函数名（排除以下划线开头的）。
    """
    try:
        source = py_file.read_text(encoding='utf-8')
    except UnicodeDecodeError:
        source = py_file.read_text(errors='ignore')

    try:
        tree = ast.parse(source, filename=str(py_file))
    except SyntaxError:
        return []

    # 1) 如果定义了 __all__ 则优先使用
    for node in tree.body:
        if isinstance(node, ast.Assign):
            for target in node.targets:
                if isinstance(target, ast.Name) and target.id == '__all__':
                    values: List[str] = []
                    if isinstance(node.value, (ast.List, ast.Tuple)):
                        for elt in node.value.elts:
                            if isinstance(elt, ast.Str):  # py<3.8
                                values.append(elt.s)
                            elif isinstance(elt, ast.Constant) and isinstance(elt.value, str):
                                values.append(elt.value)
                    return [name for name in values if name and not name.startswith('_')]

    # 2) 否则收集顶层函数与类名
    exports: Set[str] = set()
    for node in tree.body:
        if isinstance(node, (ast.FunctionDef, ast.AsyncFunctionDef, ast.ClassDef)):
            name = node.name
            if not name.startswith('_'):
                exports.add(name)
    return sorted(exports)


def generate_init_for_directory(package_dir: Path) -> Path:
    """
    为指定目录生成懒加载版 __init__.py（覆盖写入）。
    - 仅扫描一级子模块（同级 .py 文件），忽略以下划线开头的模块与 __init__.py 本身。
    - 生成结构：
        from lazy_loader import attach

        __getattr__, __dir__, __all__ = attach(
            __name__,
            submodules=["m1", "m2", ...],
            submod_attrs={"m1": ["A", "B"], ...}
        )
    """
    package_dir = package_dir.resolve()
    if not package_dir.is_dir():
        raise ValueError(f"目标不是目录: {package_dir}")

    module_to_exports: Dict[str, List[str]] = {}
    module_names: List[str] = []
    for py_file in sorted(package_dir.glob('*.py')):
        if py_file.name == '__init__.py':
            continue
        if py_file.name.startswith('_'):
            continue
        module_name = py_file.stem
        module_names.append(module_name)
        exports = _extract_exports_from_module(py_file)
        if exports:
            module_to_exports[module_name] = exports

    lines: List[str] = []
    lines.append('# This file is auto-generated. Do NOT edit manually.')
    lines.append('# Generated by neverlib.QA.gen_init')
    lines.append('from lazy_loader import attach')
    lines.append('')
    lines.append('__getattr__, __dir__, __all__ = attach(')
    lines.append('    __name__,')
    lines.append('    submodules=[')
    for name in sorted(module_names):
        lines.append(f'        "{name}",')
    lines.append('    ],')
    lines.append('    submod_attrs={')
    for module_name in sorted(module_to_exports.keys()):
        exports_sorted = sorted(module_to_exports[module_name])
        joined = ', '.join([f"'{e}'" for e in exports_sorted])
        lines.append(f'        "{module_name}": [{joined}],')
    lines.append('    }')
    lines.append(')')
    lines.append('')

    init_file = package_dir / '__init__.py'
    init_file.write_text('\n'.join(lines), encoding='utf-8')
    return init_file


def main():
    import argparse

    parser = argparse.ArgumentParser(description='为指定包目录自动生成 __init__.py')
    parser.add_argument('-p', '--package-dir', dest='package_dir',
                        default='../../neverlib/vad',
                        help='包目录路径，比如 /path/to/pkg 或 ./neverlib/utils')
    args = parser.parse_args()

    target_dir = Path(args.package_dir)
    init_path = generate_init_for_directory(target_dir)
    print(f'已生成: {init_path}')
# python -m neverlib.QA.gen_init /data03/never/Desktop/neverlib/neverlib/utils


if __name__ == '__main__':
    main()
