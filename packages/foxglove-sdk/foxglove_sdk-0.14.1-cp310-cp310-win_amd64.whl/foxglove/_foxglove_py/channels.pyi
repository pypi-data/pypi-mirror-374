# Generated by https://github.com/foxglove/foxglove-sdk
from typing import Dict, Optional

from . import Context, Schema
from .schemas import (
    ArrowPrimitive,
    CameraCalibration,
    CircleAnnotation,
    Color,
    CompressedImage,
    CompressedVideo,
    CubePrimitive,
    CylinderPrimitive,
    FrameTransform,
    FrameTransforms,
    GeoJson,
    Grid,
    ImageAnnotations,
    KeyValuePair,
    LaserScan,
    LinePrimitive,
    LocationFix,
    LocationFixes,
    Log,
    ModelPrimitive,
    PackedElementField,
    Point2,
    Point3,
    PointCloud,
    PointsAnnotation,
    Pose,
    PoseInFrame,
    PosesInFrame,
    Quaternion,
    RawAudio,
    RawImage,
    SceneEntity,
    SceneEntityDeletion,
    SceneUpdate,
    SpherePrimitive,
    TextAnnotation,
    TextPrimitive,
    TriangleListPrimitive,
    Vector2,
    Vector3,
    VoxelGrid,
)

class ArrowPrimitiveChannel:
    """
    A channel for logging ArrowPrimitive messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "ArrowPrimitiveChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "ArrowPrimitive",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove ArrowPrimitive message on the channel."""
        ...

class CameraCalibrationChannel:
    """
    A channel for logging CameraCalibration messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "CameraCalibrationChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "CameraCalibration",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove CameraCalibration message on the channel."""
        ...

class CircleAnnotationChannel:
    """
    A channel for logging CircleAnnotation messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "CircleAnnotationChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "CircleAnnotation",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove CircleAnnotation message on the channel."""
        ...

class ColorChannel:
    """
    A channel for logging Color messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "ColorChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "Color",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove Color message on the channel."""
        ...

class CompressedImageChannel:
    """
    A channel for logging CompressedImage messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "CompressedImageChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "CompressedImage",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove CompressedImage message on the channel."""
        ...

class CompressedVideoChannel:
    """
    A channel for logging CompressedVideo messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "CompressedVideoChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "CompressedVideo",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove CompressedVideo message on the channel."""
        ...

class CubePrimitiveChannel:
    """
    A channel for logging CubePrimitive messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "CubePrimitiveChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "CubePrimitive",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove CubePrimitive message on the channel."""
        ...

class CylinderPrimitiveChannel:
    """
    A channel for logging CylinderPrimitive messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "CylinderPrimitiveChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "CylinderPrimitive",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove CylinderPrimitive message on the channel."""
        ...

class FrameTransformChannel:
    """
    A channel for logging FrameTransform messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "FrameTransformChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "FrameTransform",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove FrameTransform message on the channel."""
        ...

class FrameTransformsChannel:
    """
    A channel for logging FrameTransforms messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "FrameTransformsChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "FrameTransforms",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove FrameTransforms message on the channel."""
        ...

class GeoJsonChannel:
    """
    A channel for logging GeoJson messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "GeoJsonChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "GeoJson",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove GeoJson message on the channel."""
        ...

class GridChannel:
    """
    A channel for logging Grid messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "GridChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "Grid",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove Grid message on the channel."""
        ...

class ImageAnnotationsChannel:
    """
    A channel for logging ImageAnnotations messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "ImageAnnotationsChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "ImageAnnotations",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove ImageAnnotations message on the channel."""
        ...

class KeyValuePairChannel:
    """
    A channel for logging KeyValuePair messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "KeyValuePairChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "KeyValuePair",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove KeyValuePair message on the channel."""
        ...

class LaserScanChannel:
    """
    A channel for logging LaserScan messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "LaserScanChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "LaserScan",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove LaserScan message on the channel."""
        ...

class LinePrimitiveChannel:
    """
    A channel for logging LinePrimitive messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "LinePrimitiveChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "LinePrimitive",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove LinePrimitive message on the channel."""
        ...

class LocationFixChannel:
    """
    A channel for logging LocationFix messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "LocationFixChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "LocationFix",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove LocationFix message on the channel."""
        ...

class LocationFixesChannel:
    """
    A channel for logging LocationFixes messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "LocationFixesChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "LocationFixes",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove LocationFixes message on the channel."""
        ...

class LogChannel:
    """
    A channel for logging Log messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "LogChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "Log",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove Log message on the channel."""
        ...

class ModelPrimitiveChannel:
    """
    A channel for logging ModelPrimitive messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "ModelPrimitiveChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "ModelPrimitive",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove ModelPrimitive message on the channel."""
        ...

class PackedElementFieldChannel:
    """
    A channel for logging PackedElementField messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "PackedElementFieldChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "PackedElementField",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove PackedElementField message on the channel."""
        ...

class Point2Channel:
    """
    A channel for logging Point2 messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "Point2Channel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "Point2",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove Point2 message on the channel."""
        ...

class Point3Channel:
    """
    A channel for logging Point3 messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "Point3Channel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "Point3",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove Point3 message on the channel."""
        ...

class PointCloudChannel:
    """
    A channel for logging PointCloud messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "PointCloudChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "PointCloud",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove PointCloud message on the channel."""
        ...

class PointsAnnotationChannel:
    """
    A channel for logging PointsAnnotation messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "PointsAnnotationChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "PointsAnnotation",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove PointsAnnotation message on the channel."""
        ...

class PoseChannel:
    """
    A channel for logging Pose messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "PoseChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "Pose",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove Pose message on the channel."""
        ...

class PoseInFrameChannel:
    """
    A channel for logging PoseInFrame messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "PoseInFrameChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "PoseInFrame",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove PoseInFrame message on the channel."""
        ...

class PosesInFrameChannel:
    """
    A channel for logging PosesInFrame messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "PosesInFrameChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "PosesInFrame",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove PosesInFrame message on the channel."""
        ...

class QuaternionChannel:
    """
    A channel for logging Quaternion messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "QuaternionChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "Quaternion",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove Quaternion message on the channel."""
        ...

class RawAudioChannel:
    """
    A channel for logging RawAudio messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "RawAudioChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "RawAudio",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove RawAudio message on the channel."""
        ...

class RawImageChannel:
    """
    A channel for logging RawImage messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "RawImageChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "RawImage",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove RawImage message on the channel."""
        ...

class SceneEntityChannel:
    """
    A channel for logging SceneEntity messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "SceneEntityChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "SceneEntity",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove SceneEntity message on the channel."""
        ...

class SceneEntityDeletionChannel:
    """
    A channel for logging SceneEntityDeletion messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "SceneEntityDeletionChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "SceneEntityDeletion",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove SceneEntityDeletion message on the channel."""
        ...

class SceneUpdateChannel:
    """
    A channel for logging SceneUpdate messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "SceneUpdateChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "SceneUpdate",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove SceneUpdate message on the channel."""
        ...

class SpherePrimitiveChannel:
    """
    A channel for logging SpherePrimitive messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "SpherePrimitiveChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "SpherePrimitive",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove SpherePrimitive message on the channel."""
        ...

class TextAnnotationChannel:
    """
    A channel for logging TextAnnotation messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "TextAnnotationChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "TextAnnotation",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove TextAnnotation message on the channel."""
        ...

class TextPrimitiveChannel:
    """
    A channel for logging TextPrimitive messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "TextPrimitiveChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "TextPrimitive",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove TextPrimitive message on the channel."""
        ...

class TriangleListPrimitiveChannel:
    """
    A channel for logging TriangleListPrimitive messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "TriangleListPrimitiveChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "TriangleListPrimitive",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove TriangleListPrimitive message on the channel."""
        ...

class Vector2Channel:
    """
    A channel for logging Vector2 messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "Vector2Channel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "Vector2",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove Vector2 message on the channel."""
        ...

class Vector3Channel:
    """
    A channel for logging Vector3 messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "Vector3Channel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "Vector3",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove Vector3 message on the channel."""
        ...

class VoxelGridChannel:
    """
    A channel for logging VoxelGrid messages

    You should choose a unique topic name per channel.
    """

    def __new__(
        cls,
        topic: str,
        *,
        metadata: Optional[Dict[str, str]] = None,
        context: Optional["Context"] = None,
    ) -> "VoxelGridChannel": ...
    def id(self) -> int:
        """The unique ID of the channel."""
        ...

    def topic(self) -> str:
        """The topic name of the channel."""
        ...

    @property
    def message_encoding(self) -> str:
        """The message encoding for the channel"""
        ...

    def metadata(self) -> Dict[str, str]:
        """
        Returns a copy of the channel's metadata.

        Note that changes made to the returned dictionary will not be applied to
        the channel's metadata.
        """
        ...

    def schema(self) -> Optional[Schema]:
        """
        Returns a copy of the channel's schema.

        Note that changes made to the returned object will not be applied to
        the channel's schema.
        """
        ...

    def schema_name(self) -> Optional[str]:
        """The name of the schema for the channel."""
        ...

    def has_sinks(self) -> bool:
        """Returns true if at least one sink is subscribed to this channel"""
        ...

    def close(self) -> None:
        """Close the channel."""
        ...

    def log(
        self,
        message: "VoxelGrid",
        *,
        log_time: int | None = None,
        sink_id: int | None = None,
    ) -> None:
        """Log a Foxglove VoxelGrid message on the channel."""
        ...
