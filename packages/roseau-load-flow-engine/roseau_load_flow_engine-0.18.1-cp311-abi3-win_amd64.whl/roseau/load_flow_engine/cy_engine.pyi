import numpy as np

# Elements
class CyElement:
    def connect(self, cy_element: CyElement, connections: list[tuple[int, int]]) -> None: ...
    def connect_ports(self, ports: np.ndarray) -> None: ...
    def disconnect(self) -> None: ...
    def get_potentials(self, n: int) -> np.ndarray[tuple[int], np.dtype[np.complex128]]: ...  # tuple[int] -> vector
    def get_currents(self, n: int) -> np.ndarray[tuple[int], np.dtype[np.complex128]]: ...
    def get_port_potential(self, index: int) -> complex: ...
    def get_port_current(self, index: int) -> complex: ...

class CyBus(CyElement):
    def __init__(self, n: int, potentials: np.ndarray) -> None: ...
    def initialize_potentials(self, potentials: np.ndarray) -> None: ...

class CyBranch(CyElement):
    def connect_side(self, element: CyElement, connections: list[tuple[int, int]], beginning: bool) -> None: ...
    def get_side_potentials(
        self, n1: int, n2: int
    ) -> tuple[np.ndarray[tuple[int], np.dtype[np.complex128]], np.ndarray[tuple[int], np.dtype[np.complex128]]]: ...
    def get_side_currents(
        self, n1: int, n2: int
    ) -> tuple[np.ndarray[tuple[int], np.dtype[np.complex128]], np.ndarray[tuple[int], np.dtype[np.complex128]]]: ...

class CySimplifiedLine(CyBranch):
    def __init__(self, n: int, z_line: np.ndarray) -> None: ...
    def update_line_parameters(self, z_line: np.ndarray) -> None: ...

class CyShuntLine(CyBranch):
    def __init__(self, n: int, y_shunt: np.ndarray, z_line: np.ndarray) -> None: ...
    def update_line_parameters(self, y_shunt: np.ndarray, z_line: np.ndarray) -> None: ...

class CySwitch(CyBranch):
    def __init__(self, n: int) -> None: ...

class CyOpenSwitch(CyBranch):
    def __init__(self, n: int) -> None: ...

class CyTransformer(CyBranch):
    def update_transformer_parameters(self, z2: complex, ym: complex, k: complex) -> None: ...
    def compute_open_circuit_parameters(self, uhv: float, ulv: float, sn: float) -> tuple[float, float]: ...
    def compute_short_circuit_parameters(self, uhv: float, ulv: float, sn: float) -> tuple[float, float]: ...

class CyThreePhaseTransformer(CyTransformer):
    def __init__(
        self, n1: int, n2: int, whv: str, wlv: str, z2: complex, ym: complex, k: float, clock: int
    ) -> None: ...

class CySingleTransformer(CyTransformer):
    def __init__(self, z2: complex, ym: complex, k: complex) -> None: ...

class CyCenterTransformer(CyTransformer):
    def __init__(self, z2: complex, ym: complex, k: float) -> None: ...

class CyLoad(CyElement):
    def get_inner_currents(self, size: int) -> np.ndarray[tuple[int], np.dtype[np.complex128]]: ...

class CyPowerLoad(CyLoad):
    def __init__(self, n: int, powers: np.ndarray) -> None: ...
    def update_powers(self, powers: np.ndarray) -> None: ...

class CyDeltaPowerLoad(CyLoad):
    def __init__(self, n: int, powers: np.ndarray) -> None: ...
    def update_powers(self, powers: np.ndarray) -> None: ...

class CyAdmittanceLoad(CyLoad):
    def __init__(self, n: int, admittances: np.ndarray) -> None: ...
    def update_admittances(self, admittances: np.ndarray) -> None: ...

class CyDeltaAdmittanceLoad(CyLoad):
    def __init__(self, n: int, admittances: np.ndarray) -> None: ...
    def update_admittances(self, admittances: np.ndarray) -> None: ...

class CyCurrentLoad(CyLoad):
    def __init__(self, n: int, currents: np.ndarray) -> None: ...
    def update_currents(self, currents: np.ndarray) -> None: ...

class CyDeltaCurrentLoad(CyLoad):
    def __init__(self, n: int, currents: np.ndarray) -> None: ...
    def update_currents(self, currents: np.ndarray) -> None: ...

class CyLoadBalancer(CyLoad):
    def __init__(self, z2: complex, ym: complex, k: float) -> None: ...

class CyControl:
    def __init__(
        self, t: str, u_min: float, u_down: float, u_up: float, u_max: float, alpha: float, epsilon: float
    ) -> None: ...

class CyProjection:
    def __init__(self, t: str, alpha: float, epsilon: float) -> None: ...

class CyFlexibleParameter:
    def __init__(
        self,
        control_p: CyControl,
        control_q: CyControl,
        projection: CyProjection,
        s_max: float,
        q_min: float,
        q_max: float,
    ) -> None: ...
    def compute_power(self, x: float, s_th: complex) -> complex: ...
    def update_parameters(self, s_max: float, q_min: float, q_max: float) -> None: ...

class CyFlexibleLoad(CyLoad):
    def __init__(self, n: int, powers: np.ndarray, parameters: np.ndarray) -> None: ...
    def update_powers(self, powers: np.ndarray) -> None: ...
    def get_powers(self, n: int) -> np.ndarray[tuple[int], np.dtype[np.complex128]]: ...

class CyDeltaFlexibleLoad(CyLoad):
    def __init__(self, n: int, powers: np.ndarray, parameters: np.ndarray) -> None: ...
    def update_powers(self, powers: np.ndarray) -> None: ...
    def get_powers(self, n: int) -> np.ndarray[tuple[int], np.dtype[np.complex128]]: ...

class CyVoltageSource(CyElement):
    def __init__(self, n: int, voltages: np.ndarray) -> None: ...
    def update_voltages(self, voltages: np.ndarray) -> None: ...

class CyDeltaVoltageSource(CyElement):
    def __init__(self, n: int, voltages: np.ndarray) -> None: ...
    def update_voltages(self, voltages: np.ndarray) -> None: ...

class CyGround(CyElement):
    def __init__(self) -> None: ...

class CyPotentialRef(CyElement):
    def __init__(self) -> None: ...
    def get_current(self) -> complex: ...

class CyDeltaPotentialRef(CyElement):
    def __init__(self, n: int) -> None: ...
    def get_current(self) -> complex: ...

# Network and solver
class CyElectricalNetwork:
    def __init__(self, elements: np.ndarray, nb_elements: int) -> None: ...

class CyLicense:
    @staticmethod
    def get_hostname() -> str: ...
    @staticmethod
    def get_username() -> str: ...
    @property
    def key(self) -> str: ...
    @property
    def machine_fingerprint(self) -> str: ...
    @property
    def expiry_datetime(self) -> str: ...
    @property
    def valid(self) -> bool: ...
    @property
    def max_nb_buses(self) -> int | None: ...

class CyAbstractSolver:
    def solve_load_flow(self, max_iterations: int, tolerance: float) -> tuple[int, float]: ...
    def reset_inputs(self) -> None: ...
    def get_variables(self) -> np.ndarray[tuple[int], np.dtype[np.float64]]: ...  # tuple[int] -> array
    def set_variables(self, variables: np.ndarray[tuple[int], np.dtype[np.float64]]) -> None: ...  # tuple[int] -> array

class CyAbstractNewton(CyAbstractSolver):
    def save_matrix(self, prefix: str) -> None: ...
    def get_jacobian(self) -> np.ndarray[tuple[int, int], np.dtype[np.float64]]: ...  # tuple[int, int] -> matrix
    def get_residuals(self) -> np.ndarray[tuple[int], np.dtype[np.float64]]: ...  # tuple[int] -> array
    def analyse_jacobian(self) -> tuple[list[int], list[int]]: ...

class CyNewton(CyAbstractNewton):
    def __init__(self, network: CyElectricalNetwork, optimize_tape: bool) -> None: ...

class CyNewtonGoldstein(CyAbstractNewton):
    def __init__(self, network: CyElectricalNetwork, optimize_tape: bool, m1: float, m2: float) -> None: ...
    def update_params(self, m1: float, m2: float) -> None: ...

class CyBackwardForward(CyAbstractSolver):
    def __init__(self, network: CyElectricalNetwork) -> None: ...

# Functions
def cy_activate_license(key: str, cacert_filepath: str, cache_folderpath: str) -> None: ...
def cy_deactivate_license() -> None: ...
def cy_get_license() -> CyLicense: ...
def cy_set_logging_config(severity: str) -> None: ...
