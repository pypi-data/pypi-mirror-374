from typing import Tuple, Iterable, Iterator, Union, overload
from .color import BaseColor
from .hex import Hex
from .hsv import HSV

class RGB(BaseColor):
    # --- Constructor ---
    @overload
    def __init__(self) -> None: ...
    @overload
    def __init__(self, arg: Union["RGB", str, Iterable[int]]) -> None: ...
    @overload
    def __init__(self, r: int, g: int, b: int) -> None: ...
    def __init__(self, *args) -> None: ...

    # --- Properties ---
    @property
    def r(self) -> int: ...
    @r.setter
    def r(self, value: int) -> None: ...

    @property
    def g(self) -> int: ...
    @g.setter
    def g(self, value: int) -> None: ...

    @property
    def b(self) -> int: ...
    @b.setter
    def b(self, value: int) -> None: ...

    @property
    def rgb(self) -> Tuple[int, int, int]: ...
    @rgb.setter
    def rgb(self, value: Iterable[int]) -> None: ...

    # --- Immutable convenience methods ---
    def with_red(self, r: int) -> "RGB": ...
    def with_green(self, g: int) -> "RGB": ...
    def with_blue(self, b: int) -> "RGB": ...

    # --- Conversion methods ---
    def to_rgb(self) -> "RGB": ...
    def to_hex(self) -> Hex: ...
    def to_tuple(self) -> Tuple[int, int, int]: ...
    def to_list(self) -> list[int]: ...
    def normalized(self) -> Tuple[float, float, float]: ...
    def to_hsv(self) -> HSV: ...

    # --- Alternate constructors ---
    @classmethod
    def from_hex(cls, hex_string: str) -> "RGB": ...
    @classmethod
    def from_normalized(cls, r: float, g: float, b: float) -> "RGB": ...

    # --- Sequence protocol ---
    def __iter__(self) -> Iterator[int]: ...
    def __getitem__(self, index: int) -> int: ...
    def __len__(self) -> int: ...

    # --- String representations ---
    def __str__(self) -> str: ...
    def __repr__(self) -> str: ...

    # --- Equality & hashing ---
    def __eq__(self, other: object) -> bool: ...
    def __hash__(self) -> int: ...