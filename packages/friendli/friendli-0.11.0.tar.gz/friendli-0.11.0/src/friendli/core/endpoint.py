"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

import io
from collections.abc import Mapping
from typing import IO, Any, Optional, Union

from friendli.core import models, utils
from friendli.core._hooks import HookContext
from friendli.core.types import UNSET, OptionalNullable
from friendli.core.utils import get_security_from_env
from friendli.core.utils.unmarshal_json_response import unmarshal_json_response

from .basesdk import AsyncSDK, BaseSDK, SyncSDK


class BaseEndpoint(BaseSDK):
    pass


class SyncEndpoint(BaseEndpoint, SyncSDK):
    def wandb_artifact_create(
        self,
        *,
        wandb_artifact_version_name: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        accelerator: OptionalNullable[
            Union[models.AcceleratorRequirement, models.AcceleratorRequirementTypedDict]
        ] = UNSET,
        autoscaling_policy: OptionalNullable[
            Union[models.AutoscalingPolicy, models.AutoscalingPolicyTypedDict]
        ] = UNSET,
        idempotency_key: OptionalNullable[str] = UNSET,
        name: OptionalNullable[str] = UNSET,
        project_id: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointWandbArtifactCreateResponse:
        """Create endpoint from W&B artifact.

        Create an endpoint from Weights & Biases artifact. If the idempotency key is provided, the API will check if the endpoint already exists, and rollout the existing endpoint if it does. In such cases, the project id must be provided.

        :param wandb_artifact_version_name: The specific model artifact version from Weights & Biases. The referred artifact will be used to create a new endpoint in Friendli Dedicated Endpoints or rollout an existing one.
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param accelerator: Specifies the instance type for the endpoint.
        :param autoscaling_policy: Defines autoscaling settings for the endpoint.
        :param idempotency_key: Used by Friendli Dedicated Endpoints to track which webhook automation triggered an endpoint rollout. If the `idempotencyKey` is provided, the API will check if the endpoint already exists, and rollout the existing endpoint if it does. In such cases, the `projectId` must be provided. Any unique value can be used.
        :param name: Specifies the name of your endpoint. If not provided, a name will be automatically generated for you.
        :param project_id: Specifies where endpoint will be created in your Friendli Dedicated Endpoints. If not provided, a new project will be created within your default team.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedEndpointWandbArtifactCreateRequest(
            x_friendli_team=x_friendli_team,
            dedicated_endpoint_wandb_artifact_create_body=models.DedicatedEndpointWandbArtifactCreateBody(
                wandb_artifact_version_name=wandb_artifact_version_name,
                accelerator=utils.get_pydantic_model(
                    accelerator,
                    OptionalNullable[models.AcceleratorRequirement],
                ),
                autoscaling_policy=utils.get_pydantic_model(
                    autoscaling_policy,
                    OptionalNullable[models.AutoscalingPolicy],
                ),
                idempotency_key=idempotency_key,
                name=name,
                project_id=project_id,
            ),
        )
        req = self._build_request(
            method="POST",
            path="/dedicated/endpoint/wandb-artifact-create",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.dedicated_endpoint_wandb_artifact_create_body,
                False,
                False,
                "json",
                models.DedicatedEndpointWandbArtifactCreateBody,
            ),
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedEndpointWandbArtifactCreate",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.DedicatedEndpointWandbArtifactCreateResponse,
                http_res,
            )
        if utils.match_response(http_res, ["400", "422", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    def create(
        self,
        *,
        advanced: Union[
            models.EndpointAdvancedConfig,
            models.EndpointAdvancedConfigTypedDict,
        ],
        hf_model_repo: str,
        instance_option_id: str,
        name: str,
        project_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        autoscaling_policy: OptionalNullable[
            Union[models.AutoscalingPolicy, models.AutoscalingPolicyTypedDict]
        ] = UNSET,
        hf_model_repo_revision: OptionalNullable[str] = UNSET,
        initial_version_comment: OptionalNullable[str] = UNSET,
        simplescale: OptionalNullable[
            Union[
                models.EndpointSimplescaleConfig,
                models.EndpointSimplescaleConfigTypedDict,
            ]
        ] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointStatus:
        """Create a new endpoint.

        Create a new endpoint and return its status

        :param advanced: Endpoint advanced config.
        :param hf_model_repo: HF ID of the model.
        :param instance_option_id: The ID of the instance option.
        :param name: The name of the endpoint.
        :param project_id: The ID of the project that owns the endpoint.
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param autoscaling_policy: The auto scaling configuration of the endpoint.
        :param hf_model_repo_revision: HF commit hash of the model.
        :param initial_version_comment: The comment for the initial version.
        :param simplescale: The simple scaling configuration of the endpoint.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedCreateEndpointRequest(
            x_friendli_team=x_friendli_team,
            dedicated_endpoint_create_body=models.DedicatedEndpointCreateBody(
                advanced=utils.get_pydantic_model(
                    advanced,
                    models.EndpointAdvancedConfig,
                ),
                hf_model_repo=hf_model_repo,
                instance_option_id=instance_option_id,
                name=name,
                project_id=project_id,
                autoscaling_policy=utils.get_pydantic_model(
                    autoscaling_policy,
                    OptionalNullable[models.AutoscalingPolicy],
                ),
                hf_model_repo_revision=hf_model_repo_revision,
                initial_version_comment=initial_version_comment,
                simplescale=utils.get_pydantic_model(
                    simplescale,
                    OptionalNullable[models.EndpointSimplescaleConfig],
                ),
            ),
        )
        req = self._build_request(
            method="POST",
            path="/dedicated/beta/endpoint",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.dedicated_endpoint_create_body,
                False,
                False,
                "json",
                models.DedicatedEndpointCreateBody,
            ),
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedCreateEndpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DedicatedEndpointStatus, http_res)
        if utils.match_response(http_res, ["400", "422", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    def list(
        self,
        *,
        project_id: OptionalNullable[str] = "",
        cursor: OptionalNullable[Union[bytes, IO[bytes], io.BufferedReader]] = UNSET,
        limit: OptionalNullable[int] = 20,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointListResponse:
        """List all endpoints.

        List all endpoint statuses

        :param project_id: The ID of the project. If omitted, query all endpoints under the team.
        :param cursor: Cursor for pagination
        :param limit: Limit of items per page
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedListEndpointsRequest(
            project_id=project_id,
            cursor=cursor,
            limit=limit,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request(
            method="GET",
            path="/dedicated/beta/endpoint",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedListEndpoints",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.DedicatedEndpointListResponse,
                http_res,
            )
        if utils.match_response(http_res, ["400", "422", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    def get_spec(
        self,
        *,
        endpoint_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointSpec:
        """Get endpoint specification.

        Get the specification of an endpoint

        :param endpoint_id: The ID of the endpoint
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedGetEndpointRequest(
            endpoint_id=endpoint_id,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request(
            method="GET",
            path="/dedicated/beta/endpoint/{endpoint_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedGetEndpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DedicatedEndpointSpec, http_res)
        if utils.match_response(http_res, ["400", "404", "422", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    def update(
        self,
        *,
        endpoint_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        advanced: OptionalNullable[
            Union[models.EndpointAdvancedConfig, models.EndpointAdvancedConfigTypedDict]
        ] = UNSET,
        autoscaling_policy: OptionalNullable[
            Union[models.AutoscalingPolicy, models.AutoscalingPolicyTypedDict]
        ] = UNSET,
        hf_model_repo: OptionalNullable[str] = UNSET,
        hf_model_repo_revision: OptionalNullable[str] = UNSET,
        instance_option_id: OptionalNullable[str] = UNSET,
        name: OptionalNullable[str] = UNSET,
        new_version_comment: OptionalNullable[str] = UNSET,
        simplescale: OptionalNullable[
            Union[
                models.EndpointSimplescaleConfig,
                models.EndpointSimplescaleConfigTypedDict,
            ]
        ] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointSpec:
        """Update endpoint spec.

        Update the specification of a specific endpoint

        :param endpoint_id: The ID of the endpoint
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param advanced: The advanced configuration of the endpoint.
        :param autoscaling_policy: The auto scaling configuration of the endpoint.
        :param hf_model_repo: HF ID of the model.
        :param hf_model_repo_revision: HF commit hash of the model.
        :param instance_option_id: The ID of the instance option.
        :param name: The name of the endpoint.
        :param new_version_comment: Comment for the new version.
        :param simplescale: The simple scaling configuration of the endpoint.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedUpdateEndpointRequest(
            endpoint_id=endpoint_id,
            x_friendli_team=x_friendli_team,
            dedicated_endpoint_update_body=models.DedicatedEndpointUpdateBody(
                advanced=utils.get_pydantic_model(
                    advanced,
                    OptionalNullable[models.EndpointAdvancedConfig],
                ),
                autoscaling_policy=utils.get_pydantic_model(
                    autoscaling_policy,
                    OptionalNullable[models.AutoscalingPolicy],
                ),
                hf_model_repo=hf_model_repo,
                hf_model_repo_revision=hf_model_repo_revision,
                instance_option_id=instance_option_id,
                name=name,
                new_version_comment=new_version_comment,
                simplescale=utils.get_pydantic_model(
                    simplescale,
                    OptionalNullable[models.EndpointSimplescaleConfig],
                ),
            ),
        )
        req = self._build_request(
            method="PUT",
            path="/dedicated/beta/endpoint/{endpoint_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.dedicated_endpoint_update_body,
                False,
                False,
                "json",
                models.DedicatedEndpointUpdateBody,
            ),
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedUpdateEndpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DedicatedEndpointSpec, http_res)
        if utils.match_response(http_res, ["400", "404", "422", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    def delete(
        self,
        *,
        endpoint_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Any:
        """Delete endpoint.

        Delete a specific endpoint

        :param endpoint_id: The ID of the endpoint
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedDeleteEndpointRequest(
            endpoint_id=endpoint_id,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request(
            method="DELETE",
            path="/dedicated/beta/endpoint/{endpoint_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedDeleteEndpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(Any, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                models.HTTPValidationErrorData,
                http_res,
            )
            raise models.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    def get_version_history(
        self,
        *,
        endpoint_id: str,
        cursor: OptionalNullable[Union[bytes, IO[bytes], io.BufferedReader]] = UNSET,
        limit: OptionalNullable[int] = 20,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointVersionHistoryResponse:
        """Get endpoint version history.

        Get version history of a specific endpoint

        :param endpoint_id: The ID of the endpoint
        :param cursor: Cursor for pagination
        :param limit: Limit of items per page
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedGetEndpointVersionHistoryRequest(
            endpoint_id=endpoint_id,
            cursor=cursor,
            limit=limit,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request(
            method="GET",
            path="/dedicated/beta/endpoint/{endpoint_id}/version",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedGetEndpointVersionHistory",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.DedicatedEndpointVersionHistoryResponse,
                http_res,
            )
        if utils.match_response(http_res, ["400", "404", "422", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    def get_status(
        self,
        *,
        endpoint_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointStatus:
        """Get endpoint status.

        Get the status of a specific endpoint

        :param endpoint_id: The ID of the endpoint
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedGetEndpointStatusRequest(
            endpoint_id=endpoint_id,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request(
            method="GET",
            path="/dedicated/beta/endpoint/{endpoint_id}/status",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedGetEndpointStatus",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DedicatedEndpointStatus, http_res)
        if utils.match_response(http_res, ["400", "404", "422", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    def sleep(
        self,
        *,
        endpoint_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointStatus:
        """Sleep endpoint.

        Put a specific endpoint to sleep

        :param endpoint_id: The ID of the endpoint
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedSleepEndpointRequest(
            endpoint_id=endpoint_id,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request(
            method="PUT",
            path="/dedicated/beta/endpoint/{endpoint_id}/sleep",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedSleepEndpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DedicatedEndpointStatus, http_res)
        if utils.match_response(http_res, ["400", "404", "422", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    def wake(
        self,
        *,
        endpoint_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointStatus:
        """Wake endpoint.

        Wake up a specific endpoint

        :param endpoint_id: The ID of the endpoint
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedWakeEndpointRequest(
            endpoint_id=endpoint_id,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request(
            method="PUT",
            path="/dedicated/beta/endpoint/{endpoint_id}/wake",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedWakeEndpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DedicatedEndpointStatus, http_res)
        if utils.match_response(http_res, ["400", "404", "422", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    def terminate(
        self,
        *,
        endpoint_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointStatus:
        """Terminate endpoint.

        Terminate a specific endpoint

        :param endpoint_id: The ID of the endpoint
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedTerminateEndpointRequest(
            endpoint_id=endpoint_id,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request(
            method="PUT",
            path="/dedicated/beta/endpoint/{endpoint_id}/terminate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedTerminateEndpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DedicatedEndpointStatus, http_res)
        if utils.match_response(http_res, ["400", "404", "422", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    def restart(
        self,
        *,
        endpoint_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointStatus:
        """Restart endpoint.

        Restart a FAILED or TERMINATED endpoint

        :param endpoint_id: The ID of the endpoint
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedRestartEndpointRequest(
            endpoint_id=endpoint_id,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request(
            method="PUT",
            path="/dedicated/beta/endpoint/{endpoint_id}/restart",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = self.do_request(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedRestartEndpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DedicatedEndpointStatus, http_res)
        if utils.match_response(http_res, ["400", "404", "422", "4XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = utils.stream_to_text(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)


class AsyncEndpoint(BaseEndpoint, AsyncSDK):
    async def wandb_artifact_create(
        self,
        *,
        wandb_artifact_version_name: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        accelerator: OptionalNullable[
            Union[models.AcceleratorRequirement, models.AcceleratorRequirementTypedDict]
        ] = UNSET,
        autoscaling_policy: OptionalNullable[
            Union[models.AutoscalingPolicy, models.AutoscalingPolicyTypedDict]
        ] = UNSET,
        idempotency_key: OptionalNullable[str] = UNSET,
        name: OptionalNullable[str] = UNSET,
        project_id: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointWandbArtifactCreateResponse:
        """Create endpoint from W&B artifact.

        Create an endpoint from Weights & Biases artifact. If the idempotency key is provided, the API will check if the endpoint already exists, and rollout the existing endpoint if it does. In such cases, the project id must be provided.

        :param wandb_artifact_version_name: The specific model artifact version from Weights & Biases. The referred artifact will be used to create a new endpoint in Friendli Dedicated Endpoints or rollout an existing one.
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param accelerator: Specifies the instance type for the endpoint.
        :param autoscaling_policy: Defines autoscaling settings for the endpoint.
        :param idempotency_key: Used by Friendli Dedicated Endpoints to track which webhook automation triggered an endpoint rollout. If the `idempotencyKey` is provided, the API will check if the endpoint already exists, and rollout the existing endpoint if it does. In such cases, the `projectId` must be provided. Any unique value can be used.
        :param name: Specifies the name of your endpoint. If not provided, a name will be automatically generated for you.
        :param project_id: Specifies where endpoint will be created in your Friendli Dedicated Endpoints. If not provided, a new project will be created within your default team.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedEndpointWandbArtifactCreateRequest(
            x_friendli_team=x_friendli_team,
            dedicated_endpoint_wandb_artifact_create_body=models.DedicatedEndpointWandbArtifactCreateBody(
                wandb_artifact_version_name=wandb_artifact_version_name,
                accelerator=utils.get_pydantic_model(
                    accelerator,
                    OptionalNullable[models.AcceleratorRequirement],
                ),
                autoscaling_policy=utils.get_pydantic_model(
                    autoscaling_policy,
                    OptionalNullable[models.AutoscalingPolicy],
                ),
                idempotency_key=idempotency_key,
                name=name,
                project_id=project_id,
            ),
        )
        req = self._build_request_async(
            method="POST",
            path="/dedicated/endpoint/wandb-artifact-create",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.dedicated_endpoint_wandb_artifact_create_body,
                False,
                False,
                "json",
                models.DedicatedEndpointWandbArtifactCreateBody,
            ),
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedEndpointWandbArtifactCreate",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.DedicatedEndpointWandbArtifactCreateResponse,
                http_res,
            )
        if utils.match_response(http_res, ["400", "422", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    async def create(
        self,
        *,
        advanced: Union[
            models.EndpointAdvancedConfig,
            models.EndpointAdvancedConfigTypedDict,
        ],
        hf_model_repo: str,
        instance_option_id: str,
        name: str,
        project_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        autoscaling_policy: OptionalNullable[
            Union[models.AutoscalingPolicy, models.AutoscalingPolicyTypedDict]
        ] = UNSET,
        hf_model_repo_revision: OptionalNullable[str] = UNSET,
        initial_version_comment: OptionalNullable[str] = UNSET,
        simplescale: OptionalNullable[
            Union[
                models.EndpointSimplescaleConfig,
                models.EndpointSimplescaleConfigTypedDict,
            ]
        ] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointStatus:
        """Create a new endpoint.

        Create a new endpoint and return its status

        :param advanced: Endpoint advanced config.
        :param hf_model_repo: HF ID of the model.
        :param instance_option_id: The ID of the instance option.
        :param name: The name of the endpoint.
        :param project_id: The ID of the project that owns the endpoint.
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param autoscaling_policy: The auto scaling configuration of the endpoint.
        :param hf_model_repo_revision: HF commit hash of the model.
        :param initial_version_comment: The comment for the initial version.
        :param simplescale: The simple scaling configuration of the endpoint.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedCreateEndpointRequest(
            x_friendli_team=x_friendli_team,
            dedicated_endpoint_create_body=models.DedicatedEndpointCreateBody(
                advanced=utils.get_pydantic_model(
                    advanced,
                    models.EndpointAdvancedConfig,
                ),
                hf_model_repo=hf_model_repo,
                instance_option_id=instance_option_id,
                name=name,
                project_id=project_id,
                autoscaling_policy=utils.get_pydantic_model(
                    autoscaling_policy,
                    OptionalNullable[models.AutoscalingPolicy],
                ),
                hf_model_repo_revision=hf_model_repo_revision,
                initial_version_comment=initial_version_comment,
                simplescale=utils.get_pydantic_model(
                    simplescale,
                    OptionalNullable[models.EndpointSimplescaleConfig],
                ),
            ),
        )
        req = self._build_request_async(
            method="POST",
            path="/dedicated/beta/endpoint",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.dedicated_endpoint_create_body,
                False,
                False,
                "json",
                models.DedicatedEndpointCreateBody,
            ),
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedCreateEndpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DedicatedEndpointStatus, http_res)
        if utils.match_response(http_res, ["400", "422", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    async def list(
        self,
        *,
        project_id: OptionalNullable[str] = "",
        cursor: OptionalNullable[Union[bytes, IO[bytes], io.BufferedReader]] = UNSET,
        limit: OptionalNullable[int] = 20,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointListResponse:
        """List all endpoints.

        List all endpoint statuses

        :param project_id: The ID of the project. If omitted, query all endpoints under the team.
        :param cursor: Cursor for pagination
        :param limit: Limit of items per page
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedListEndpointsRequest(
            project_id=project_id,
            cursor=cursor,
            limit=limit,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request_async(
            method="GET",
            path="/dedicated/beta/endpoint",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=False,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedListEndpoints",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.DedicatedEndpointListResponse,
                http_res,
            )
        if utils.match_response(http_res, ["400", "422", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    async def get_spec(
        self,
        *,
        endpoint_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointSpec:
        """Get endpoint specification.

        Get the specification of an endpoint

        :param endpoint_id: The ID of the endpoint
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedGetEndpointRequest(
            endpoint_id=endpoint_id,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request_async(
            method="GET",
            path="/dedicated/beta/endpoint/{endpoint_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedGetEndpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DedicatedEndpointSpec, http_res)
        if utils.match_response(http_res, ["400", "404", "422", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    async def update(
        self,
        *,
        endpoint_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        advanced: OptionalNullable[
            Union[models.EndpointAdvancedConfig, models.EndpointAdvancedConfigTypedDict]
        ] = UNSET,
        autoscaling_policy: OptionalNullable[
            Union[models.AutoscalingPolicy, models.AutoscalingPolicyTypedDict]
        ] = UNSET,
        hf_model_repo: OptionalNullable[str] = UNSET,
        hf_model_repo_revision: OptionalNullable[str] = UNSET,
        instance_option_id: OptionalNullable[str] = UNSET,
        name: OptionalNullable[str] = UNSET,
        new_version_comment: OptionalNullable[str] = UNSET,
        simplescale: OptionalNullable[
            Union[
                models.EndpointSimplescaleConfig,
                models.EndpointSimplescaleConfigTypedDict,
            ]
        ] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointSpec:
        """Update endpoint spec.

        Update the specification of a specific endpoint

        :param endpoint_id: The ID of the endpoint
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param advanced: The advanced configuration of the endpoint.
        :param autoscaling_policy: The auto scaling configuration of the endpoint.
        :param hf_model_repo: HF ID of the model.
        :param hf_model_repo_revision: HF commit hash of the model.
        :param instance_option_id: The ID of the instance option.
        :param name: The name of the endpoint.
        :param new_version_comment: Comment for the new version.
        :param simplescale: The simple scaling configuration of the endpoint.
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedUpdateEndpointRequest(
            endpoint_id=endpoint_id,
            x_friendli_team=x_friendli_team,
            dedicated_endpoint_update_body=models.DedicatedEndpointUpdateBody(
                advanced=utils.get_pydantic_model(
                    advanced,
                    OptionalNullable[models.EndpointAdvancedConfig],
                ),
                autoscaling_policy=utils.get_pydantic_model(
                    autoscaling_policy,
                    OptionalNullable[models.AutoscalingPolicy],
                ),
                hf_model_repo=hf_model_repo,
                hf_model_repo_revision=hf_model_repo_revision,
                instance_option_id=instance_option_id,
                name=name,
                new_version_comment=new_version_comment,
                simplescale=utils.get_pydantic_model(
                    simplescale,
                    OptionalNullable[models.EndpointSimplescaleConfig],
                ),
            ),
        )
        req = self._build_request_async(
            method="PUT",
            path="/dedicated/beta/endpoint/{endpoint_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=True,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            get_serialized_body=lambda: utils.serialize_request_body(
                request.dedicated_endpoint_update_body,
                False,
                False,
                "json",
                models.DedicatedEndpointUpdateBody,
            ),
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedUpdateEndpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DedicatedEndpointSpec, http_res)
        if utils.match_response(http_res, ["400", "404", "422", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    async def delete(
        self,
        *,
        endpoint_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> Any:
        """Delete endpoint.

        Delete a specific endpoint

        :param endpoint_id: The ID of the endpoint
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedDeleteEndpointRequest(
            endpoint_id=endpoint_id,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request_async(
            method="DELETE",
            path="/dedicated/beta/endpoint/{endpoint_id}",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedDeleteEndpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        response_data: Any = None
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(Any, http_res)
        if utils.match_response(http_res, "422", "application/json"):
            response_data = unmarshal_json_response(
                models.HTTPValidationErrorData,
                http_res,
            )
            raise models.HTTPValidationError(response_data, http_res)
        if utils.match_response(http_res, ["400", "404", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    async def get_version_history(
        self,
        *,
        endpoint_id: str,
        cursor: OptionalNullable[Union[bytes, IO[bytes], io.BufferedReader]] = UNSET,
        limit: OptionalNullable[int] = 20,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointVersionHistoryResponse:
        """Get endpoint version history.

        Get version history of a specific endpoint

        :param endpoint_id: The ID of the endpoint
        :param cursor: Cursor for pagination
        :param limit: Limit of items per page
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedGetEndpointVersionHistoryRequest(
            endpoint_id=endpoint_id,
            cursor=cursor,
            limit=limit,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request_async(
            method="GET",
            path="/dedicated/beta/endpoint/{endpoint_id}/version",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedGetEndpointVersionHistory",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(
                models.DedicatedEndpointVersionHistoryResponse,
                http_res,
            )
        if utils.match_response(http_res, ["400", "404", "422", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    async def get_status(
        self,
        *,
        endpoint_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointStatus:
        """Get endpoint status.

        Get the status of a specific endpoint

        :param endpoint_id: The ID of the endpoint
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedGetEndpointStatusRequest(
            endpoint_id=endpoint_id,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request_async(
            method="GET",
            path="/dedicated/beta/endpoint/{endpoint_id}/status",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedGetEndpointStatus",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DedicatedEndpointStatus, http_res)
        if utils.match_response(http_res, ["400", "404", "422", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    async def sleep(
        self,
        *,
        endpoint_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointStatus:
        """Sleep endpoint.

        Put a specific endpoint to sleep

        :param endpoint_id: The ID of the endpoint
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedSleepEndpointRequest(
            endpoint_id=endpoint_id,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request_async(
            method="PUT",
            path="/dedicated/beta/endpoint/{endpoint_id}/sleep",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedSleepEndpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DedicatedEndpointStatus, http_res)
        if utils.match_response(http_res, ["400", "404", "422", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    async def wake(
        self,
        *,
        endpoint_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointStatus:
        """Wake endpoint.

        Wake up a specific endpoint

        :param endpoint_id: The ID of the endpoint
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedWakeEndpointRequest(
            endpoint_id=endpoint_id,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request_async(
            method="PUT",
            path="/dedicated/beta/endpoint/{endpoint_id}/wake",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedWakeEndpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DedicatedEndpointStatus, http_res)
        if utils.match_response(http_res, ["400", "404", "422", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    async def terminate(
        self,
        *,
        endpoint_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointStatus:
        """Terminate endpoint.

        Terminate a specific endpoint

        :param endpoint_id: The ID of the endpoint
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedTerminateEndpointRequest(
            endpoint_id=endpoint_id,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request_async(
            method="PUT",
            path="/dedicated/beta/endpoint/{endpoint_id}/terminate",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedTerminateEndpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DedicatedEndpointStatus, http_res)
        if utils.match_response(http_res, ["400", "404", "422", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, "5XX", "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)

    async def restart(
        self,
        *,
        endpoint_id: str,
        x_friendli_team: OptionalNullable[str] = UNSET,
        retries: OptionalNullable[utils.RetryConfig] = UNSET,
        server_url: Optional[str] = None,
        timeout_ms: Optional[int] = None,
        http_headers: Optional[Mapping[str, str]] = None,
    ) -> models.DedicatedEndpointStatus:
        """Restart endpoint.

        Restart a FAILED or TERMINATED endpoint

        :param endpoint_id: The ID of the endpoint
        :param x_friendli_team: ID of team to run requests as (optional parameter).
        :param retries: Override the default retry configuration for this method
        :param server_url: Override the default server URL for this method
        :param timeout_ms: Override the default request timeout configuration for this method in milliseconds
        :param http_headers: Additional headers to set or replace on requests.
        """
        base_url = None
        url_variables = None
        if timeout_ms is None:
            timeout_ms = self.sdk_configuration.timeout_ms
        if server_url is not None:
            base_url = server_url
        else:
            base_url = self._get_url(base_url, url_variables)
        request = models.DedicatedRestartEndpointRequest(
            endpoint_id=endpoint_id,
            x_friendli_team=x_friendli_team,
        )
        req = self._build_request_async(
            method="PUT",
            path="/dedicated/beta/endpoint/{endpoint_id}/restart",
            base_url=base_url,
            url_variables=url_variables,
            request=request,
            request_body_required=False,
            request_has_path_params=True,
            request_has_query_params=True,
            user_agent_header="user-agent",
            accept_header_value="application/json",
            http_headers=http_headers,
            security=self.sdk_configuration.security,
            timeout_ms=timeout_ms,
        )
        if retries == UNSET:
            if self.sdk_configuration.retry_config is not UNSET:
                retries = self.sdk_configuration.retry_config
            else:
                retries = utils.RetryConfig(
                    "backoff",
                    utils.BackoffStrategy(500, 60000, 1.5, 3600000),
                    True,
                )
        retry_config = None
        if isinstance(retries, utils.RetryConfig):
            retry_config = (retries, ["429", "500", "502", "503", "504"])
        http_res = await self.do_request_async(
            hook_ctx=HookContext(
                config=self.sdk_configuration,
                base_url=base_url or "",
                operation_id="dedicatedRestartEndpoint",
                oauth2_scopes=[],
                security_source=get_security_from_env(
                    self.sdk_configuration.security,
                    models.Security,
                ),
            ),
            request=req,
            error_status_codes=["400", "404", "422", "4XX", "500", "5XX"],
            retry_config=retry_config,
        )
        if utils.match_response(http_res, "200", "application/json"):
            return unmarshal_json_response(models.DedicatedEndpointStatus, http_res)
        if utils.match_response(http_res, ["400", "404", "422", "4XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        if utils.match_response(http_res, ["500", "5XX"], "*"):
            http_res_text = await utils.stream_to_text_async(http_res)
            raise models.SDKError("API error occurred", http_res, http_res_text)
        raise models.SDKError("Unexpected response received", http_res)
