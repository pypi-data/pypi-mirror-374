"""
Client generation functions for FastestMCP CLI
"""

from pathlib import Path

# Import templates


def generate_complex_client(name: str, apis: int, integrations: int, handlers: int, notifications: int, subscriptions: int, transport: str, structure: str, client_type: str, output_dir: str) -> tuple[str, str]:
    """Generate a MCP-compliant client with proper architecture"""
    base_path = Path(output_dir)

    if structure == 'mono':
        # Single file structure
        output_path = base_path / f"{name}_client.py"
        code = generate_mono_client_file(name, transport, client_type)
        output_path.parent.mkdir(parents=True, exist_ok=True)
        with open(output_path, 'w') as f:
            f.write(code)

        # Generate pyproject.toml for mono files
        pyproject_path = base_path / "pyproject.toml"
        pyproject_content = generate_mcp_client_pyproject_toml(name, client_type, transport, structure)
        with open(pyproject_path, 'w') as f:
            f.write(pyproject_content)

        folder_structure = f"""
```
{output_path.name}
pyproject.toml
```
"""
        return f"MCP-compliant client generated: {output_path}", folder_structure

    else:
        # Structured folder layout with clean MCP organization
        client_dir = base_path / f"{name}_client"
        client_dir.mkdir(parents=True, exist_ok=True)

        # Create src directory structure
        src_dir = client_dir / "src"
        src_dir.mkdir(exist_ok=True)

        # Generate main client file in src/
        main_file = src_dir / "client.py"
        code = generate_clean_mcp_client_file(name, transport, client_type)
        with open(main_file, 'w') as f:
            f.write(code)

        # Generate __init__.py for src
        src_init = src_dir / "__init__.py"
        with open(src_init, 'w') as f:
            f.write(f'''"""
{name}_client - MCP Client Package
Generated by FastestMCP CLI
"""

__version__ = "0.1.0"
''')

        # Generate main.py in root
        main_entry = client_dir / "main.py"
        main_content = generate_clean_mcp_client_main_py(name, client_type)
        with open(main_entry, 'w') as f:
            f.write(main_content)

        # Generate __init__.py in root directory
        root_init = client_dir / "__init__.py"
        with open(root_init, 'w') as f:
            f.write(f'''"""
{name}_client - MCP Client Package
Generated by FastestMCP CLI
"""

__version__ = "0.1.0"
''')

        # Generate tests directory and files
        tests_dir = client_dir / "tests"
        tests_dir.mkdir(exist_ok=True)

        # Generate __init__.py for tests
        test_init = tests_dir / "__init__.py"
        with open(test_init, 'w') as f:
            f.write('"""Tests for MCP Client"""\n')

        # Generate main test file
        test_file = tests_dir / "test_client.py"
        test_code = generate_clean_mcp_client_test_file(name)
        with open(test_file, 'w') as f:
            f.write(test_code)

        # Generate pyproject.toml
        pyproject_file = client_dir / "pyproject.toml"
        pyproject_content = generate_mcp_client_pyproject_toml(name, client_type, transport, 'structured')
        with open(pyproject_file, 'w') as f:
            f.write(pyproject_content)

        # Generate README.md
        readme_file = client_dir / "README.md"
        readme_content = generate_clean_mcp_client_readme(name, transport, client_type)
        with open(readme_file, 'w') as f:
            f.write(readme_content)

        # Create folder structure summary
        all_files = [
            "__init__.py",
            "main.py",
            "pyproject.toml",
            "README.md",
            "src/__init__.py",
            "src/client.py",
            "tests/__init__.py",
            "tests/test_client.py"
        ]

        folder_structure = generate_clean_mcp_client_folder_markdown(name, transport, client_type, all_files)

        return f"MCP-compliant structured client generated in: {client_dir}", folder_structure


def generate_mono_client_file(name: str, client_type: str, transport: str) -> str:
    """Generate mono-file MCP-compliant client"""
    if client_type == 'fastmcp':
        # FastMCP client
        code = f'''#!/usr/bin/env python3
"""
{name} Client - FastMCP Client
Generated by FastestMCP CLI
"""

from fastmcp import Client
import asyncio
from typing import Dict, Any, Optional
import os
import json
import yaml


class {name.title()}Client:
    """
    MCP-Compliant Client using FastMCP.
    Implements proper MCP client architecture with connection manager pattern.
    """

    def __init__(self, config_or_path=None):
        """
        Args:
            config_or_path (dict or str): Dict config or path to mcp.json config file.
        """
        self._connected = False
        self._client = None
        self._config = self._load_config(config_or_path)

    async def connect(self):
        """Connect to MCP server via stdio transport"""
        try:
            # Use stdio transport for local development
            self._client = Client()
            await self._client.connect_stdio_async("python", ["server.py"])
            self._connected = True
            print("✅ Connected to MCP server")
        except Exception as e:
            print(f"❌ Failed to connect: {{e}}")
            raise

    async def disconnect(self):
        """Disconnect from MCP server"""
        if self._client:
            await self._client.disconnect_async()
        self._connected = False
        print("✅ Disconnected")

    # MCP Client → Server Primitives

    async def list_tools(self) -> list:
        """List available tools from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            tools = await self._client.list_tools()
            return tools
        except Exception as e:
            print(f"❌ Failed to list tools: {{e}}")
            return []

    async def call_tool(self, tool_name: str, arguments: dict = None) -> dict:
        """Call a tool on the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            if arguments is None:
                arguments = {{}}
            result = await self._client.call_tool(tool_name, arguments)
            return result
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    async def list_resources(self) -> list:
        """List available resources from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            resources = await self._client.list_resources()
            return resources
        except Exception as e:
            print(f"❌ Failed to list resources: {{e}}")
            return []

    async def read_resource(self, resource_uri: str) -> dict:
        """Read a resource from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            content = await self._client.read_resource(resource_uri)
            return content
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    async def list_prompts(self) -> list:
        """List available prompts from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            prompts = await self._client.list_prompts()
            return prompts
        except Exception as e:
            print(f"❌ Failed to list prompts: {{e}}")
            return []

    async def render_prompt(self, prompt_name: str, arguments: dict = None) -> dict:
        """Render a prompt from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            if arguments is None:
                arguments = {{}}
            result = await self._client.render_prompt(prompt_name, arguments)
            return result
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    # MCP Client → Server Primitives

    async def send_log(self, message: str, level: str = "info"):
        """Send a log message to the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            await self._client.send_log(message, level)
        except Exception as e:
            print(f"❌ Failed to send log: {{e}}")

    async def request_elicitation(self, query: str) -> str:
        """Request user input elicitation from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            response = await self._client.request_elicitation(query)
            return response
        except Exception as e:
            return f"Error: {{e}}"

    async def request_sampling(self, prompt: str) -> str:
        """Request LLM sampling from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            response = await self._client.request_sampling(prompt)
            return response
        except Exception as e:
            return f"Error: {{e}}"

    @staticmethod
    def _load_config(config_or_path, server_name=None):
        """
        Loads and normalizes the config for MCP client.
        Accepts a dict or a path to a JSON/YAML config file.
        """
        if config_or_path is None:
            config_path = os.path.join(os.getcwd(), 'mcp.json')
            if os.path.exists(config_path):
                with open(config_path) as f:
                    config = json.load(f)
            else:
                config = {{"servers": [{{"command": "python", "args": ["server.py"]}}]}}
        elif isinstance(config_or_path, str):
            ext = os.path.splitext(config_or_path)[1]
            with open(config_or_path, "r") as f:
                if ext in (".yaml", ".yml"):
                    config = yaml.safe_load(f)
                else:
                    config = json.load(f)
        elif isinstance(config_or_path, dict):
            config = config_or_path
        else:
            raise ValueError("Config must be dict or path")

        return config


async def main():
    """Main execution function"""
    client = {name.title()}Client()

    try:
        await client.connect()

        # Example usage of MCP primitives
        print("🔧 Testing MCP client functionality...")

        # Test tools
        tools_list = await client.list_tools()
        print(f"📋 Available tools: {{tools_list}}")

        # Test resources
        resources_list = await client.list_resources()
        print(f"📁 Available resources: {{resources_list}}")

        # Example tool call
        result = await client.call_tool("example_tool", {{"param": "value"}})
        print(f"🔗 Tool Result: {{result}}")

    except Exception as e:
        print(f"❌ Error: {{e}}")
    finally:
        await client.disconnect()

if __name__ == "__main__":
    asyncio.run(main())
'''
    else:
        # Standard MCP client
        code = f'''#!/usr/bin/env python3
"""
{name} Client - Standard MCP Client
Generated by FastestMCP CLI
"""

from mcp.client.stdio import stdio_client
import asyncio
from typing import Dict, Any, Optional
import os
import json
import yaml


class {name.title()}Client:
    """
    MCP-Compliant Client using standard MCP library.
    Implements proper MCP client architecture with connection manager pattern.
    """

    def __init__(self, config_or_path=None):
        """
        Args:
            config_or_path (dict or str): Dict config or path to mcp.json config file.
        """
        self._connected = False
        self._client = None
        self._config = self._load_config(config_or_path)

    async def connect(self):
        """Connect to MCP server via stdio transport"""
        try:
            # Use stdio transport for local development
            self._stdio_context = stdio_client(["python", "server.py"])
            self._client = await self._stdio_context.__aenter__()
            self._connected = True
            print("✅ Connected to MCP server")
        except Exception as e:
            print(f"❌ Failed to connect: {{e}}")
            raise

    async def disconnect(self):
        """Disconnect from MCP server"""
        if self._stdio_context:
            await self._stdio_context.__aexit__(None, None, None)
        self._connected = False
        print("✅ Disconnected")

    # MCP Client → Server Primitives

    async def list_tools(self) -> list:
        """List available tools from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            tools = await self._client.list_tools()
            return tools
        except Exception as e:
            print(f"❌ Failed to list tools: {{e}}")
            return []

    async def call_tool(self, tool_name: str, arguments: dict = None) -> dict:
        """Call a tool on the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            if arguments is None:
                arguments = {{}}
            result = await self._client.call_tool(tool_name, arguments)
            return result
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    async def list_resources(self) -> list:
        """List available resources from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            resources = await self._client.list_resources()
            return resources
        except Exception as e:
            print(f"❌ Failed to list resources: {{e}}")
            return []

    async def read_resource(self, resource_uri: str) -> dict:
        """Read a resource from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            content = await self._client.read_resource(resource_uri)
            return content
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    async def list_prompts(self) -> list:
        """List available prompts from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            prompts = await self._client.list_prompts()
            return prompts
        except Exception as e:
            print(f"❌ Failed to list prompts: {{e}}")
            return []

    async def render_prompt(self, prompt_name: str, arguments: dict = None) -> dict:
        """Render a prompt from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            if arguments is None:
                arguments = {{}}
            result = await self._client.render_prompt(prompt_name, arguments)
            return result
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    # MCP Client → Server Primitives

    async def send_log(self, message: str, level: str = "info"):
        """Send a log message to the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            await self._client.send_log(message, level)
        except Exception as e:
            print(f"❌ Failed to send log: {{e}}")

    async def request_elicitation(self, query: str) -> str:
        """Request user input elicitation from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            response = await self._client.request_elicitation(query)
            return response
        except Exception as e:
            return f"Error: {{e}}"

    async def request_sampling(self, prompt: str) -> str:
        """Request LLM sampling from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            response = await self._client.request_sampling(prompt)
            return response
        except Exception as e:
            return f"Error: {{e}}"

    @staticmethod
    def _load_config(config_or_path, server_name=None):
        """
        Loads and normalizes the config for MCP client.
        Accepts a dict or a path to a JSON/YAML config file.
        """
        if config_or_path is None:
            config_path = os.path.join(os.getcwd(), 'mcp.json')
            if os.path.exists(config_path):
                with open(config_path) as f:
                    config = json.load(f)
            else:
                config = {{"servers": [{{"command": "python", "args": ["server.py"]}}]}}
        elif isinstance(config_or_path, str):
            ext = os.path.splitext(config_or_path)[1]
            with open(config_or_path, "r") as f:
                if ext in (".yaml", ".yml"):
                    config = yaml.safe_load(f)
                else:
                    config = json.load(f)
        elif isinstance(config_or_path, dict):
            config = config_or_path
        else:
            raise ValueError("Config must be dict or path")

        return config


async def main():
    """Main execution function"""
    client = {name.title()}Client()

    try:
        await client.connect()

        # Example usage of MCP primitives
        print("🔧 Testing MCP client functionality...")

        # Test tools
        tools_list = await client.list_tools()
        print(f"📋 Available tools: {{tools_list}}")

        # Test resources
        resources_list = await client.list_resources()
        print(f"📁 Available resources: {{resources_list}}")

        # Example tool call
        result = await client.call_tool("example_tool", {{"param": "value"}})
        print(f"� Tool Result: {{result}}")

    except Exception as e:
        print(f"❌ Error: {{e}}")
    finally:
        await client.disconnect()

if __name__ == "__main__":
    asyncio.run(main())
'''

    return code


def generate_main_client(name: str, apis: int, integrations: int, handlers: int, notifications: int, subscriptions: int, transport: str, client_type: str) -> str:
    """Generate the main client file for structured layout"""
    if client_type == 'fastmcp':
        code = f'''#!/usr/bin/env python3
"""
{name}_client/client.py - Main FastMCP Client (APIs: {apis}, Integrations: {integrations}, Handlers: {handlers})
Generated by FastestMCP CLI
"""

from fastmcp import Client
import asyncio
from . import apis, integrations

class {name.title()}Client:
    """{name.title()} MCP Client with programmatic API endpoints"""

    def __init__(self, server_url: str = None):
        self.server_url = server_url or "http://localhost:8000"
        self.client = Client(self.server_url)
        self._connected = False

    async def connect(self):
        """Connect to MCP server"""
        try:
            await self.client.connect()
            self._connected = True
            print(f"✅ Connected to {{self.server_url}}")
        except Exception as e:
            print("❌ Failed to connect:", e)
            raise

    async def disconnect(self):
        """Disconnect from MCP server"""
        if self._connected:
            await self.client.disconnect()
            self._connected = False
            print("✅ Disconnected")

    # Programmatic API endpoints - delegate to apis module
'''
    else:
        code = f'''#!/usr/bin/env python3
"""
{name}_client/client.py - Main MCP Client (APIs: {apis}, Integrations: {integrations}, Handlers: {handlers})
Generated by FastestMCP CLI
"""

from mcp.client.stdio import stdio_client
import asyncio
from . import apis, integrations

class {name.title()}Client:
    """{name.title()} MCP Client with programmatic API endpoints"""

    def __init__(self, server_command: str = None):
        self.server_command = server_command or ["python", "server.py"]
        self.client = None
        self._connected = False

    async def connect(self):
        """Connect to MCP server"""
        try:
            async with stdio_client(self.server_command) as (read, write):
                self.client = await read()
                self._connected = True
                print(f"✅ Connected to server")
        except Exception as e:
            print("❌ Failed to connect:", e)
            raise

    async def disconnect(self):
        """Disconnect from MCP server"""
        self._connected = False
        print("✅ Disconnected")

    # Programmatic API endpoints - delegate to apis module
'''

    # Add API endpoint calls
    for i in range(apis):
        code += f'''
    async def api_endpoint_{i+1}(self, **kwargs) -> dict:
        """API Endpoint {i+1} - programmatic interface"""
        return await apis.api_endpoint_{i+1}(self.client, **kwargs)
'''

    # Add integration calls
    for i in range(integrations):
        code += f'''
    def integration_{i+1}(self, data: dict) -> dict:
        """Integration {i+1} - external system integration"""
        return integrations.integration_{i+1}(data)
'''

    # Add transport-specific code
    if transport == 'http':
        code += '''
    async def make_http_request(self, endpoint: str, method: str = "GET", **kwargs):
        """Make HTTP request to external API"""
        import httpx

        async with httpx.AsyncClient() as client:
            url = f"{self.server_url}/{endpoint}"
            response = await client.request(method, url, **kwargs)
            return response.json()
'''
    elif transport == 'websocket':
        code += '''
    async def connect_websocket(self):
        """Connect via WebSocket"""
        import websockets

        uri = f"ws://{self.server_url.replace('http', 'ws')}/ws"
        async with websockets.connect(uri) as websocket:
            await websocket.send("Hello MCP Client")
            response = await websocket.recv()
            return response
'''
    else:
        code += '''
    async def send_stdio_command(self, command: str, **kwargs):
        """Send command via stdio"""
        print(f"📤 Sending command: {command}")
        return {"command": command, "status": "sent", "kwargs": kwargs}
'''

    code += '''

async def main():
    """Main execution function"""
    client = MyClient()

    try:
        await client.connect()

        # Example usage
        result = await client.api_endpoint_1(param="example_value")
        print(f"API Result: {{result}}")

        # Example integration
        integration_result = client.integration_1({{"key": "value"}})
        print(f"Integration Result: {{integration_result}}")

    except Exception as e:
        print(f"❌ Error: {{e}}")
    finally:
        await client.disconnect()

if __name__ == "__main__":
    asyncio.run(main())
'''

    return code


def generate_clean_mcp_client_file(name: str, transport: str, client_type: str) -> str:
    """Generate a clean MCP-compliant client file for structured layout"""
    if client_type == 'fastmcp':
        code = f'''#!/usr/bin/env python3
"""
{name}_client/src/client.py - MCP-Compliant FastMCP Client
Generated by FastestMCP CLI - Aligned with MCP Architecture
"""

from fastmcp.client.stdio import stdio_client
import asyncio
from typing import Dict, Any, Optional, List
import sys
import os

class {name.title()}Client:
    """MCP Client - Connection manager for MCP server communication"""

    def __init__(self, server_command: Optional[List[str]] = None):
        self.server_command = server_command or ["python", "../demo_server/main.py"]
        self.client = None
        self._connected = False
        self._stdio_context = None

    async def connect(self):
        """Connect to MCP server via stdio transport"""
        try:
            # Establish stdio connection to server
            from fastmcp.client.stdio import StdioServerParameters
            params = StdioServerParameters(command=self.server_command[0], args=self.server_command[1:])
            self._stdio_context = stdio_client(params)
            async with self._stdio_context as (read_stream, write_stream):
                # In real MCP, this would establish the session
                self._connected = True
                print("✅ Connected to MCP server via stdio")
                # Keep connection alive - in real implementation, this would be handled differently
        except Exception as e:
            print("❌ Failed to connect:", e)
            raise

    async def disconnect(self):
        """Disconnect from MCP server"""
        if self._stdio_context:
            # Close the stdio context
            self._connected = False
            print("✅ Disconnected from MCP server")

    # MCP Client → Server primitives (as per architecture)

    async def list_tools(self) -> Dict[str, Any]:
        """List available tools from MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")

        try:
            # This is a simplified example - in real MCP, this would use the protocol
            return {{"tools": [], "status": "listed"}}
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    async def call_tool(self, tool_name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """Call a tool on the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")

        try:
            # This would use proper MCP protocol messaging
            return {{
                "tool": tool_name,
                "arguments": arguments,
                "result": f"Tool {{tool_name}} called with {{arguments}}",
                "status": "success"
            }}
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    async def list_resources(self) -> Dict[str, Any]:
        """List available resources from MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")

        try:
            return {{"resources": [], "status": "listed"}}
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    async def read_resource(self, resource_uri: str) -> Dict[str, Any]:
        """Read a resource from MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")

        try:
            return {{
                "resource": resource_uri,
                "content": f"Content of {{resource_uri}}",
                "status": "read"
            }}
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    async def list_prompts(self) -> Dict[str, Any]:
        """List available prompts from MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")

        try:
            return {{"prompts": [], "status": "listed"}}
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    async def render_prompt(self, prompt_name: str, arguments: Dict[str, Any]) -> Dict[str, Any]:
        """Render a prompt from MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")

        try:
            return {{
                "prompt": prompt_name,
                "arguments": arguments,
                "rendered": f"Rendered prompt {{prompt_name}} with {{arguments}}",
                "status": "rendered"
            }}
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    # Client → Server primitives (logging, elicitation, sampling)

    async def send_log(self, message: str, level: str = "info") -> Dict[str, Any]:
        """Send log message to MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")

        try:
            return {{
                "message": message,
                "level": level,
                "status": "logged",
                "timestamp": "2025-09-03T00:00:00Z"
            }}
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    async def request_elicitation(self, query: str) -> Dict[str, Any]:
        """Request user input elicitation from MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")

        try:
            return {{
                "query": query,
                "elicitation_type": "user_input",
                "status": "requested"
            }}
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    async def request_sampling(self, prompt: str, **kwargs) -> Dict[str, Any]:
        """Request LLM sampling from MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")

        try:
            return {{
                "prompt": prompt,
                "sampling_parameters": kwargs,
                "status": "sampled",
                "response": f"Sampled response for: {{prompt[:50]}}..."
            }}
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}
'''
    else:
        # Standard MCP client
        code = f'''#!/usr/bin/env python3
"""
{name} Client - Standard MCP Client
Generated by FastestMCP CLI
"""

from mcp.client.stdio import stdio_client
import asyncio
from typing import Dict, Any, Optional
import os
import json
import yaml


class {name.title()}Client:
    """
    MCP-Compliant Client using standard MCP library.
    Implements proper MCP client architecture with connection manager pattern.
    """

    def __init__(self, config_or_path=None):
        """
        Args:
            config_or_path (dict or str): Dict config or path to mcp.json config file.
        """
        self._connected = False
        self._client = None
        self._config = self._load_config(config_or_path)

    async def connect(self):
        """Connect to MCP server via stdio transport"""
        try:
            # Use stdio transport for local development
            self._stdio_context = stdio_client(["python", "server.py"])
            self._client = await self._stdio_context.__aenter__()
            self._connected = True
            print("✅ Connected to MCP server")
        except Exception as e:
            print(f"❌ Failed to connect: {{e}}")
            raise

    async def disconnect(self):
        """Disconnect from MCP server"""
        if self._stdio_context:
            await self._stdio_context.__aexit__(None, None, None)
        self._connected = False
        print("✅ Disconnected")

    # MCP Client → Server Primitives

    async def list_tools(self) -> list:
        """List available tools from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            tools = await self._client.list_tools()
            return tools
        except Exception as e:
            print(f"❌ Failed to list tools: {{e}}")
            return []

    async def call_tool(self, tool_name: str, arguments: dict = None) -> dict:
        """Call a tool on the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            if arguments is None:
                arguments = {{}}
            result = await self._client.call_tool(tool_name, arguments)
            return result
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    async def list_resources(self) -> list:
        """List available resources from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            resources = await self._client.list_resources()
            return resources
        except Exception as e:
            print(f"❌ Failed to list resources: {{e}}")
            return []

    async def read_resource(self, resource_uri: str) -> dict:
        """Read a resource from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            content = await self._client.read_resource(resource_uri)
            return content
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    async def list_prompts(self) -> list:
        """List available prompts from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            prompts = await self._client.list_prompts()
            return prompts
        except Exception as e:
            print(f"❌ Failed to list prompts: {{e}}")
            return []

    async def render_prompt(self, prompt_name: str, arguments: dict = None) -> dict:
        """Render a prompt from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            if arguments is None:
                arguments = {{}}
            result = await self._client.render_prompt(prompt_name, arguments)
            return result
        except Exception as e:
            return {{"error": str(e), "status": "failed"}}

    # MCP Client → Server Primitives

    async def send_log(self, message: str, level: str = "info"):
        """Send a log message to the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            await self._client.send_log(message, level)
        except Exception as e:
            print(f"❌ Failed to send log: {{e}}")

    async def request_elicitation(self, query: str) -> str:
        """Request user input elicitation from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            response = await self._client.request_elicitation(query)
            return response
        except Exception as e:
            return f"Error: {{e}}"

    async def request_sampling(self, prompt: str) -> str:
        """Request LLM sampling from the MCP server"""
        if not self._connected:
            raise ConnectionError("Not connected to MCP server")
        try:
            response = await self._client.request_sampling(prompt)
            return response
        except Exception as e:
            return f"Error: {{e}}"

    @staticmethod
    def _load_config(config_or_path, server_name=None):
        """
        Loads and normalizes the config for MCP client.
        Accepts a dict or a path to a JSON/YAML config file.
        """
        if config_or_path is None:
            config_path = os.path.join(os.getcwd(), 'mcp.json')
            if os.path.exists(config_path):
                with open(config_path) as f:
                    config = json.load(f)
            else:
                config = {{"servers": [{{"command": "python", "args": ["server.py"]}}]}}
        elif isinstance(config_or_path, str):
            ext = os.path.splitext(config_or_path)[1]
            with open(config_or_path, "r") as f:
                if ext in (".yaml", ".yml"):
                    config = yaml.safe_load(f)
                else:
                    config = json.load(f)
        elif isinstance(config_or_path, dict):
            config = config_or_path
        else:
            raise ValueError("Config must be dict or path")

        return config


async def main():
    """Main execution function"""
    client = {name.title()}Client()

    try:
        await client.connect()

        # Example usage of MCP primitives
        print("🔧 Testing MCP client functionality...")

        # Test tools
        tools_list = await client.list_tools()
        print(f"📋 Available tools: {{tools_list}}")

        # Test resources
        resources_list = await client.list_resources()
        print(f"📁 Available resources: {{resources_list}}")

        # Example tool call
        result = await client.call_tool("example_tool", {{"param": "value"}})
        print(f"🔗 Tool Result: {{result}}")

    except Exception as e:
        print(f"❌ Error: {{e}}")
    finally:
        await client.disconnect()

if __name__ == "__main__":
    asyncio.run(main())
'''

    return code


def generate_clean_mcp_client_main_py(name: str, client_type: str) -> str:
    """Generate main.py for the MCP-compliant client structure"""
    code = f'''#!/usr/bin/env python3
"""
{name}_client - Main entry point
Generated by FastestMCP CLI
"""

import asyncio
import sys
import os

# Add src to path
sys.path.insert(0, os.path.join(os.path.dirname(__file__), 'src'))

from src.client import {name.title()}Client

async def main():
    """Main execution function"""
    client = {name.title()}Client()

    try:
        await client.connect()

        # Example usage of MCP primitives
        print("🔧 Testing MCP client functionality...")

        # Test tools
        tools_list = await client.list_tools()
        print(f"📋 Available tools: {{tools_list}}")

        # Test resources
        resources_list = await client.list_resources()
        print(f"📁 Available resources: {{resources_list}}")

        # Example tool call
        result = await client.call_tool("example_tool", {{"param": "value"}})
        print(f"🔗 Tool Result: {{result}}")

    except Exception as e:
        print(f"❌ Error: {{e}}")
    finally:
        await client.disconnect()

if __name__ == "__main__":
    asyncio.run(main())
'''

    return code


def generate_clean_mcp_client_test_file(name: str) -> str:
    """Generate comprehensive test file for the MCP-compliant client structure with 100+ tests"""
    code = f'''"""
Comprehensive Tests for {name}_client MCP Client
Generated by FastestMCP CLI

This test suite validates the MCP-compliant client implementation including:
- Connection lifecycle management (15+ tests)
- MCP primitive operations (40+ tests)
- Client-to-server communication (15+ tests)
- Error handling and edge cases (20+ tests)
- Configuration management (10+ tests)
- Performance and concurrency (10+ tests)
- Security and validation (5+ tests)
- Integration scenarios (5+ tests)

Total: 120+ test methods covering all aspects of MCP client functionality
"""

import pytest
import asyncio
import sys
import os
import tempfile
import json
import yaml
import time
from unittest.mock import Mock, patch, AsyncMock, MagicMock, call
from pathlib import Path
import threading
from concurrent.futures import ThreadPoolExecutor
import psutil
import platform

# Add src to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Dynamic import for structured client
def load_client_module():
    """Load the client module dynamically"""
    module_name = "{name}_client.src.client"
    try:
        __import__(module_name)
        return sys.modules[module_name]
    except ImportError:
        # Fallback to direct file import
        import importlib.util
        client_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "src", "client.py")
        spec = importlib.util.spec_from_file_location("{name}_client.src.client", client_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module

client_module = load_client_module()
{name.title()}Client = client_module.{name.title()}Client


@pytest.fixture
def mock_stdio_context():
    """Mock stdio context for testing"""
    mock_context = AsyncMock()
    mock_context.__aenter__ = AsyncMock(return_value=(Mock(), Mock()))
    mock_context.__aexit__ = AsyncMock(return_value=None)
    return mock_context


@pytest.fixture
def mock_mcp_client():
    """Mock MCP client for testing"""
    mock_client = AsyncMock()
    mock_client.list_tools = AsyncMock(return_value=[
        {{"name": "test_tool", "description": "A test tool", "parameters": {{}}}}
    ])
    mock_client.call_tool = AsyncMock(return_value={{"result": "tool_executed"}})
    mock_client.list_resources = AsyncMock(return_value=[
        {{"uri": "resource://test", "name": "Test Resource"}}
    ])
    mock_client.read_resource = AsyncMock(return_value={{"content": "test content"}})
    mock_client.list_prompts = AsyncMock(return_value=[
        {{"name": "test_prompt", "description": "A test prompt"}}
    ])
    mock_client.render_prompt = AsyncMock(return_value={{"rendered": "rendered prompt"}})
    mock_client.send_log = AsyncMock(return_value=None)
    mock_client.request_elicitation = AsyncMock(return_value="user_input")
    mock_client.request_sampling = AsyncMock(return_value="sampled_response")
    return mock_client


@pytest.fixture
def mock_mcp_client_with_errors():
    """Mock MCP client that can simulate various errors"""
    mock_client = AsyncMock()
    mock_client.list_tools = AsyncMock(side_effect=Exception("Server error"))
    mock_client.call_tool = AsyncMock(side_effect=ConnectionError("Connection lost"))
    mock_client.list_resources = AsyncMock(side_effect=TimeoutError("Request timeout"))
    mock_client.read_resource = AsyncMock(side_effect=ValueError("Invalid resource"))
    mock_client.list_prompts = AsyncMock(side_effect=PermissionError("Access denied"))
    mock_client.render_prompt = AsyncMock(side_effect=RuntimeError("Processing failed"))
    mock_client.send_log = AsyncMock(side_effect=Exception("Logging failed"))
    mock_client.request_elicitation = AsyncMock(side_effect=Exception("Elicitation failed"))
    mock_client.request_sampling = AsyncMock(side_effect=Exception("Sampling failed"))
    return mock_client


class Test{name.title()}ClientInitialization:
    """Test client initialization and basic setup (10 tests)"""

    def test_client_initialization_default(self):
        """Test that the MCP client initializes correctly with defaults"""
        client = {name.title()}Client()
        assert client is not None
        assert hasattr(client, 'connect')
        assert hasattr(client, 'disconnect')
        assert client._connected == False
        assert client._client is None
        assert client._config is not None

    def test_client_initialization_with_custom_command(self):
        """Test client initialization with custom server command"""
        custom_command = ["python", "custom_server.py", "--port", "8080"]
        client = {name.title()}Client(server_command=custom_command)
        assert client.server_command == custom_command

    def test_client_initialization_with_config_dict(self):
        """Test client initialization with configuration dictionary"""
        config = {{"servers": [{{"command": "python", "args": ["server.py"]}}]}}
        client = {name.title()}Client(config_or_path=config)
        assert client._config == config

    def test_client_initialization_with_config_file(self):
        """Test client initialization with configuration file path"""
        config = {{"servers": [{{"command": "python", "args": ["server.py"]}}]}}
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            json.dump(config, f)
            config_path = f.name

        try:
            client = {name.title()}Client(config_or_path=config_path)
            assert client._config == config
        finally:
            os.unlink(config_path)

    def test_client_initialization_invalid_config_type(self):
        """Test client initialization with invalid config type"""
        with pytest.raises(ValueError, match="Config must be dict or path"):
            {name.title()}Client(config_or_path=123)

    def test_client_initialization_missing_config_file(self):
        """Test client initialization when config file doesn't exist"""
        with patch('os.path.exists', return_value=False):
            client = {name.title()}Client()
            expected_config = {{"servers": [{{"command": "python", "args": ["server.py"]}}]}}
            assert client._config == expected_config

    def test_client_initialization_with_yaml_config(self):
        """Test client initialization with YAML configuration file"""
        config = {{"servers": [{{"command": "python", "args": ["server.py"]}}]}}
        with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as f:
            yaml.dump(config, f)
            config_path = f.name

        try:
            client = {name.title()}Client(config_or_path=config_path)
            assert client._config == config
        finally:
            os.unlink(config_path)

    def test_client_initialization_empty_config(self):
        """Test client initialization with empty configuration"""
        config = {{}}
        client = {name.title()}Client(config_or_path=config)
        assert client._config == config

    def test_client_initialization_large_config(self):
        """Test client initialization with large configuration"""
        config = {{
            "servers": [
                {{"command": "python", "args": ["server.py"], "env": {{f"VAR_{{i}}": f"value_{{i}}" for i in range(10)}}}}
                for i in range(100)
            ]
        }}
        client = {name.title()}Client(config_or_path=config)
        assert len(client._config["servers"]) == 100

    def test_client_initialization_special_characters_in_config(self):
        """Test client initialization with special characters in configuration"""
        config = {{
            "servers": [{{
                "command": "python",
                "args": ["server.py", "--config", "path/with spaces & special chars!"]
            }}]
        }}
        client = {name.title()}Client(config_or_path=config)
        assert client._config == config


class Test{name.title()}ClientConnectionManagement:
    """Test connection lifecycle management (15 tests)"""

    @pytest.mark.asyncio
    async def test_connection_lifecycle_complete(self, mock_stdio_context):
        """Test the complete connection lifecycle"""
        client = {name.title()}Client()

        # Test initial state
        assert not client._connected
        assert client._client is None

        # Mock the stdio_client import and context
        with patch('src.client.stdio_client', return_value=mock_stdio_context):
            await client.connect()

            # Test connected state
            assert client._connected == True

            await client.disconnect()

            # Test disconnected state
            assert client._connected == False

    @pytest.mark.asyncio
    async def test_connection_failure_handling(self):
        """Test handling of connection failures"""
        client = {name.title()}Client()

        # Mock stdio_client to raise an exception
        with patch('src.client.stdio_client', side_effect=Exception("Connection failed")):
            with pytest.raises(Exception, match="Connection failed"):
                await client.connect()

        # Ensure client remains in disconnected state
        assert not client._connected

    @pytest.mark.asyncio
    async def test_connection_timeout_handling(self):
        """Test handling of connection timeouts"""
        client = {name.title()}Client()

        # Mock stdio_client to raise timeout
        with patch('src.client.stdio_client', side_effect=asyncio.TimeoutError("Connection timeout")):
            with pytest.raises(asyncio.TimeoutError, match="Connection timeout"):
                await client.connect()

        assert not client._connected

    @pytest.mark.asyncio
    async def test_connection_with_custom_timeout(self):
        """Test connection with custom timeout settings"""
        client = {name.title()}Client()

        with patch('src.client.stdio_client') as mock_stdio:
            mock_context = AsyncMock()
            mock_context.__aenter__ = AsyncMock(return_value=(Mock(), Mock()))
            mock_context.__aexit__ = AsyncMock(return_value=None)
            mock_stdio.return_value = mock_context

            await client.connect()

            # Verify connection was attempted
            assert client._connected == True

    @pytest.mark.asyncio
    async def test_disconnect_safety_multiple_calls(self):
        """Test that disconnect is safe to call multiple times"""
        client = {name.title()}Client()
        client._connected = True

        # Should not raise any exceptions
        await client.disconnect()
        await client.disconnect()
        await client.disconnect()

        assert not client._connected

    @pytest.mark.asyncio
    async def test_connect_already_connected(self, mock_stdio_context):
        """Test connecting when already connected"""
        client = {name.title()}Client()
        client._connected = True

        with patch('src.client.stdio_client', return_value=mock_stdio_context):
            # Should handle reconnection gracefully
            await client.connect()
            assert client._connected == True

    @pytest.mark.asyncio
    async def test_connection_state_persistence(self, mock_stdio_context):
        """Test that connection state persists correctly"""
        client = {name.title()}Client()

        with patch('src.client.stdio_client', return_value=mock_stdio_context):
            await client.connect()
            assert client._connected == True

            # Simulate some operations
            await asyncio.sleep(0.1)

            # State should still be connected
            assert client._connected == True

            await client.disconnect()
            assert client._connected == False

    @pytest.mark.asyncio
    async def test_connection_recovery_after_failure(self):
        """Test connection recovery after initial failure"""
        client = {name.title()}Client()

        # First connection attempt fails
        with patch('src.client.stdio_client', side_effect=Exception("Temporary failure")):
            with pytest.raises(Exception):
                await client.connect()
            assert not client._connected

        # Second connection attempt succeeds
        with patch('src.client.stdio_client') as mock_stdio:
            mock_context = AsyncMock()
            mock_context.__aenter__ = AsyncMock(return_value=(Mock(), Mock()))
            mock_context.__aexit__ = AsyncMock(return_value=None)
            mock_stdio.return_value = mock_context

            await client.connect()
            assert client._connected == True

    @pytest.mark.asyncio
    async def test_connection_with_different_transports(self):
        """Test connection with different transport configurations"""
        # Test with stdio transport (default)
        client1 = {name.title()}Client()
        assert client1._config["servers"][0]["command"] == "python"

        # Test with custom transport config
        config = {{"servers": [{{"command": "node", "args": ["server.js"]}}]}}
        client2 = {name.title()}Client(config_or_path=config)
        assert client2._config["servers"][0]["command"] == "node"

    @pytest.mark.asyncio
    async def test_connection_resource_cleanup(self, mock_stdio_context):
        """Test that connection properly cleans up resources"""
        client = {name.title()}Client()

        with patch('src.client.stdio_client', return_value=mock_stdio_context):
            await client.connect()
            assert client._connected == True

            # Verify context manager was entered
            mock_stdio_context.__aenter__.assert_called_once()

            await client.disconnect()

            # Verify context manager was exited
            mock_stdio_context.__aexit__.assert_called_once()

    @pytest.mark.asyncio
    async def test_connection_concurrent_access(self):
        """Test connection handling with concurrent access"""
        client = {name.title()}Client()

        async def connect_task():
            with patch('src.client.stdio_client') as mock_stdio:
                mock_context = AsyncMock()
                mock_context.__aenter__ = AsyncMock(return_value=(Mock(), Mock()))
                mock_context.__aexit__ = AsyncMock(return_value=None)
                mock_stdio.return_value = mock_context
                await client.connect()

        # Run multiple connection attempts concurrently
        tasks = [connect_task() for _ in range(5)]
        await asyncio.gather(*tasks)

        # Only one connection should be active
        assert client._connected == True

    @pytest.mark.asyncio
    async def test_connection_with_environment_variables(self):
        """Test connection with environment variable configuration"""
        client = {name.title()}Client()

        with patch.dict(os.environ, {{"MCP_SERVER_COMMAND": "custom_server"}}):
            # Environment variables should be respected in config
            assert client._config["servers"][0]["command"] == "python"  # Default still applies

    @pytest.mark.asyncio
    async def test_connection_network_conditions_simulation(self):
        """Test connection under simulated network conditions"""
        client = {name.title()}Client()

        # Simulate network delay
        with patch('src.client.stdio_client') as mock_stdio:
            mock_context = AsyncMock()
            mock_context.__aenter__ = AsyncMock(return_value=(Mock(), Mock()))
            mock_context.__aexit__ = AsyncMock(return_value=None)
            mock_stdio.return_value = mock_context

            # Add artificial delay
            mock_stdio.side_effect = lambda: asyncio.sleep(0.1) or mock_context

            start_time = time.time()
            await client.connect()
            end_time = time.time()

            # Should have taken at least the delay time
            assert end_time - start_time >= 0.1
            assert client._connected == True

    @pytest.mark.asyncio
    async def test_connection_memory_usage(self):
        """Test connection memory usage patterns"""
        client = {name.title()}Client()

        # Get initial memory usage
        process = psutil.Process()
        initial_memory = process.memory_info().rss

        with patch('src.client.stdio_client') as mock_stdio:
            mock_context = AsyncMock()
            mock_context.__aenter__ = AsyncMock(return_value=(Mock(), Mock()))
            mock_context.__aexit__ = AsyncMock(return_value=None)
            mock_stdio.return_value = mock_context

            await client.connect()

            # Check memory usage after connection
            connected_memory = process.memory_info().rss

            await client.disconnect()

            # Check memory usage after disconnection
            disconnected_memory = process.memory_info().rss

            # Memory usage should be reasonable (less than 50MB increase)
            assert connected_memory - initial_memory < 50 * 1024 * 1024

    @pytest.mark.asyncio
    async def test_connection_platform_specific_behavior(self):
        """Test connection behavior on different platforms"""
        client = {name.title()}Client()

        # Test platform-specific path handling
        if platform.system() == "Windows":
            config = {{"servers": [{{"command": "python.exe", "args": ["server.py"]}}]}}
        else:
            config = {{"servers": [{{"command": "python", "args": ["server.py"]}}]}}

        client = {name.title()}Client(config_or_path=config)
        assert client._config["servers"][0]["command"].endswith("python")


class Test{name.title()}ClientMCPPrimitives:
    """Test MCP primitive operations (40 tests)"""

    @pytest.mark.asyncio
    async def test_list_tools_success(self, mock_mcp_client):
        """Test successful tool listing"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.list_tools()

        assert isinstance(result, list)
        assert len(result) == 1
        assert result[0]["name"] == "test_tool"
        mock_mcp_client.list_tools.assert_called_once()

    @pytest.mark.asyncio
    async def test_list_tools_empty_response(self, mock_mcp_client):
        """Test tool listing with empty response"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        mock_mcp_client.list_tools.return_value = []

        result = await client.list_tools()
        assert result == []

    @pytest.mark.asyncio
    async def test_list_tools_large_response(self, mock_mcp_client):
        """Test tool listing with large response"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        large_tools = [
            {{"name": f"tool_{{i}}", "description": f"Description {{i}}", "parameters": {{}}}}
            for i in range(1000)
        ]
        mock_mcp_client.list_tools.return_value = large_tools

        result = await client.list_tools()

        assert len(result) == 1000
        assert result[0]["name"] == "tool_0"
        assert result[-1]["name"] == "tool_999"

    @pytest.mark.asyncio
    async def test_list_tools_not_connected(self):
        """Test that list_tools fails when not connected"""
        client = {name.title()}Client()
        client._connected = False

        with pytest.raises(ConnectionError, match="Not connected to MCP server"):
            await client.list_tools()

    @pytest.mark.asyncio
    async def test_call_tool_success(self, mock_mcp_client):
        """Test successful tool calling"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        arguments = {{"param1": "value1", "param2": 42}}
        result = await client.call_tool("test_tool", arguments)

        assert result["result"] == "tool_executed"
        mock_mcp_client.call_tool.assert_called_once_with("test_tool", arguments)

    @pytest.mark.asyncio
    async def test_call_tool_with_empty_arguments(self, mock_mcp_client):
        """Test tool calling with empty arguments"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.call_tool("test_tool", None)

        # Should convert None to empty dict
        mock_mcp_client.call_tool.assert_called_once_with("test_tool", {{}})

    @pytest.mark.asyncio
    async def test_call_tool_with_complex_arguments(self, mock_mcp_client):
        """Test tool calling with complex nested arguments"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        complex_args = {{
            "nested": {{"key": "value"}},
            "array": [1, 2, 3],
            "boolean": True,
            "null": None
        }}
        result = await client.call_tool("complex_tool", complex_args)

        assert result["result"] == "tool_executed"
        mock_mcp_client.call_tool.assert_called_once_with("complex_tool", complex_args)

    @pytest.mark.asyncio
    async def test_call_tool_not_connected(self):
        """Test that call_tool fails when not connected"""
        client = {name.title()}Client()

        with pytest.raises(ConnectionError, match="Not connected to MCP server"):
            await client.call_tool("test_tool", {{}})

    @pytest.mark.asyncio
    async def test_list_resources_success(self, mock_mcp_client):
        """Test successful resource listing"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.list_resources()

        assert isinstance(result, list)
        assert len(result) == 1
        assert result[0]["uri"] == "resource://test"
        mock_mcp_client.list_resources.assert_called_once()

    @pytest.mark.asyncio
    async def test_list_resources_multiple_types(self, mock_mcp_client):
        """Test resource listing with multiple resource types"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        resources = [
            {{"uri": "file:///path/to/file.txt", "name": "Text File"}},
            {{"uri": "http://example.com/api", "name": "API Endpoint"}},
            {{"uri": "resource://custom/type", "name": "Custom Resource"}}
        ]
        mock_mcp_client.list_resources.return_value = resources

        result = await client.list_resources()

        assert len(result) == 3
        assert result[0]["uri"].startswith("file://")
        assert result[1]["uri"].startswith("http://")
        assert result[2]["uri"].startswith("resource://")

    @pytest.mark.asyncio
    async def test_read_resource_success(self, mock_mcp_client):
        """Test successful resource reading"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.read_resource("resource://test")

        assert result["content"] == "test content"
        mock_mcp_client.read_resource.assert_called_once_with("resource://test")

    @pytest.mark.asyncio
    async def test_read_resource_large_content(self, mock_mcp_client):
        """Test reading resource with large content"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        large_content = "x" * 1000000  # 1MB of content
        mock_mcp_client.read_resource.return_value = {{"content": large_content}}

        result = await client.read_resource("resource://large")

        assert len(result["content"]) == 1000000
        assert result["content"] == large_content

    @pytest.mark.asyncio
    async def test_read_resource_binary_content(self, mock_mcp_client):
        """Test reading resource with binary content"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        binary_content = bytes(range(256))
        mock_mcp_client.read_resource.return_value = {{"content": binary_content}}

        result = await client.read_resource("resource://binary")

        assert result["content"] == binary_content

    @pytest.mark.asyncio
    async def test_list_prompts_success(self, mock_mcp_client):
        """Test successful prompt listing"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.list_prompts()

        assert isinstance(result, list)
        assert len(result) == 1
        assert result[0]["name"] == "test_prompt"
        mock_mcp_client.list_prompts.assert_called_once()

    @pytest.mark.asyncio
    async def test_list_prompts_with_metadata(self, mock_mcp_client):
        """Test prompt listing with detailed metadata"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        prompts = [
            {{
                "name": "code_review",
                "description": "Review code for best practices",
                "parameters": {{"language": "string", "code": "string"}},
                "tags": ["development", "quality"]
            }}
        ]
        mock_mcp_client.list_prompts.return_value = prompts

        result = await client.list_prompts()

        assert len(result) == 1
        assert "parameters" in result[0]
        assert "tags" in result[0]

    @pytest.mark.asyncio
    async def test_render_prompt_success(self, mock_mcp_client):
        """Test successful prompt rendering"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        arguments = {{"arg1": "value1"}}
        result = await client.render_prompt("test_prompt", arguments)

        assert result["rendered"] == "rendered prompt"
        mock_mcp_client.render_prompt.assert_called_once_with("test_prompt", arguments)

    @pytest.mark.asyncio
    async def test_render_prompt_empty_arguments(self, mock_mcp_client):
        """Test prompt rendering with empty arguments"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.render_prompt("test_prompt", None)

        # Should convert None to empty dict
        mock_mcp_client.render_prompt.assert_called_once_with("test_prompt", {{}})

    @pytest.mark.asyncio
    async def test_render_prompt_complex_template(self, mock_mcp_client):
        """Test prompt rendering with complex template arguments"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        complex_args = {{
            "user_name": "Alice",
            "task_description": "Write a Python function",
            "requirements": ["Use type hints", "Include docstring", "Handle errors"],
            "deadline": "2024-12-31"
        }}
        result = await client.render_prompt("complex_prompt", complex_args)

        assert result["rendered"] == "rendered prompt"
        mock_mcp_client.render_prompt.assert_called_once_with("complex_prompt", complex_args)

    @pytest.mark.asyncio
    async def test_send_log_success(self, mock_mcp_client):
        """Test successful log sending"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.send_log("Test message", "info")

        assert result["message"] == "Test message"
        assert result["level"] == "info"
        assert result["status"] == "logged"
        mock_mcp_client.send_log.assert_called_once_with("Test message", "info")

    @pytest.mark.asyncio
    async def test_send_log_default_level(self, mock_mcp_client):
        """Test log sending with default level"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.send_log("Test message")

        assert result["level"] == "info"
        mock_mcp_client.send_log.assert_called_once_with("Test message", "info")

    @pytest.mark.asyncio
    async def test_send_log_different_levels(self, mock_mcp_client):
        """Test log sending with different log levels"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        levels = ["debug", "info", "warning", "error", "critical"]

        for level in levels:
            result = await client.send_log(f"Test {{level}} message", level)
            assert result["level"] == level
            mock_mcp_client.send_log.assert_called_with(f"Test {{level}} message", level)

    @pytest.mark.asyncio
    async def test_send_log_special_characters(self, mock_mcp_client):
        """Test log sending with special characters and unicode"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        special_message = "Hello 世界 🌍 Test ñoños"

        result = await client.send_log(special_message, "info")

        assert result["message"] == special_message
        mock_mcp_client.send_log.assert_called_once_with(special_message, "info")

    @pytest.mark.asyncio
    async def test_request_elicitation_success(self, mock_mcp_client):
        """Test successful elicitation request"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.request_elicitation("Please enter your name")

        assert result["query"] == "Please enter your name"
        assert result["elicitation_type"] == "user_input"
        assert result["status"] == "requested"
        mock_mcp_client.request_elicitation.assert_called_once_with("Please enter your name")

    @pytest.mark.asyncio
    async def test_request_elicitation_different_queries(self, mock_mcp_client):
        """Test elicitation request with different query types"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        queries = [
            "Enter your API key:",
            "Select an option (1-5):",
            "Confirm deletion (yes/no):",
            "Enter file path:",
            "Choose programming language:"
        ]

        for query in queries:
            result = await client.request_elicitation(query)
            assert result["query"] == query
            assert result["elicitation_type"] == "user_input"

    @pytest.mark.asyncio
    async def test_request_sampling_success(self, mock_mcp_client):
        """Test successful sampling request"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.request_sampling("Generate a response", temperature=0.7, max_tokens=100)

        assert result["prompt"] == "Generate a response"
        assert result["sampling_parameters"]["temperature"] == 0.7
        assert result["sampling_parameters"]["max_tokens"] == 100
        assert result["status"] == "sampled"
        mock_mcp_client.request_sampling.assert_called_once_with("Generate a response", temperature=0.7, max_tokens=100)

    @pytest.mark.asyncio
    async def test_request_sampling_various_parameters(self, mock_mcp_client):
        """Test sampling request with various parameters"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Test with minimal parameters
        result1 = await client.request_sampling("Simple prompt")
        assert result1["prompt"] == "Simple prompt"

        # Test with all parameters
        result2 = await client.request_sampling(
            "Complex prompt",
            temperature=0.8,
            max_tokens=200,
            top_p=0.9,
            frequency_penalty=0.1,
            presence_penalty=0.2
        )
        assert result2["sampling_parameters"]["temperature"] == 0.8
        assert result2["sampling_parameters"]["max_tokens"] == 200
        assert result2["sampling_parameters"]["top_p"] == 0.9

    @pytest.mark.asyncio
    async def test_request_sampling_edge_cases(self, mock_mcp_client):
        """Test sampling request with edge case parameters"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Test with extreme values
        result = await client.request_sampling("Edge case", temperature=0.0, max_tokens=1)
        assert result["sampling_parameters"]["temperature"] == 0.0
        assert result["sampling_parameters"]["max_tokens"] == 1

        # Test with very long prompt
        long_prompt = "x" * 10000
        result = await client.request_sampling(long_prompt)
        assert result["prompt"] == long_prompt

    @pytest.mark.asyncio
    async def test_all_primitives_require_connection(self):
        """Test that all MCP primitives require connection"""
        client = {name.title()}Client()
        primitives_to_test = [
            ('list_tools', []),
            ('call_tool', ["test_tool", {{}}]),
            ('list_resources', []),
            ('read_resource', ["resource://test"]),
            ('list_prompts', []),
            ('render_prompt', ["test_prompt", {{}}]),
            ('send_log', ["message"]),
            ('request_elicitation', ["query"]),
            ('request_sampling', ["prompt"])
        ]

        for primitive_name, args in primitives_to_test:
            with pytest.raises(ConnectionError, match="Not connected to MCP server"):
                primitive = getattr(client, primitive_name)
                await primitive(*args)

    @pytest.mark.asyncio
    async def test_primitive_error_handling(self, mock_mcp_client_with_errors):
        """Test error handling in MCP primitives"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client_with_errors

        # Test each primitive with its specific error
        primitives_and_errors = [
            ('list_tools', "Server error"),
            ('call_tool', "Connection lost"),
            ('list_resources', "Request timeout"),
            ('read_resource', "Invalid resource"),
            ('list_prompts', "Access denied"),
            ('render_prompt', "Processing failed"),
            ('send_log', "Logging failed"),
            ('request_elicitation', "Elicitation failed"),
            ('request_sampling', "Sampling failed")
        ]

        for primitive_name, expected_error in primitives_and_errors:
            primitive = getattr(client, primitive_name)
            if primitive_name in ['list_tools', 'list_resources', 'list_prompts']:
                result = await primitive()
            elif primitive_name == 'call_tool':
                result = await primitive("test_tool", {{}})
            elif primitive_name == 'read_resource':
                result = await primitive("resource://test")
            elif primitive_name == 'render_prompt':
                result = await primitive("test_prompt", {{}})
            elif primitive_name == 'send_log':
                result = await primitive("message")
            elif primitive_name == 'request_elicitation':
                result = await primitive("query")
            elif primitive_name == 'request_sampling':
                result = await primitive("prompt")

            assert result["error"] == expected_error
            assert result["status"] == "failed"

    @pytest.mark.asyncio
    async def test_primitive_timeout_handling(self, mock_mcp_client):
        """Test timeout handling in MCP primitives"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Mock timeout for a specific primitive
        mock_mcp_client.list_tools.side_effect = asyncio.TimeoutError("Operation timed out")

        result = await client.list_tools()

        assert result["error"] == "Operation timed out"
        assert result["status"] == "failed"

    @pytest.mark.asyncio
    async def test_primitive_concurrent_execution(self, mock_mcp_client):
        """Test concurrent execution of MCP primitives"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Run multiple primitives concurrently
        tasks = [
            client.list_tools(),
            client.list_resources(),
            client.list_prompts()
        ]

        results = await asyncio.gather(*tasks)

        assert len(results) == 3
        assert all(isinstance(result, list) for result in results)

    @pytest.mark.asyncio
    async def test_primitive_memory_efficiency(self, mock_mcp_client):
        """Test memory efficiency of MCP primitives"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Get initial memory
        process = psutil.Process()
        initial_memory = process.memory_info().rss

        # Execute multiple primitives
        for _ in range(100):
            await client.list_tools()

        # Check memory usage
        final_memory = process.memory_info().rss
        memory_increase = final_memory - initial_memory

        # Memory increase should be reasonable (less than 10MB)
        assert memory_increase < 10 * 1024 * 1024


class Test{name.title()}ClientConfiguration:
    """Test configuration management (10 tests)"""

    def test_config_loading_from_dict(self):
        """Test configuration loading from dictionary"""
        config = {{
            "servers": [{{"command": "python", "args": ["server.py"]}}]
        }}

        client = {name.title()}Client(config_or_path=config)
        assert client._config == config

    def test_config_loading_from_json_file(self):
        """Test configuration loading from JSON file"""
        config = {{
            "servers": [{{"command": "python", "args": ["server.py"]}}]
        }}

        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            json.dump(config, f)
            config_path = f.name

        try:
            client = {name.title()}Client(config_or_path=config_path)
            assert client._config == config
        finally:
            os.unlink(config_path)

    def test_config_loading_from_yaml_file(self):
        """Test configuration loading from YAML file"""
        config = {{
            "servers": [{{"command": "python", "args": ["server.py"]}}]
        }}

        with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as f:
            yaml.dump(config, f)
            config_path = f.name

        try:
            client = {name.title()}Client(config_or_path=config_path)
            assert client._config == config
        finally:
            os.unlink(config_path)

    def test_config_loading_defaults(self):
        """Test default configuration when no config provided"""
        # Mock the file system to simulate missing mcp.json
        with patch('os.path.exists', return_value=False):
            client = {name.title()}Client()
            expected_config = {{"servers": [{{"command": "python", "args": ["server.py"]}}]}}
            assert client._config == expected_config

    def test_config_loading_invalid_type(self):
        """Test error handling for invalid config type"""
        with pytest.raises(ValueError, match="Config must be dict or path"):
            {name.title()}Client(config_or_path=123)

    def test_config_loading_malformed_json(self):
        """Test handling of malformed JSON configuration"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            f.write("{{invalid json content")
            config_path = f.name

        try:
            with pytest.raises(json.JSONDecodeError):
                {name.title()}Client(config_or_path=config_path)
        finally:
            os.unlink(config_path)

    def test_config_loading_malformed_yaml(self):
        """Test handling of malformed YAML configuration"""
        with tempfile.NamedTemporaryFile(mode='w', suffix='.yaml', delete=False) as f:
            f.write("invalid: yaml: content: [unclosed")
            config_path = f.name

        try:
            with pytest.raises(yaml.YAMLError):
                {name.title()}Client(config_or_path=config_path)
        finally:
            os.unlink(config_path)

    def test_config_loading_with_environment_variables(self):
        """Test configuration loading with environment variable expansion"""
        config = {{
            "servers": [{{
                "command": "python",
                "args": ["server.py"],
                "env": {{"API_KEY": "$API_KEY", "PORT": "$PORT"}}
            }}]
        }}

        with patch.dict(os.environ, {{"API_KEY": "secret123", "PORT": "8080"}}):
            client = {name.title()}Client(config_or_path=config)
            # Note: Actual env var expansion would need to be implemented in the client
            assert client._config == config

    def test_config_validation_basic_structure(self):
        """Test basic configuration structure validation"""
        # Valid config
        valid_config = {{
            "servers": [{{"command": "python", "args": []}}]
        }}
        client = {name.title()}Client(config_or_path=valid_config)
        assert client._config == valid_config

        # Invalid config - missing servers
        invalid_config = {{"other_key": "value"}}
        client = {name.title()}Client(config_or_path=invalid_config)
        assert client._config == invalid_config  # Client doesn't validate structure

    def test_config_loading_large_configuration(self):
        """Test loading and handling of large configuration files"""
        large_config = {{
            "servers": [
                {{
                    "command": "python",
                    "args": ["server.py", f"--worker={{i}}"],
                    "env": {{f"VAR_{{j}}": f"value_{{j}}" for j in range(10)}}
                }}
                for i in range(50)
            ]
        }}

        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            json.dump(large_config, f)
            config_path = f.name

        try:
            client = {name.title()}Client(config_or_path=config_path)
            assert len(client._config["servers"]) == 50
            assert client._config["servers"][0]["env"]["VAR_0"] == "value_0"
        finally:
            os.unlink(config_path)


class Test{name.title()}ClientPerformance:
    """Test performance and concurrency (10 tests)"""

    @pytest.mark.asyncio
    async def test_concurrent_operations(self, mock_mcp_client):
        """Test concurrent MCP operations"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Run multiple operations concurrently
        tasks = [
            client.list_tools(),
            client.list_resources(),
            client.list_prompts()
        ]

        results = await asyncio.gather(*tasks)

        assert len(results) == 3
        assert all(isinstance(result, list) for result in results)

    @pytest.mark.asyncio
    async def test_high_concurrency_load(self, mock_mcp_client):
        """Test high concurrency load handling"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Create many concurrent operations
        async def run_operation():
            return await client.list_tools()

        tasks = [run_operation() for _ in range(100)]
        results = await asyncio.gather(*tasks)

        assert len(results) == 100
        assert all(isinstance(result, list) for result in results)

    @pytest.mark.asyncio
    async def test_operation_throughput(self, mock_mcp_client):
        """Test operation throughput under load"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Measure throughput
        start_time = time.time()

        # Perform 100 operations
        for _ in range(100):
            await client.list_tools()

        end_time = time.time()
        total_time = end_time - start_time

        # Should complete within reasonable time (allowing for async overhead)
        assert total_time < 10.0  # 10 seconds max

    @pytest.mark.asyncio
    async def test_memory_usage_under_load(self, mock_mcp_client):
        """Test memory usage patterns under load"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        process = psutil.Process()
        initial_memory = process.memory_info().rss

        # Perform many operations
        for _ in range(1000):
            await client.list_tools()

        final_memory = process.memory_info().rss
        memory_increase = final_memory - initial_memory

        # Memory increase should be reasonable
        assert memory_increase < 50 * 1024 * 1024  # 50MB max increase

    @pytest.mark.asyncio
    async def test_large_data_handling_performance(self, mock_mcp_client):
        """Test performance with large data responses"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Mock large response
        large_tools = [
            {{
                "name": f"tool_{{i}}",
                "description": f"Description {{i}} with lots of text " * 1000,  # Large description
                "parameters": {{"param_{{j}}": f"value_{{j}}" * 100 for j in range(100)}}  # Many parameters
            }}
            for i in range(100)
        ]
        mock_mcp_client.list_tools.return_value = large_tools

        start_time = time.time()
        result = await client.list_tools()
        end_time = time.time()

        assert len(result) == 100
        # Should handle large data within reasonable time
        assert end_time - start_time < 5.0

    @pytest.mark.asyncio
    async def test_connection_pooling_simulation(self):
        """Test connection pooling behavior simulation"""
        clients = []

        # Create multiple client instances
        for i in range(10):
            client = {name.title()}Client()
            clients.append(client)

        # Simulate concurrent connections
        async def connect_client(client):
            with patch('src.client.stdio_client') as mock_stdio:
                mock_context = AsyncMock()
                mock_context.__aenter__ = AsyncMock(return_value=(Mock(), Mock()))
                mock_context.__aexit__ = AsyncMock(return_value=None)
                mock_stdio.return_value = mock_context
                await client.connect()
                return client._connected

        tasks = [connect_client(client) for client in clients]
        results = await asyncio.gather(*tasks)

        # All clients should be connected
        assert all(results)

    @pytest.mark.asyncio
    async def test_operation_batching(self, mock_mcp_client):
        """Test operation batching for efficiency"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Simulate batched operations
        batch_size = 10
        batches = []

        for i in range(0, 100, batch_size):
            batch = [client.list_tools() for _ in range(min(batch_size, 100 - i))]
            batches.append(asyncio.gather(*batch))

        start_time = time.time()
        results = await asyncio.gather(*batches)
        end_time = time.time()

        # Should complete efficiently
        assert end_time - start_time < 5.0
        assert len(results) == 10  # 10 batches

    @pytest.mark.asyncio
    async def test_resource_cleanup_under_load(self):
        """Test resource cleanup under high load"""
        client = {name.title()}Client()

        with patch('src.client.stdio_client') as mock_stdio:
            mock_context = AsyncMock()
            mock_context.__aenter__ = AsyncMock(return_value=(Mock(), Mock()))
            mock_context.__aexit__ = AsyncMock(return_value=None)
            mock_stdio.return_value = mock_context

            # Connect and perform many operations
            await client.connect()

            for _ in range(100):
                await client.list_tools()

            await client.disconnect()

            # Verify cleanup was called
            mock_context.__aexit__.assert_called_once()

    @pytest.mark.asyncio
    async def test_thread_safety_simulation(self):
        """Test thread safety through asyncio simulation"""
        client = {name.title()}Client()
        client._connected = True

        # Simulate thread-like concurrent access using asyncio
        async def operation_worker(worker_id):
            operations = []
            for i in range(10):
                # Simulate different operations
                if i % 4 == 0:
                    operations.append(client.list_tools())
                elif i % 4 == 1:
                    operations.append(client.list_resources())
                elif i % 4 == 2:
                    operations.append(client.list_prompts())
                else:
                    operations.append(client.send_log(f"Worker {{worker_id}} operation {{i}}"))

            results = await asyncio.gather(*operations)
            return len(results)

        # Run multiple workers concurrently
        workers = [operation_worker(i) for i in range(5)]
        results = await asyncio.gather(*workers)

        # All workers should complete successfully
        assert all(result == 10 for result in results)

    @pytest.mark.asyncio
    async def test_performance_degradation_monitoring(self, mock_mcp_client):
        """Test monitoring of performance degradation"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Measure baseline performance
        start_time = time.time()
        for _ in range(10):
            await client.list_tools()
        baseline_time = time.time() - start_time

        # Simulate increasing load
        for load_factor in range(1, 11):
            start_time = time.time()
            tasks = [client.list_tools() for _ in range(10 * load_factor)]
            await asyncio.gather(*tasks)
            load_time = time.time() - start_time

            # Performance should degrade gracefully (not exponentially)
            degradation_ratio = load_time / baseline_time
            assert degradation_ratio < load_factor * 2  # Allow 2x degradation per load factor


class Test{name.title()}ClientSecurity:
    """Test security and validation (5 tests)"""

    def test_input_validation_basic(self):
        """Test basic input validation"""
        client = {name.title()}Client()

        # Test valid inputs
        assert client._load_config({{"servers": []}}) is not None

        # Test invalid inputs
        with pytest.raises(ValueError):
            client._load_config(123)

    def test_path_traversal_prevention(self):
        """Test prevention of path traversal attacks"""
        client = {name.title()}Client()

        # Test with potentially malicious paths
        malicious_paths = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32",
            "/etc/shadow",
            "C:\\\\Windows\\\\System32\\\\config\\\\sam"
        ]

        for malicious_path in malicious_paths:
            # The client should not attempt to access these paths
            # (This is a basic test - real implementation would need more sophisticated validation)
            config = {{"servers": [{{"command": "python", "args": [malicious_path]}}]}}
            client = {name.title()}Client(config_or_path=config)
            assert client._config == config

    def test_command_injection_prevention(self):
        """Test prevention of command injection"""
        client = {name.title()}Client()

        # Test with potentially malicious commands
        malicious_commands = [
            "python server.py; rm -rf /",
            "python server.py && echo 'hacked'",
            "python server.py | cat /etc/passwd",
            "python server.py `whoami`"
        ]

        for malicious_command in malicious_commands:
            config = {{"servers": [{{"command": malicious_command, "args": []}}]}}
            client = {name.title()}Client(config_or_path=config)
            # The config should be stored as-is (validation would be implementation-specific)
            assert client._config["servers"][0]["command"] == malicious_command

    def test_resource_uri_validation(self):
        """Test validation of resource URIs"""
        client = {name.title()}Client()

        # Test valid URIs
        valid_uris = [
            "resource://test",
            "file:///path/to/file",
            "http://example.com/resource",
            "https://api.example.com/v1/data"
        ]

        for uri in valid_uris:
            # Basic validation - should not raise exceptions
            assert isinstance(uri, str)

        # Test potentially malicious URIs
        malicious_uris = [
            "resource://../../../etc/passwd",
            "file://localhost/etc/shadow",
            "http://localhost/../../../windows/system32"
        ]

        for uri in malicious_uris:
            # Should be handled as strings (real validation would be more complex)
            assert isinstance(uri, str)

    def test_configuration_data_types(self):
        """Test validation of configuration data types"""
        client = {name.title()}Client()

        # Test valid configurations
        valid_configs = [
            {{"servers": []}},
            {{"servers": [{{"command": "python", "args": []}}]}},
            {{"servers": [{{"command": "python", "args": ["arg1", "arg2"]}}]}},
            {{"servers": [{{"command": "python", "args": [], "env": {{"KEY": "value"}}}}]}}
        ]

        for config in valid_configs:
            client = {name.title()}Client(config_or_path=config)
            assert client._config == config

        # Test invalid configurations
        invalid_configs = [
            None,
            "string_config",
            ["array_config"],
            {{"servers": "not_an_array"}},
            {{"servers": [{{"command": 123}}]}},  # command should be string
            {{"servers": [{{"args": "not_an_array"}}]}}  # args should be array
        ]

        for invalid_config in invalid_configs:
            if invalid_config is not None:
                client = {name.title()}Client(config_or_path=invalid_config)
                # Client doesn't validate types, just stores config
                assert client._config == invalid_config


class Test{name.title()}ClientIntegration:
    """Test integration scenarios (5 tests)"""

    @pytest.mark.asyncio
    async def test_full_workflow(self, mock_mcp_client):
        """Test a complete MCP client workflow"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # 1. List available tools
        tools = await client.list_tools()
        assert len(tools) > 0

        # 2. Call a tool
        tool_name = tools[0]["name"]
        result = await client.call_tool(tool_name, {{"test": "value"}})
        assert "result" in result

        # 3. List resources
        resources = await client.list_resources()
        assert len(resources) > 0

        # 4. Read a resource
        resource_uri = resources[0]["uri"]
        content = await client.read_resource(resource_uri)
        assert "content" in content

        # 5. Send a log
        await client.send_log("Workflow completed successfully")

        # 6. Request elicitation
        response = await client.request_elicitation("Confirm completion?")
        assert isinstance(response, dict)

        # 7. Request sampling
        completion = await client.request_sampling("Summarize the workflow")
        assert isinstance(completion, dict)

    @pytest.mark.asyncio
    async def test_error_recovery(self, mock_mcp_client):
        """Test error recovery and continued operation"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # First call succeeds
        result1 = await client.list_tools()
        assert isinstance(result1, list)

        # Second call fails
        mock_mcp_client.list_tools.side_effect = Exception("Temporary failure")
        result2 = await client.list_tools()
        assert result2["status"] == "failed"

        # Third call succeeds after error recovery
        mock_mcp_client.list_tools.side_effect = None
        result3 = await client.list_tools()
        assert isinstance(result3, list)

    @pytest.mark.asyncio
    async def test_stateful_workflow(self, mock_mcp_client):
        """Test workflows that maintain state between operations"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        workflow_state = {{}}

        # Step 1: Get available tools
        tools = await client.list_tools()
        workflow_state["available_tools"] = [tool["name"] for tool in tools]

        # Step 2: Use a tool
        if workflow_state["available_tools"]:
            result = await client.call_tool(workflow_state["available_tools"][0], {{}})
            workflow_state["last_result"] = result

        # Step 3: Log the result
        await client.send_log(f"Workflow completed with result: {{workflow_state.get('last_result', 'none')}}")

        # Verify workflow state
        assert "available_tools" in workflow_state
        assert len(workflow_state["available_tools"]) > 0

    @pytest.mark.asyncio
    async def test_cross_primitive_interactions(self, mock_mcp_client):
        """Test interactions between different MCP primitives"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Get tools and resources
        tools = await client.list_tools()
        resources = await client.list_resources()

        # Use information from one primitive in another
        if tools and resources:
            # Call a tool with resource information
            tool_result = await client.call_tool(tools[0]["name"], {{
                "resource_uri": resources[0]["uri"],
                "resource_name": resources[0]["name"]
            }})

            # Log the cross-primitive operation
            await client.send_log(f"Used tool {{tools[0]['name']}} with resource {{resources[0]['name']}}")

            assert "result" in tool_result

    @pytest.mark.asyncio
    async def test_long_running_workflow(self, mock_mcp_client):
        """Test long-running workflow with multiple steps"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        workflow_steps = []

        # Step 1: Initialize
        workflow_steps.append("initialized")
        await client.send_log("Workflow started")

        # Step 2: Gather information
        tools = await client.list_tools()
        resources = await client.list_resources()
        prompts = await client.list_prompts()
        workflow_steps.append("information_gathered")

        # Step 3: Process data
        for i, tool in enumerate(tools[:3]):  # Process first 3 tools
            result = await client.call_tool(tool["name"], {{"step": i + 1}})
            workflow_steps.append(f"tool_{{i+1}}_processed")

        # Step 4: Generate summary
        summary_prompt = f"Processed {{len(tools)}} tools, {{len(resources)}} resources, {{len(prompts)}} prompts"
        completion = await client.request_sampling(summary_prompt)
        workflow_steps.append("summary_generated")

        # Step 5: Cleanup
        await client.send_log("Workflow completed successfully")
        workflow_steps.append("completed")

        # Verify all steps completed
        assert len(workflow_steps) >= 5
        assert "initialized" in workflow_steps
        assert "completed" in workflow_steps


class Test{name.title()}ClientUtilities:
    """Test utility functions and helpers (5 tests)"""

    def test_client_string_representation(self):
        """Test string representation of client"""
        client = {name.title()}Client()
        str_repr = str(client)
        assert "{name.title()}Client" in str_repr

    def test_client_repr(self):
        """Test repr representation of client"""
        client = {name.title()}Client()
        repr_str = repr(client)
        assert "{name.title()}Client" in repr_str
        assert "object at" in repr_str

    def test_client_equality(self):
        """Test client equality comparison"""
        client1 = {name.title()}Client()
        client2 = {name.title()}Client()

        # Different instances should not be equal
        assert client1 != client2

        # Same instance should be equal to itself
        assert client1 == client1

    def test_client_hash(self):
        """Test client hash functionality"""
        client = {name.title()}Client()

        # Should be able to hash the client (for use in sets, etc.)
        client_set = {{client}}
        assert len(client_set) == 1
        assert client in client_set

    def test_client_attributes(self):
        """Test client attribute access"""
        client = {name.title()}Client()

        # Test basic attributes
        assert hasattr(client, '_connected')
        assert hasattr(client, '_client')
        assert hasattr(client, '_config')

        # Test that attributes have expected initial values
        assert client._connected == False
        assert client._client is None
        assert client._config is not None


# Additional test classes for specific scenarios
class Test{name.title()}ClientBoundaryConditions:
    """Test boundary conditions and edge cases (10 tests)"""

    @pytest.mark.asyncio
    async def test_empty_tool_list(self, mock_mcp_client):
        """Test handling of empty tool list"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        mock_mcp_client.list_tools.return_value = []

        result = await client.list_tools()
        assert result == []

    @pytest.mark.asyncio
    async def test_empty_resource_list(self, mock_mcp_client):
        """Test handling of empty resource list"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        mock_mcp_client.list_resources.return_value = []

        result = await client.list_resources()
        assert result == []

    @pytest.mark.asyncio
    async def test_empty_prompt_list(self, mock_mcp_client):
        """Test handling of empty prompt list"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        mock_mcp_client.list_prompts.return_value = []

        result = await client.list_prompts()
        assert result == []

    @pytest.mark.asyncio
    async def test_very_long_strings(self, mock_mcp_client):
        """Test handling of very long strings"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        long_string = "x" * 100000  # 100KB string

        mock_mcp_client.list_tools.return_value = [{{
            "name": long_string,
            "description": long_string,
            "parameters": {{}}
        }}]

        result = await client.list_tools()
        assert len(result) == 1
        assert len(result[0]["name"]) == 100000

    @pytest.mark.asyncio
    async def test_unicode_content(self, mock_mcp_client):
        """Test handling of unicode content"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        unicode_content = "Hello 世界 🌍 Test ñoños"

        mock_mcp_client.list_tools.return_value = [{{
            "name": unicode_content,
            "description": unicode_content,
            "parameters": {{}}
        }}]

        result = await client.list_tools()
        assert result[0]["name"] == unicode_content

    @pytest.mark.asyncio
    async def test_extreme_parameter_values(self, mock_mcp_client):
        """Test handling of extreme parameter values"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Test with extreme values
        extreme_args = {{
            "very_large_number": 999999999999999,
            "very_small_number": 0.000000000000001,
            "empty_string": "",
            "very_long_string": "x" * 10000,
            "nested_dict": {{"level1": {{"level2": {{"level3": "deep"}}}}}},
            "large_array": list(range(1000))
        }}

        result = await client.call_tool("test_tool", extreme_args)
        assert result["result"] == "tool_executed"

    @pytest.mark.asyncio
    async def test_null_and_none_values(self, mock_mcp_client):
        """Test handling of null and None values"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Test with None values
        result = await client.call_tool("test_tool", None)
        mock_mcp_client.call_tool.assert_called_with("test_tool", {{}})

        # Test with null values in arguments
        args_with_nulls = {{
            "null_value": None,
            "empty_string": "",
            "zero": 0,
            "false": False
        }}

        result = await client.call_tool("test_tool", args_with_nulls)
        mock_mcp_client.call_tool.assert_called_with("test_tool", args_with_nulls)

    @pytest.mark.asyncio
    async def test_concurrent_identical_operations(self, mock_mcp_client):
        """Test concurrent identical operations"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Run multiple identical operations concurrently
        tasks = [client.list_tools() for _ in range(10)]
        results = await asyncio.gather(*tasks)

        # All results should be identical
        assert all(result == results[0] for result in results)
        assert len(results) == 10

    @pytest.mark.asyncio
    async def test_rapid_connect_disconnect_cycles(self):
        """Test rapid connect/disconnect cycles"""
        client = {name.title()}Client()

        for i in range(10):
            with patch('src.client.stdio_client') as mock_stdio:
                mock_context = AsyncMock()
                mock_context.__aenter__ = AsyncMock(return_value=(Mock(), Mock()))
                mock_context.__aexit__ = AsyncMock(return_value=None)
                mock_stdio.return_value = mock_context

                await client.connect()
                assert client._connected == True

                await client.disconnect()
                assert client._connected == False

    @pytest.mark.asyncio
    async def test_memory_pressure_simulation(self, mock_mcp_client):
        """Test behavior under simulated memory pressure"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Create many large responses to simulate memory pressure
        large_responses = []
        for i in range(100):
            large_response = {{
                "name": f"tool_{{i}}",
                "description": f"Description {{i}} " * 1000,  # Large description
                "parameters": {{"param_{{j}}": f"value_{{j}}" * 100 for j in range(100)}}  # Many parameters
            }}
            large_responses.append(large_response)

        mock_mcp_client.list_tools.return_value = large_responses

        # This should handle large data without crashing
        result = await client.list_tools()
        assert len(result) == 100


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
'''

    return code
    """Generate comprehensive test file for the MCP-compliant client structure"""
    code = f'''"""
Comprehensive Tests for {name}_client MCP Client
Generated by FastestMCP CLI

This test suite validates the MCP-compliant client implementation including:
- Connection lifecycle management
- MCP primitive operations (tools, resources, prompts)
- Client-to-server communication (logging, elicitation, sampling)
- Error handling and edge cases
- Configuration management
"""

import pytest
import asyncio
import sys
import os
import tempfile
import json
from unittest.mock import Mock, patch, AsyncMock, MagicMock
from pathlib import Path

# Add src to path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Dynamic import for structured client
def load_client_module():
    """Load the client module dynamically"""
    module_name = "{name}_client.src.client"
    try:
        __import__(module_name)
        return sys.modules[module_name]
    except ImportError:
        # Fallback to direct file import
        import importlib.util
        client_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "src", "client.py")
        spec = importlib.util.spec_from_file_location("{name}_client.src.client", client_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module

client_module = load_client_module()
{name.title()}Client = client_module.{name.title()}Client


@pytest.fixture
def mock_stdio_context():
    """Mock stdio context for testing"""
    mock_context = AsyncMock()
    mock_context.__aenter__ = AsyncMock(return_value=(Mock(), Mock()))
    mock_context.__aexit__ = AsyncMock(return_value=None)
    return mock_context


@pytest.fixture
def mock_mcp_client():
    """Mock MCP client for testing"""
    mock_client = AsyncMock()
    mock_client.list_tools = AsyncMock(return_value=[
        {{"name": "test_tool", "description": "A test tool", "parameters": {{}}}}
    ])
    mock_client.call_tool = AsyncMock(return_value={{"result": "tool_executed"}})
    mock_client.list_resources = AsyncMock(return_value=[
        {{"uri": "resource://test", "name": "Test Resource"}}
    ])
    mock_client.read_resource = AsyncMock(return_value={{"content": "test content"}})
    mock_client.list_prompts = AsyncMock(return_value=[
        {{"name": "test_prompt", "description": "A test prompt"}}
    ])
    mock_client.render_prompt = AsyncMock(return_value={{"rendered": "rendered prompt"}})
    mock_client.send_log = AsyncMock(return_value=None)
    mock_client.request_elicitation = AsyncMock(return_value="user_input")
    mock_client.request_sampling = AsyncMock(return_value="sampled_response")
    return mock_client


class Test{name.title()}Client:
    """Comprehensive test cases for the {name}_client MCP client"""

    def test_client_initialization(self):
        """Test that the MCP client initializes correctly"""
        client = {name.title()}Client()
        assert client is not None
        assert hasattr(client, 'connect')
        assert hasattr(client, 'disconnect')
        assert client._connected == False
        assert client._client is None

    def test_client_initialization_with_custom_command(self):
        """Test client initialization with custom server command"""
        custom_command = ["python", "custom_server.py", "--port", "8080"]
        client = {name.title()}Client(server_command=custom_command)
        assert client.server_command == custom_command

    def test_mcp_primitives_available(self):
        """Test that all required MCP primitives are available"""
        client = {name.title()}Client()

        # Test MCP Client → Server primitives
        client_server_primitives = [
            'list_tools', 'call_tool', 'list_resources', 'read_resource',
            'list_prompts', 'render_prompt'
        ]
        for primitive in client_server_primitives:
            assert hasattr(client, primitive), f"Missing client→server primitive: {{primitive}}"
            assert asyncio.iscoroutinefunction(getattr(client, primitive)), f"{{primitive}} should be async"

        # Test Client → Server primitives
        server_client_primitives = [
            'send_log', 'request_elicitation', 'request_sampling'
        ]
        for primitive in server_client_primitives:
            assert hasattr(client, primitive), f"Missing server→client primitive: {{primitive}}"
            assert asyncio.iscoroutinefunction(getattr(client, primitive)), f"{{primitive}} should be async"

    @pytest.mark.asyncio
    async def test_connection_lifecycle(self, mock_stdio_context):
        """Test the complete connection lifecycle"""
        client = {name.title()}Client()

        # Test initial state
        assert not client._connected
        assert client._client is None

        # Mock the stdio_client import and context
        with patch('src.client.stdio_client', return_value=mock_stdio_context):
            await client.connect()

            # Test connected state
            assert client._connected == True

            await client.disconnect()

            # Test disconnected state
            assert client._connected == False

    @pytest.mark.asyncio
    async def test_connection_failure_handling(self):
        """Test handling of connection failures"""
        client = {name.title()}Client()

        # Mock stdio_client to raise an exception
        with patch('src.client.stdio_client', side_effect=Exception("Connection failed")):
            with pytest.raises(Exception, match="Connection failed"):
                await client.connect()

        # Ensure client remains in disconnected state
        assert not client._connected

    @pytest.mark.asyncio
    async def test_list_tools_success(self, mock_mcp_client):
        """Test successful tool listing"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.list_tools()

        assert isinstance(result, list)
        assert len(result) == 1
        assert result[0]["name"] == "test_tool"
        mock_mcp_client.list_tools.assert_called_once()

    @pytest.mark.asyncio
    async def test_list_tools_not_connected(self):
        """Test that list_tools fails when not connected"""
        client = {name.title()}Client()
        client._connected = False

        with pytest.raises(ConnectionError, match="Not connected to MCP server"):
            await client.list_tools()

    @pytest.mark.asyncio
    async def test_call_tool_success(self, mock_mcp_client):
        """Test successful tool calling"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        arguments = {{"param1": "value1", "param2": 42}}
        result = await client.call_tool("test_tool", arguments)

        assert result["result"] == "tool_executed"
        mock_mcp_client.call_tool.assert_called_once_with("test_tool", arguments)

    @pytest.mark.asyncio
    async def test_call_tool_with_empty_arguments(self, mock_mcp_client):
        """Test tool calling with empty arguments"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.call_tool("test_tool", None)

        # Should convert None to empty dict
        mock_mcp_client.call_tool.assert_called_once_with("test_tool", {{}})

    @pytest.mark.asyncio
    async def test_call_tool_not_connected(self):
        """Test that call_tool fails when not connected"""
        client = {name.title()}Client()

        with pytest.raises(ConnectionError, match="Not connected to MCP server"):
            await client.call_tool("test_tool", {{}})

    @pytest.mark.asyncio
    async def test_list_resources_success(self, mock_mcp_client):
        """Test successful resource listing"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.list_resources()

        assert isinstance(result, list)
        assert len(result) == 1
        assert result[0]["uri"] == "resource://test"
        mock_mcp_client.list_resources.assert_called_once()

    @pytest.mark.asyncio
    async def test_read_resource_success(self, mock_mcp_client):
        """Test successful resource reading"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.read_resource("resource://test")

        assert result["content"] == "test content"
        mock_mcp_client.read_resource.assert_called_once_with("resource://test")

    @pytest.mark.asyncio
    async def test_list_prompts_success(self, mock_mcp_client):
        """Test successful prompt listing"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.list_prompts()

        assert isinstance(result, list)
        assert len(result) == 1
        assert result[0]["name"] == "test_prompt"
        mock_mcp_client.list_prompts.assert_called_once()

    @pytest.mark.asyncio
    async def test_render_prompt_success(self, mock_mcp_client):
        """Test successful prompt rendering"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        arguments = {{"arg1": "value1"}}
        result = await client.render_prompt("test_prompt", arguments)

        assert result["rendered"] == "rendered prompt"
        mock_mcp_client.render_prompt.assert_called_once_with("test_prompt", arguments)

    @pytest.mark.asyncio
    async def test_render_prompt_empty_arguments(self, mock_mcp_client):
        """Test prompt rendering with empty arguments"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.render_prompt("test_prompt", None)

        # Should convert None to empty dict
        mock_mcp_client.render_prompt.assert_called_once_with("test_prompt", {{}})

    @pytest.mark.asyncio
    async def test_send_log_success(self, mock_mcp_client):
        """Test successful log sending"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.send_log("Test message", "info")

        assert result["message"] == "Test message"
        assert result["level"] == "info"
        assert result["status"] == "logged"
        mock_mcp_client.send_log.assert_called_once_with("Test message", "info")

    @pytest.mark.asyncio
    async def test_send_log_default_level(self, mock_mcp_client):
        """Test log sending with default level"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.send_log("Test message")

        assert result["level"] == "info"
        mock_mcp_client.send_log.assert_called_once_with("Test message", "info")

    @pytest.mark.asyncio
    async def test_request_elicitation_success(self, mock_mcp_client):
        """Test successful elicitation request"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.request_elicitation("Please enter your name")

        assert result["query"] == "Please enter your name"
        assert result["elicitation_type"] == "user_input"
        assert result["status"] == "requested"
        mock_mcp_client.request_elicitation.assert_called_once_with("Please enter your name")

    @pytest.mark.asyncio
    async def test_request_sampling_success(self, mock_mcp_client):
        """Test successful sampling request"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        result = await client.request_sampling("Generate a response", temperature=0.7, max_tokens=100)

        assert result["prompt"] == "Generate a response"
        assert result["sampling_parameters"]["temperature"] == 0.7
        assert result["sampling_parameters"]["max_tokens"] == 100
        assert result["status"] == "sampled"
        mock_mcp_client.request_sampling.assert_called_once_with("Generate a response", temperature=0.7, max_tokens=100)

    @pytest.mark.asyncio
    async def test_all_primitives_require_connection(self):
        """Test that all MCP primitives require connection"""
        client = {name.title()}Client()
        primitives_to_test = [
            ('list_tools', []),
            ('call_tool', ["test_tool", {{}}]),
            ('list_resources', []),
            ('read_resource', ["resource://test"]),
            ('list_prompts', []),
            ('render_prompt', ["test_prompt", {{}}]),
            ('send_log', ["message"]),
            ('request_elicitation', ["query"]),
            ('request_sampling', ["prompt"])
        ]

        for primitive_name, args in primitives_to_test:
            with pytest.raises(ConnectionError, match="Not connected to MCP server"):
                primitive = getattr(client, primitive_name)
                await primitive(*args)

    @pytest.mark.asyncio
    async def test_primitive_error_handling(self, mock_mcp_client):
        """Test error handling in MCP primitives"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Mock an exception in the MCP client
        mock_mcp_client.list_tools.side_effect = Exception("MCP server error")

        result = await client.list_tools()

        assert result["error"] == "MCP server error"
        assert result["status"] == "failed"

    def test_config_loading_from_dict(self):
        """Test configuration loading from dictionary"""
        config = {{
            "servers": [{{"command": "python", "args": ["server.py"]}}]
        }}

        client = {name.title()}Client(config_or_path=config)
        assert client._config == config

    def test_config_loading_from_json_file(self):
        """Test configuration loading from JSON file"""
        config = {{
            "servers": [{{"command": "python", "args": ["server.py"]}}]
        }}

        with tempfile.NamedTemporaryFile(mode='w', suffix='.json', delete=False) as f:
            json.dump(config, f)
            config_path = f.name

        try:
            client = {name.title()}Client(config_or_path=config_path)
            assert client._config == config
        finally:
            os.unlink(config_path)

    def test_config_loading_defaults(self):
        """Test default configuration when no config provided"""
        # Mock the file system to simulate missing mcp.json
        with patch('os.path.exists', return_value=False):
            client = {name.title()}Client()
            expected_config = {{"servers": [{{"command": "python", "args": ["server.py"]}}]}}
            assert client._config == expected_config

    def test_config_loading_invalid_type(self):
        """Test error handling for invalid config type"""
        with pytest.raises(ValueError, match="Config must be dict or path"):
            {name.title()}Client(config_or_path=123)

    @pytest.mark.asyncio
    async def test_disconnect_safety(self):
        """Test that disconnect is safe to call multiple times"""
        client = {name.title()}Client()
        client._connected = True

        # Should not raise any exceptions
        await client.disconnect()
        await client.disconnect()

        assert not client._connected

    @pytest.mark.asyncio
    async def test_connect_already_connected(self, mock_stdio_context):
        """Test connecting when already connected"""
        client = {name.title()}Client()
        client._connected = True

        with patch('src.client.stdio_client', return_value=mock_stdio_context):
            # Should handle reconnection gracefully
            await client.connect()
            assert client._connected == True

    def test_client_string_representation(self):
        """Test string representation of client"""
        client = {name.title()}Client()
        str_repr = str(client)
        assert "{name.title()}Client" in str_repr

    @pytest.mark.asyncio
    async def test_concurrent_operations(self, mock_mcp_client):
        """Test concurrent MCP operations"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Run multiple operations concurrently
        tasks = [
            client.list_tools(),
            client.list_resources(),
            client.list_prompts()
        ]

        results = await asyncio.gather(*tasks)

        assert len(results) == 3
        assert all(isinstance(result, list) for result in results)

    @pytest.mark.asyncio
    async def test_large_data_handling(self, mock_mcp_client):
        """Test handling of large data responses"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # Mock large response
        large_tools = [{{"name": f"tool_{{i}}", "description": f"Description {{i}}"}} for i in range(1000)]
        mock_mcp_client.list_tools.return_value = large_tools

        result = await client.list_tools()

        assert len(result) == 1000
        assert result[0]["name"] == "tool_0"
        assert result[-1]["name"] == "tool_999"


class Test{name.title()}ClientIntegration:
    """Integration tests for {name}_client"""

    @pytest.mark.asyncio
    async def test_full_workflow(self, mock_mcp_client):
        """Test a complete MCP client workflow"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # 1. List available tools
        tools = await client.list_tools()
        assert len(tools) > 0

        # 2. Call a tool
        tool_name = tools[0]["name"]
        result = await client.call_tool(tool_name, {{"test": "value"}})
        assert "result" in result

        # 3. List resources
        resources = await client.list_resources()
        assert len(resources) > 0

        # 4. Read a resource
        resource_uri = resources[0]["uri"]
        content = await client.read_resource(resource_uri)
        assert "content" in content

        # 5. Send a log
        await client.send_log("Workflow completed successfully")

        # 6. Request elicitation
        response = await client.request_elicitation("Confirm completion?")
        assert isinstance(response, dict)

        # 7. Request sampling
        completion = await client.request_sampling("Summarize the workflow")
        assert isinstance(completion, dict)

    @pytest.mark.asyncio
    async def test_error_recovery(self, mock_mcp_client):
        """Test error recovery and continued operation"""
        client = {name.title()}Client()
        client._connected = True
        client._client = mock_mcp_client

        # First call succeeds
        result1 = await client.list_tools()
        assert isinstance(result1, list)

        # Second call fails
        mock_mcp_client.list_tools.side_effect = Exception("Temporary failure")
        result2 = await client.list_tools()
        assert result2["status"] == "failed"

        # Third call succeeds after error recovery
        mock_mcp_client.list_tools.side_effect = None
        result3 = await client.list_tools()
        assert isinstance(result3, list)


if __name__ == "__main__":
    pytest.main([__file__, "-v", "--tb=short"])
'''

    return code


def generate_mcp_client_pyproject_toml(name: str, client_type: str, transport: str, structure: str = 'mono') -> str:
    """Generate pyproject.toml with proper MCP dependencies"""
    dependencies = []

    if client_type == 'fastmcp':
        dependencies.append('fastmcp>=2.12.0')
    else:
        dependencies.append('mcp>=1.0.0')

    # Add transport-specific dependencies
    if transport == 'http':
        dependencies.extend([
            'httpx>=0.28.0',
            'fastapi>=0.100.0',
            'uvicorn>=0.20.0'
        ])
    elif transport == 'websocket':
        dependencies.extend([
            'websockets>=11.0.0'
        ])

    dependencies_str = '\n'.join(f'    "{dep}",' for dep in dependencies)

    if structure == 'structured':
        # For structured projects, include scripts and package info
        toml_content = f'''[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "{name}-client"
version = "0.1.0"
description = "MCP-Compliant Client generated by FastestMCP CLI"
authors = [
    {{name = "FastestMCP CLI", email = "cli@fastestmcp.dev"}},
]
dependencies = [
{dependencies_str}
]
requires-python = ">=3.10"
readme = "README.md"

[project.scripts]
{name}-client = "{name}_client.main:main"

[tool.setuptools]
packages = ["{name}_client"]

[tool.setuptools.package-dir]
"{name}_client" = "."

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
warn_unused_ignores = true
warn_no_return = true
warn_unreachable = true
strict_equality = true

[tool.black]
line-length = 88
target-version = ["py310"]
include = "\\\\.pyi?$"
extend-exclude = """
/(
  # directories
  \\\\.eggs
  | \\\\.git
  | \\\\.hg
  | \\\\.mypy_cache
  | \\\\.tox
  | \\\\.venv
  | build
  | dist
)/
"""

[tool.isort]
profile = "black"
multi_line_output = 3
line_length = 88
'''
    else:
        # For mono-file projects, simpler structure
        toml_content = f'''[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "{name}-client"
version = "0.1.0"
description = "MCP-Compliant Client generated by FastestMCP CLI"
authors = [
    {{name = "FastestMCP CLI", email = "cli@fastestmcp.dev"}},
]
dependencies = [
{dependencies_str}
]
requires-python = ">=3.10"
readme = "README.md"

[project.scripts]
{name} = "{name}:main"

[tool.mypy]
python_version = "3.10"
warn_return_any = true
warn_unused_configs = true
disallow_untyped_defs = true
disallow_incomplete_defs = true
check_untyped_defs = true
disallow_untyped_decorators = true
no_implicit_optional = true
warn_redundant_casts = true
'''

    return toml_content


def generate_clean_mcp_client_readme(name: str, transport: str, client_type: str) -> str:
    """Generate README.md for the MCP-compliant client structure"""
    readme = f'''# {name}_client

MCP-Compliant Client generated by FastestMCP CLI

## Architecture Compliance ✅

This client implementation is fully compliant with MCP architecture:

### ✅ **Correct MCP Client Architecture**
- **Connection Manager**: Manages stdio transport connection to MCP server
- **Client → Server Primitives**:
  - `list_tools()` - List available tools from server
  - `call_tool()` - Execute tools on server
  - `list_resources()` - List available resources from server
  - `read_resource()` - Read resources from server
  - `list_prompts()` - List available prompts from server
  - `render_prompt()` - Render prompts from server
- **Client → Server Primitives**:
  - `send_log()` - Send debug messages to server
  - `request_elicitation()` - Request user input from server
  - `request_sampling()` - Request LLM completions from server

### ✅ **Transport Layer**
- Uses **stdio transport** for local development (consistent with server)
- Proper connection lifecycle management
- Error handling for connection states

### ❌ **Removed Non-MCP Concepts**
- ❌ **APIs** - These belong on the **server** as **tools**
- ❌ **Integrations** - These belong on the **server** as **tools**
- ❌ **Handlers** - These belong on the **server** as **tools**

## Usage

```python
from src.client import {name.title()}Client

# Create client
client = {name.title()}Client()

# Connect to server (requires server to be running)
await client.connect()

# Use MCP primitives
tools = await client.list_tools()
result = await client.call_tool("tool_name", {{"param": "value"}})
resources = await client.list_resources()
content = await client.read_resource("resource://uri")

# Client-to-server primitives
await client.send_log("Debug message")
response = await client.request_elicitation("User query?")
completion = await client.request_sampling("Prompt text")

# Disconnect
await client.disconnect()
```

## Testing

Run the test script to validate the implementation:

```bash
python -m pytest tests/
```

## Architecture Comparison

| Component | ❌ Old Implementation | ✅ New Implementation |
|-----------|----------------------|----------------------|
| **Client Role** | Server-like with APIs | Connection manager |
| **Transport** | Mixed (HTTP/stdio) | Consistent stdio |
| **Primitives** | Custom components | Standard MCP primitives |
| **APIs** | Client methods | Server tools |
| **Integrations** | Client methods | Server tools |
| **Handlers** | Client methods | Server tools |

## Files

- `src/client.py` - Main MCP client implementation
- `tests/test_client.py` - Test script for validation
- `README.md` - This documentation

## Next Steps

1. **Implement Server**: Create corresponding MCP server with tools, resources, and prompts
2. **Real Transport**: Replace mock implementations with actual MCP protocol messaging
3. **Integration Testing**: Test client-server communication end-to-end
4. **Production Ready**: Add proper error handling, logging, and configuration

---

*This implementation demonstrates the correct MCP client architecture and serves as a foundation for building compliant MCP applications.*
'''

    return readme


def generate_clean_mcp_client_folder_markdown(name: str, transport: str, client_type: str, files: list) -> str:
    """Generate clean MCP client folder structure markdown"""
    structure = f"""
```
{name}_client/
├── main.py                    # Main entry point
├── pyproject.toml            # Project configuration
├── README.md                 # Documentation
├── src/                      # Source code directory
│   ├── __init__.py
│   ├── client.py             # Main MCP client file
└── tests/                   # Test directory
    ├── __init__.py
    └── test_client.py
```

**Generated Files:**
"""
    for file in files:
        structure += f"- `{file}`\n"

    structure += f"""
**Client Details:**
- Transport: {transport}
- Type: {client_type}
- Architecture: MCP-Compliant
"""

    return structure