"""
Test generation utilities for FastestMCP CLI
"""

def generate_test_file(name: str, tools: int, resources: int, prompts: int, notifications: int, subscriptions: int, structure: str = 'mono') -> str:
    """Generate test file for the MCP server"""
    package_name = name.replace('-', '_')

    if structure == 'mono':
        # For mono-file projects
        test_content = f'''"""
Tests for {name} MCP Server
Generated by FastestMCP CLI
"""

import pytest
import asyncio
import importlib.util
from unittest.mock import Mock, patch, AsyncMock

# Dynamic import for mono-file server
def load_server_module():
    """Load the server module dynamically to handle filenames with hyphens"""
    spec = importlib.util.spec_from_file_location("{name.replace('-', '_')}", "{name}.py")
    module = importlib.util.module_from_spec(spec)
    spec.loader.exec_module(module)
    return module

server_module = load_server_module()
app = server_module.app
register_tools = server_module.register_tools
register_resources = server_module.register_resources
register_prompts = getattr(server_module, 'register_prompts', None)
register_notifications = getattr(server_module, 'register_notifications', None)
register_subscriptions = getattr(server_module, 'register_subscriptions', None)


class Test{name.replace('-', '').replace('_', '').title()}Server:
    """Test cases for the {name} MCP server"""

    def test_server_creation(self):
        """Test that the MCP server is created successfully"""
        assert app is not None
        assert hasattr(app, 'name')
        assert "{name}" in app.name

    def test_register_tools_function_exists(self):
        """Test that register_tools function exists"""
        assert callable(register_tools)

    def test_register_resources_function_exists(self):
        """Test that register_resources function exists"""
        assert callable(register_resources)

    @pytest.mark.asyncio
    async def test_server_can_start(self):
        """Test that the server can be started (mocked)"""
        with patch.object(app, 'run_stdio_async', new_callable=AsyncMock) as mock_run:
            # We can't actually run the server in tests, but we can verify the method exists
            assert hasattr(app, 'run_stdio_async')
            assert callable(app.run_stdio_async)
'''

        # Add component-specific tests
        if tools > 0:
            test_content += f'''
    def test_tools_registration(self):
        """Test tools registration with mocked server"""
        mock_server = Mock()
        result = register_tools(mock_server)
        assert result["success"] == True
        assert result["count"] == {tools}
        assert "tools" in result["component_type"]
'''

        if resources > 0:
            test_content += f'''
    def test_resources_registration(self):
        """Test resources registration with mocked server"""
        mock_server = Mock()
        result = register_resources(mock_server)
        assert result["success"] == True
        assert result["count"] == {resources}
        assert "resources" in result["component_type"]
'''

        if prompts > 0:
            test_content += '''
    def test_prompts_registration(self):
        """Test prompts registration with mocked server"""
        mock_server = Mock()
        result = register_prompts(mock_server)
        assert result["success"] == True
        assert result["count"] == {prompts}
        assert "prompts" in result["component_type"]
'''

        if notifications > 0:
            test_content += '''
    def test_notifications_registration(self):
        """Test notifications registration with mocked server"""
        mock_server = Mock()
        result = register_notifications(mock_server)
        assert result["success"] == True
        assert result["count"] == {notifications}
        assert "notifications" in result["component_type"]
'''

        if subscriptions > 0:
            test_content += '''
    def test_subscriptions_registration(self):
        """Test subscriptions registration with mocked server"""
        mock_server = Mock()
        result = register_subscriptions(mock_server)
        assert result["success"] == True
        assert result["count"] == {subscriptions}
        assert "subscriptions" in result["component_type"]
'''

    else:
        # For structured projects
        test_content = f'''"""
Tests for {name} MCP Server
Generated by FastestMCP CLI
"""

import pytest
import asyncio
import sys
import os
from unittest.mock import Mock, patch, AsyncMock

# Add the parent directory to sys.path for imports
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

# Dynamic import for structured project
def load_server_module():
    """Load the server module dynamically"""
    module_name = "{package_name}.server"
    try:
        __import__(module_name)
        return sys.modules[module_name]
    except ImportError:
        # Fallback to direct file import
        import importlib.util
        server_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "server.py")
        spec = importlib.util.spec_from_file_location("{package_name}.server", server_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module

def load_tools_module():
    """Load the tools module dynamically"""
    module_name = "{package_name}.tools"
    try:
        __import__(module_name)
        return sys.modules[module_name]
    except ImportError:
        # Fallback to direct file import
        import importlib.util
        tools_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "tools.py")
        spec = importlib.util.spec_from_file_location("{package_name}.tools", tools_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module

def load_resources_module():
    """Load the resources module dynamically"""
    module_name = "{package_name}.resources"
    try:
        __import__(module_name)
        return sys.modules[module_name]
    except ImportError:
        # Fallback to direct file import
        import importlib.util
        resources_path = os.path.join(os.path.dirname(os.path.dirname(os.path.abspath(__file__))), "resources.py")
        spec = importlib.util.spec_from_file_location("{package_name}.resources", resources_path)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)
        return module

server_module = load_server_module()
tools_module = load_tools_module()
resources_module = load_resources_module()

app = server_module.app
tools = tools_module
resources = resources_module


class Test{name.replace('-', '').replace('_', '').title()}Server:
    """Test cases for the {name} MCP server"""

    def test_server_creation(self):
        """Test that the MCP server is created successfully"""
        assert app is not None
        assert hasattr(app, 'name')
        assert "{name}" in app.name

    def test_tools_module_import(self):
        """Test that tools module can be imported"""
        assert tools is not None
        assert hasattr(tools, 'register_tools')

    def test_resources_module_import(self):
        """Test that resources module can be imported"""
        assert resources is not None
        assert hasattr(resources, 'register_resources')

    @pytest.mark.asyncio
    async def test_server_can_start(self):
        """Test that the server can be started (mocked)"""
        with patch.object(app, 'run_stdio_async', new_callable=AsyncMock) as mock_run:
            # We can't actually run the server in tests, but we can verify the method exists
            assert hasattr(app, 'run_stdio_async')
            assert callable(app.run_stdio_async)
'''

        # Add component-specific tests for structured projects
        if tools > 0:
            test_content += f'''
    def test_tools_registration(self):
        """Test tools registration with mocked server"""
        mock_server = Mock()
        result = tools.register_tools(mock_server)
        assert result["success"] == True
        assert result["count"] == {tools}
'''

        if resources > 0:
            test_content += f'''
    def test_resources_registration(self):
        """Test resources registration with mocked server"""
        mock_server = Mock()
        result = resources.register_resources(mock_server)
        assert result["success"] == True
        assert result["count"] == {resources}
'''

    test_content += '''

if __name__ == "__main__":
    pytest.main([__file__, "-v"])
'''

    return test_content