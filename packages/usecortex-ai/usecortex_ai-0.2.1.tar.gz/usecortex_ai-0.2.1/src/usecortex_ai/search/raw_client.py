# This file was auto-generated by Fern from our API Definition.

import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.http_response import AsyncHttpResponse, HttpResponse
from ..core.pydantic_utilities import parse_obj_as
from ..core.request_options import RequestOptions
from ..core.serialization import convert_and_respect_annotation_metadata
from ..errors.bad_request_error import BadRequestError
from ..errors.forbidden_error import ForbiddenError
from ..errors.internal_server_error import InternalServerError
from ..errors.not_found_error import NotFoundError
from ..errors.service_unavailable_error import ServiceUnavailableError
from ..errors.unauthorized_error import UnauthorizedError
from ..errors.unprocessable_entity_error import UnprocessableEntityError
from ..types.actual_error_response import ActualErrorResponse
from ..types.bm_25_operator_type import Bm25OperatorType
from ..types.search_chunk import SearchChunk
from .types.alpha import Alpha

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class RawSearchClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def qna(
        self,
        *,
        question: str,
        session_id: str,
        tenant_id: str,
        context_list: typing.Optional[typing.Sequence[str]] = OMIT,
        search_modes: typing.Optional[typing.Sequence[str]] = OMIT,
        sub_tenant_id: typing.Optional[str] = OMIT,
        highlight_chunks: typing.Optional[bool] = OMIT,
        stream: typing.Optional[bool] = OMIT,
        search_alpha: typing.Optional[float] = OMIT,
        recency_bias: typing.Optional[float] = OMIT,
        ai_generation: typing.Optional[bool] = OMIT,
        top_n: typing.Optional[int] = OMIT,
        user_name: typing.Optional[str] = OMIT,
        user_instructions: typing.Optional[str] = OMIT,
        multi_step_reasoning: typing.Optional[bool] = OMIT,
        auto_agent_routing: typing.Optional[bool] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        question : str

        session_id : str

        tenant_id : str

        context_list : typing.Optional[typing.Sequence[str]]

        search_modes : typing.Optional[typing.Sequence[str]]

        sub_tenant_id : typing.Optional[str]

        highlight_chunks : typing.Optional[bool]

        stream : typing.Optional[bool]

        search_alpha : typing.Optional[float]

        recency_bias : typing.Optional[float]

        ai_generation : typing.Optional[bool]

        top_n : typing.Optional[int]

        user_name : typing.Optional[str]

        user_instructions : typing.Optional[str]

        multi_step_reasoning : typing.Optional[bool]

        auto_agent_routing : typing.Optional[bool]

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "search/qna",
            method="POST",
            json={
                "question": question,
                "session_id": session_id,
                "tenant_id": tenant_id,
                "context_list": context_list,
                "search_modes": search_modes,
                "sub_tenant_id": sub_tenant_id,
                "highlight_chunks": highlight_chunks,
                "stream": stream,
                "search_alpha": search_alpha,
                "recency_bias": recency_bias,
                "ai_generation": ai_generation,
                "top_n": top_n,
                "user_name": user_name,
                "user_instructions": user_instructions,
                "multi_step_reasoning": multi_step_reasoning,
                "auto_agent_routing": auto_agent_routing,
                "metadata": metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return HttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def retrieve(
        self,
        *,
        query: str,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = OMIT,
        max_chunks: typing.Optional[int] = OMIT,
        alpha: typing.Optional[Alpha] = OMIT,
        recency_bias: typing.Optional[float] = OMIT,
        num_related_chunks: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[SearchChunk]]:
        """
        Search for content within indexed sources using semantic and keyword search capabilities.

        This endpoint performs a search query against the Findr backend, allowing users to retrieve
        relevant content chunks from their indexed documents and sources. The search can be customized
        with various parameters to control the number of results and search behavior.

        Args:
            request (SearchRequest): The search request containing:
                - query (str): Search query string to find relevant content
                - tenant_id (str, optional): Tenant identifier for multi-tenancy
                - sub_tenant_id (str, optional): Sub-tenant identifier, defaults to tenant_id
                - max_chunks (int, optional): Maximum number of content chunks to return
                - alpha (Union[float, str], optional): Search algorithm parameter for result ranking (default: 0.8). Can be float-type (0.0-1.0) or 'auto' for dynamic selection
                - recency_bias (float, optional): Bias towards more recent content (default: 0.5)
                - num_related_chunks (int, optional): Number of related chunks to return (default: 0)
            api_details (dict): Authentication details obtained from API key validation

        Returns:
            SearchData: Success response with search results

        Parameters
        ----------
        query : str

        tenant_id : str

        sub_tenant_id : typing.Optional[str]

        max_chunks : typing.Optional[int]

        alpha : typing.Optional[Alpha]

        recency_bias : typing.Optional[float]

        num_related_chunks : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[SearchChunk]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "search/retrieve",
            method="POST",
            json={
                "query": query,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
                "max_chunks": max_chunks,
                "alpha": convert_and_respect_annotation_metadata(object_=alpha, annotation=Alpha, direction="write"),
                "recency_bias": recency_bias,
                "num_related_chunks": num_related_chunks,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[SearchChunk],
                    parse_obj_as(
                        type_=typing.List[SearchChunk],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    def full_text_search(
        self,
        *,
        query: str,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = OMIT,
        operator: typing.Optional[Bm25OperatorType] = OMIT,
        max_chunks: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> HttpResponse[typing.List[SearchChunk]]:
        """
        Full text search endpoint for Cortex customers.
        Performs full text search with configurable operators for precise text matching against the Findr backend.

        This endpoint performs a full text search query against the Findr backend, allowing users to retrieve
        relevant content chunks from their indexed documents and sources using BM25-based text matching.
        The search can be customized with various operators to control the matching behavior.

        Args:
            request (FullTextSearchRequest): The full text search request containing:
                - query (str): Search query string to find relevant content
                - tenant_id (str): Tenant identifier for multi-tenancy
                - sub_tenant_id (str, optional): Sub-tenant identifier, defaults to tenant_id
                - operator (BM25OperatorType, optional): Full text search operator type (OR or AND). Defaults to OR
                - max_chunks (int, optional): Maximum number of content chunks to return (1-1001, defaults to 25)
            api_details (dict): Authentication details obtained from API key validation

        Returns:
            FullTextSearchData: Success response with full text search results

        Parameters
        ----------
        query : str

        tenant_id : str

        sub_tenant_id : typing.Optional[str]

        operator : typing.Optional[Bm25OperatorType]

        max_chunks : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        HttpResponse[typing.List[SearchChunk]]
            Successful Response
        """
        _response = self._client_wrapper.httpx_client.request(
            "search/full-text-search",
            method="POST",
            json={
                "query": query,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
                "operator": operator,
                "max_chunks": max_chunks,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[SearchChunk],
                    parse_obj_as(
                        type_=typing.List[SearchChunk],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return HttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)


class AsyncRawSearchClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def qna(
        self,
        *,
        question: str,
        session_id: str,
        tenant_id: str,
        context_list: typing.Optional[typing.Sequence[str]] = OMIT,
        search_modes: typing.Optional[typing.Sequence[str]] = OMIT,
        sub_tenant_id: typing.Optional[str] = OMIT,
        highlight_chunks: typing.Optional[bool] = OMIT,
        stream: typing.Optional[bool] = OMIT,
        search_alpha: typing.Optional[float] = OMIT,
        recency_bias: typing.Optional[float] = OMIT,
        ai_generation: typing.Optional[bool] = OMIT,
        top_n: typing.Optional[int] = OMIT,
        user_name: typing.Optional[str] = OMIT,
        user_instructions: typing.Optional[str] = OMIT,
        multi_step_reasoning: typing.Optional[bool] = OMIT,
        auto_agent_routing: typing.Optional[bool] = OMIT,
        metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.Optional[typing.Any]]:
        """
        Parameters
        ----------
        question : str

        session_id : str

        tenant_id : str

        context_list : typing.Optional[typing.Sequence[str]]

        search_modes : typing.Optional[typing.Sequence[str]]

        sub_tenant_id : typing.Optional[str]

        highlight_chunks : typing.Optional[bool]

        stream : typing.Optional[bool]

        search_alpha : typing.Optional[float]

        recency_bias : typing.Optional[float]

        ai_generation : typing.Optional[bool]

        top_n : typing.Optional[int]

        user_name : typing.Optional[str]

        user_instructions : typing.Optional[str]

        multi_step_reasoning : typing.Optional[bool]

        auto_agent_routing : typing.Optional[bool]

        metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.Optional[typing.Any]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "search/qna",
            method="POST",
            json={
                "question": question,
                "session_id": session_id,
                "tenant_id": tenant_id,
                "context_list": context_list,
                "search_modes": search_modes,
                "sub_tenant_id": sub_tenant_id,
                "highlight_chunks": highlight_chunks,
                "stream": stream,
                "search_alpha": search_alpha,
                "recency_bias": recency_bias,
                "ai_generation": ai_generation,
                "top_n": top_n,
                "user_name": user_name,
                "user_instructions": user_instructions,
                "multi_step_reasoning": multi_step_reasoning,
                "auto_agent_routing": auto_agent_routing,
                "metadata": metadata,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if _response is None or not _response.text.strip():
                return AsyncHttpResponse(response=_response, data=None)
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.Optional[typing.Any],
                    parse_obj_as(
                        type_=typing.Optional[typing.Any],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def retrieve(
        self,
        *,
        query: str,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = OMIT,
        max_chunks: typing.Optional[int] = OMIT,
        alpha: typing.Optional[Alpha] = OMIT,
        recency_bias: typing.Optional[float] = OMIT,
        num_related_chunks: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[SearchChunk]]:
        """
        Search for content within indexed sources using semantic and keyword search capabilities.

        This endpoint performs a search query against the Findr backend, allowing users to retrieve
        relevant content chunks from their indexed documents and sources. The search can be customized
        with various parameters to control the number of results and search behavior.

        Args:
            request (SearchRequest): The search request containing:
                - query (str): Search query string to find relevant content
                - tenant_id (str, optional): Tenant identifier for multi-tenancy
                - sub_tenant_id (str, optional): Sub-tenant identifier, defaults to tenant_id
                - max_chunks (int, optional): Maximum number of content chunks to return
                - alpha (Union[float, str], optional): Search algorithm parameter for result ranking (default: 0.8). Can be float-type (0.0-1.0) or 'auto' for dynamic selection
                - recency_bias (float, optional): Bias towards more recent content (default: 0.5)
                - num_related_chunks (int, optional): Number of related chunks to return (default: 0)
            api_details (dict): Authentication details obtained from API key validation

        Returns:
            SearchData: Success response with search results

        Parameters
        ----------
        query : str

        tenant_id : str

        sub_tenant_id : typing.Optional[str]

        max_chunks : typing.Optional[int]

        alpha : typing.Optional[Alpha]

        recency_bias : typing.Optional[float]

        num_related_chunks : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[SearchChunk]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "search/retrieve",
            method="POST",
            json={
                "query": query,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
                "max_chunks": max_chunks,
                "alpha": convert_and_respect_annotation_metadata(object_=alpha, annotation=Alpha, direction="write"),
                "recency_bias": recency_bias,
                "num_related_chunks": num_related_chunks,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[SearchChunk],
                    parse_obj_as(
                        type_=typing.List[SearchChunk],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)

    async def full_text_search(
        self,
        *,
        query: str,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = OMIT,
        operator: typing.Optional[Bm25OperatorType] = OMIT,
        max_chunks: typing.Optional[int] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncHttpResponse[typing.List[SearchChunk]]:
        """
        Full text search endpoint for Cortex customers.
        Performs full text search with configurable operators for precise text matching against the Findr backend.

        This endpoint performs a full text search query against the Findr backend, allowing users to retrieve
        relevant content chunks from their indexed documents and sources using BM25-based text matching.
        The search can be customized with various operators to control the matching behavior.

        Args:
            request (FullTextSearchRequest): The full text search request containing:
                - query (str): Search query string to find relevant content
                - tenant_id (str): Tenant identifier for multi-tenancy
                - sub_tenant_id (str, optional): Sub-tenant identifier, defaults to tenant_id
                - operator (BM25OperatorType, optional): Full text search operator type (OR or AND). Defaults to OR
                - max_chunks (int, optional): Maximum number of content chunks to return (1-1001, defaults to 25)
            api_details (dict): Authentication details obtained from API key validation

        Returns:
            FullTextSearchData: Success response with full text search results

        Parameters
        ----------
        query : str

        tenant_id : str

        sub_tenant_id : typing.Optional[str]

        operator : typing.Optional[Bm25OperatorType]

        max_chunks : typing.Optional[int]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncHttpResponse[typing.List[SearchChunk]]
            Successful Response
        """
        _response = await self._client_wrapper.httpx_client.request(
            "search/full-text-search",
            method="POST",
            json={
                "query": query,
                "tenant_id": tenant_id,
                "sub_tenant_id": sub_tenant_id,
                "operator": operator,
                "max_chunks": max_chunks,
            },
            headers={
                "content-type": "application/json",
            },
            request_options=request_options,
            omit=OMIT,
        )
        try:
            if 200 <= _response.status_code < 300:
                _data = typing.cast(
                    typing.List[SearchChunk],
                    parse_obj_as(
                        type_=typing.List[SearchChunk],  # type: ignore
                        object_=_response.json(),
                    ),
                )
                return AsyncHttpResponse(response=_response, data=_data)
            if _response.status_code == 400:
                raise BadRequestError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 401:
                raise UnauthorizedError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 403:
                raise ForbiddenError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 404:
                raise NotFoundError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 422:
                raise UnprocessableEntityError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        typing.Optional[typing.Any],
                        parse_obj_as(
                            type_=typing.Optional[typing.Any],  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 500:
                raise InternalServerError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            if _response.status_code == 503:
                raise ServiceUnavailableError(
                    headers=dict(_response.headers),
                    body=typing.cast(
                        ActualErrorResponse,
                        parse_obj_as(
                            type_=ActualErrorResponse,  # type: ignore
                            object_=_response.json(),
                        ),
                    ),
                )
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response.text)
        raise ApiError(status_code=_response.status_code, headers=dict(_response.headers), body=_response_json)
