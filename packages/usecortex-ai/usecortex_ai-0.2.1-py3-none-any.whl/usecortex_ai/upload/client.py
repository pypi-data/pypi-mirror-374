# This file was auto-generated by Fern from our API Definition.

import typing

from .. import core
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.request_options import RequestOptions
from ..types.app_sources_upload_data import AppSourcesUploadData
from ..types.batch_upload_data import BatchUploadData
from ..types.processing_status import ProcessingStatus
from ..types.relations import Relations
from ..types.single_upload_data import SingleUploadData
from ..types.source_model import SourceModel
from .raw_client import AsyncRawUploadClient, RawUploadClient

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class UploadClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._raw_client = RawUploadClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> RawUploadClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        RawUploadClient
        """
        return self._raw_client

    def batch_upload(
        self,
        *,
        tenant_id: str,
        files: typing.List[core.File],
        sub_tenant_id: typing.Optional[str] = None,
        tenant_metadata: typing.Optional[str] = OMIT,
        document_metadata: typing.Optional[str] = OMIT,
        relations: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BatchUploadData:
        """
        Parameters
        ----------
        tenant_id : str

        files : typing.List[core.File]
            See core.File for more documentation

        sub_tenant_id : typing.Optional[str]

        tenant_metadata : typing.Optional[str]

        document_metadata : typing.Optional[str]

        relations : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BatchUploadData
            Successful Response

        Examples
        --------
        from usecortex-ai import CortexAI

        client = CortexAI(token="YOUR_TOKEN", )
        client.upload.batch_upload(tenant_id='tenant_id', )
        """
        _response = self._raw_client.batch_upload(
            tenant_id=tenant_id,
            files=files,
            sub_tenant_id=sub_tenant_id,
            tenant_metadata=tenant_metadata,
            document_metadata=document_metadata,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    def batch_update(
        self,
        *,
        tenant_id: str,
        files: typing.List[core.File],
        sub_tenant_id: typing.Optional[str] = None,
        source_ids: typing.Optional[typing.List[str]] = OMIT,
        tenant_metadata: typing.Optional[str] = OMIT,
        document_metadata: typing.Optional[str] = OMIT,
        relations: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BatchUploadData:
        """
        Parameters
        ----------
        tenant_id : str

        files : typing.List[core.File]
            See core.File for more documentation

        sub_tenant_id : typing.Optional[str]

        source_ids : typing.Optional[typing.List[str]]

        tenant_metadata : typing.Optional[str]

        document_metadata : typing.Optional[str]

        relations : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BatchUploadData
            Successful Response

        Examples
        --------
        from usecortex-ai import CortexAI

        client = CortexAI(token="YOUR_TOKEN", )
        client.upload.batch_update(tenant_id='tenant_id', )
        """
        _response = self._raw_client.batch_update(
            tenant_id=tenant_id,
            files=files,
            sub_tenant_id=sub_tenant_id,
            source_ids=source_ids,
            tenant_metadata=tenant_metadata,
            document_metadata=document_metadata,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    def upload_document(
        self,
        *,
        tenant_id: str,
        file: core.File,
        sub_tenant_id: typing.Optional[str] = None,
        tenant_metadata: typing.Optional[str] = OMIT,
        document_metadata: typing.Optional[str] = OMIT,
        relations: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Parameters
        ----------
        tenant_id : str

        file : core.File
            See core.File for more documentation

        sub_tenant_id : typing.Optional[str]

        tenant_metadata : typing.Optional[str]

        document_metadata : typing.Optional[str]

        relations : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        from usecortex-ai import CortexAI

        client = CortexAI(token="YOUR_TOKEN", )
        client.upload.upload_document(tenant_id='tenant_id', )
        """
        _response = self._raw_client.upload_document(
            tenant_id=tenant_id,
            file=file,
            sub_tenant_id=sub_tenant_id,
            tenant_metadata=tenant_metadata,
            document_metadata=document_metadata,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    def update_document(
        self,
        *,
        source_id: str,
        tenant_id: str,
        file: core.File,
        sub_tenant_id: typing.Optional[str] = None,
        tenant_metadata: typing.Optional[str] = OMIT,
        document_metadata: typing.Optional[str] = OMIT,
        relations: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Parameters
        ----------
        source_id : str

        tenant_id : str

        file : core.File
            See core.File for more documentation

        sub_tenant_id : typing.Optional[str]

        tenant_metadata : typing.Optional[str]

        document_metadata : typing.Optional[str]

        relations : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        from usecortex-ai import CortexAI

        client = CortexAI(token="YOUR_TOKEN", )
        client.upload.update_document(source_id='source_id', tenant_id='tenant_id', )
        """
        _response = self._raw_client.update_document(
            source_id=source_id,
            tenant_id=tenant_id,
            file=file,
            sub_tenant_id=sub_tenant_id,
            tenant_metadata=tenant_metadata,
            document_metadata=document_metadata,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    def upload_app_sources(
        self,
        *,
        tenant_id: str,
        request: typing.Sequence[SourceModel],
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AppSourcesUploadData:
        """
        Parameters
        ----------
        tenant_id : str

        request : typing.Sequence[SourceModel]

        sub_tenant_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AppSourcesUploadData
            Successful Response

        Examples
        --------
        from usecortex-ai import CortexAI, SourceModel

        client = CortexAI(token="YOUR_TOKEN", )
        client.upload.upload_app_sources(tenant_id='tenant_id', request=[SourceModel()], )
        """
        _response = self._raw_client.upload_app_sources(
            tenant_id=tenant_id, request=request, sub_tenant_id=sub_tenant_id, request_options=request_options
        )
        return _response.data

    def upload_markdown(
        self,
        *,
        tenant_id: str,
        content: str,
        sub_tenant_id: typing.Optional[str] = None,
        tenant_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        document_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        relations: typing.Optional[Relations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Upload markdown content. If request.document_metadata contains a 'file_id' key (non-empty), it will be used as the file ID;
        otherwise, a new file_id will be generated for that file. This allows file-specific IDs to be set directly in the metadata.

        Parameters
        ----------
        tenant_id : str

        content : str

        sub_tenant_id : typing.Optional[str]

        tenant_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        document_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        relations : typing.Optional[Relations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        from usecortex-ai import CortexAI

        client = CortexAI(token="YOUR_TOKEN", )
        client.upload.upload_markdown(tenant_id='tenant_id', content='content', )
        """
        _response = self._raw_client.upload_markdown(
            tenant_id=tenant_id,
            content=content,
            sub_tenant_id=sub_tenant_id,
            tenant_metadata=tenant_metadata,
            document_metadata=document_metadata,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    def upload_text(
        self,
        *,
        tenant_id: str,
        content: str,
        sub_tenant_id: typing.Optional[str] = None,
        tenant_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        document_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        relations: typing.Optional[Relations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Upload markdown content. If request.document_metadata contains a 'file_id' key (non-empty), it will be used as the file ID;
        otherwise, a new file_id will be generated for that file. This allows file-specific IDs to be set directly in the metadata.

        Parameters
        ----------
        tenant_id : str

        content : str

        sub_tenant_id : typing.Optional[str]

        tenant_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        document_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        relations : typing.Optional[Relations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        from usecortex-ai import CortexAI

        client = CortexAI(token="YOUR_TOKEN", )
        client.upload.upload_text(tenant_id='tenant_id', content='content', )
        """
        _response = self._raw_client.upload_text(
            tenant_id=tenant_id,
            content=content,
            sub_tenant_id=sub_tenant_id,
            tenant_metadata=tenant_metadata,
            document_metadata=document_metadata,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    def update_markdown(
        self,
        *,
        source_id: str,
        tenant_id: str,
        content: str,
        sub_tenant_id: typing.Optional[str] = None,
        tenant_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        document_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        relations: typing.Optional[Relations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Parameters
        ----------
        source_id : str

        tenant_id : str

        content : str

        sub_tenant_id : typing.Optional[str]

        tenant_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        document_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        relations : typing.Optional[Relations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        from usecortex-ai import CortexAI

        client = CortexAI(token="YOUR_TOKEN", )
        client.upload.update_markdown(source_id='source_id', tenant_id='tenant_id', content='content', )
        """
        _response = self._raw_client.update_markdown(
            source_id=source_id,
            tenant_id=tenant_id,
            content=content,
            sub_tenant_id=sub_tenant_id,
            tenant_metadata=tenant_metadata,
            document_metadata=document_metadata,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    def update_text(
        self,
        *,
        source_id: str,
        tenant_id: str,
        content: str,
        sub_tenant_id: typing.Optional[str] = None,
        tenant_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        document_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        relations: typing.Optional[Relations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Parameters
        ----------
        source_id : str

        tenant_id : str

        content : str

        sub_tenant_id : typing.Optional[str]

        tenant_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        document_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        relations : typing.Optional[Relations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        from usecortex-ai import CortexAI

        client = CortexAI(token="YOUR_TOKEN", )
        client.upload.update_text(source_id='source_id', tenant_id='tenant_id', content='content', )
        """
        _response = self._raw_client.update_text(
            source_id=source_id,
            tenant_id=tenant_id,
            content=content,
            sub_tenant_id=sub_tenant_id,
            tenant_metadata=tenant_metadata,
            document_metadata=document_metadata,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    def upload_embeddings(
        self,
        *,
        tenant_id: str,
        embeddings: typing.Sequence[typing.Sequence[float]],
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Parameters
        ----------
        tenant_id : str

        embeddings : typing.Sequence[typing.Sequence[float]]

        sub_tenant_id : typing.Optional[str]

        file_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        from usecortex-ai import CortexAI

        client = CortexAI(token="YOUR_TOKEN", )
        client.upload.upload_embeddings(tenant_id='tenant_id', embeddings=[[1.1]], )
        """
        _response = self._raw_client.upload_embeddings(
            tenant_id=tenant_id,
            embeddings=embeddings,
            sub_tenant_id=sub_tenant_id,
            file_id=file_id,
            request_options=request_options,
        )
        return _response.data

    def update_embeddings(
        self,
        *,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = None,
        embeddings: typing.Optional[typing.Dict[str, typing.Sequence[float]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Parameters
        ----------
        tenant_id : str

        sub_tenant_id : typing.Optional[str]

        embeddings : typing.Optional[typing.Dict[str, typing.Sequence[float]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        from usecortex-ai import CortexAI

        client = CortexAI(token="YOUR_TOKEN", )
        client.upload.update_embeddings(tenant_id='tenant_id', )
        """
        _response = self._raw_client.update_embeddings(
            tenant_id=tenant_id, sub_tenant_id=sub_tenant_id, embeddings=embeddings, request_options=request_options
        )
        return _response.data

    def scrape_webpage(
        self,
        *,
        web_url: str,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = None,
        relations: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Parameters
        ----------
        web_url : str

        tenant_id : str

        sub_tenant_id : typing.Optional[str]

        file_id : typing.Optional[str]

        relations : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        from usecortex-ai import CortexAI

        client = CortexAI(token="YOUR_TOKEN", )
        client.upload.scrape_webpage(web_url='web_url', tenant_id='tenant_id', )
        """
        _response = self._raw_client.scrape_webpage(
            web_url=web_url,
            tenant_id=tenant_id,
            sub_tenant_id=sub_tenant_id,
            file_id=file_id,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    def update_webpage(
        self,
        *,
        web_url: str,
        source_id: str,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = None,
        relations: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Parameters
        ----------
        web_url : str

        source_id : str

        tenant_id : str

        sub_tenant_id : typing.Optional[str]

        relations : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        from usecortex-ai import CortexAI

        client = CortexAI(token="YOUR_TOKEN", )
        client.upload.update_webpage(web_url='web_url', source_id='source_id', tenant_id='tenant_id', )
        """
        _response = self._raw_client.update_webpage(
            web_url=web_url,
            source_id=source_id,
            tenant_id=tenant_id,
            sub_tenant_id=sub_tenant_id,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    def delete_source(
        self,
        *,
        tenant_id: str,
        source_ids: typing.Sequence[str],
        sub_tenant_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Parameters
        ----------
        tenant_id : str

        source_ids : typing.Sequence[str]

        sub_tenant_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        from usecortex-ai import CortexAI

        client = CortexAI(token="YOUR_TOKEN", )
        client.upload.delete_source(tenant_id='tenant_id', source_ids=['source_ids'], )
        """
        _response = self._raw_client.delete_source(
            tenant_id=tenant_id, source_ids=source_ids, sub_tenant_id=sub_tenant_id, request_options=request_options
        )
        return _response.data

    def delete_memory(
        self,
        *,
        tenant_id: str,
        source_ids: typing.Sequence[str],
        sub_tenant_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Parameters
        ----------
        tenant_id : str

        source_ids : typing.Sequence[str]

        sub_tenant_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        from usecortex-ai import CortexAI

        client = CortexAI(token="YOUR_TOKEN", )
        client.upload.delete_memory(tenant_id='tenant_id', source_ids=['source_ids'], )
        """
        _response = self._raw_client.delete_memory(
            tenant_id=tenant_id, source_ids=source_ids, sub_tenant_id=sub_tenant_id, request_options=request_options
        )
        return _response.data

    def verify_processing(
        self,
        *,
        file_id: str,
        tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProcessingStatus:
        """
        Verify the processing status of an uploaded file.

        Returns:
            ProcessingStatusResponse: Processing status information

        Parameters
        ----------
        file_id : str

        tenant_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProcessingStatus
            Successful Response

        Examples
        --------
        from usecortex-ai import CortexAI

        client = CortexAI(token="YOUR_TOKEN", )
        client.upload.verify_processing(file_id='file_id', )
        """
        _response = self._raw_client.verify_processing(
            file_id=file_id, tenant_id=tenant_id, request_options=request_options
        )
        return _response.data


class AsyncUploadClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._raw_client = AsyncRawUploadClient(client_wrapper=client_wrapper)

    @property
    def with_raw_response(self) -> AsyncRawUploadClient:
        """
        Retrieves a raw implementation of this client that returns raw responses.

        Returns
        -------
        AsyncRawUploadClient
        """
        return self._raw_client

    async def batch_upload(
        self,
        *,
        tenant_id: str,
        files: typing.List[core.File],
        sub_tenant_id: typing.Optional[str] = None,
        tenant_metadata: typing.Optional[str] = OMIT,
        document_metadata: typing.Optional[str] = OMIT,
        relations: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BatchUploadData:
        """
        Parameters
        ----------
        tenant_id : str

        files : typing.List[core.File]
            See core.File for more documentation

        sub_tenant_id : typing.Optional[str]

        tenant_metadata : typing.Optional[str]

        document_metadata : typing.Optional[str]

        relations : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BatchUploadData
            Successful Response

        Examples
        --------
        import asyncio

        from usecortex-ai import AsyncCortexAI

        client = AsyncCortexAI(token="YOUR_TOKEN", )
        async def main() -> None:
            await client.upload.batch_upload(tenant_id='tenant_id', )
        asyncio.run(main())
        """
        _response = await self._raw_client.batch_upload(
            tenant_id=tenant_id,
            files=files,
            sub_tenant_id=sub_tenant_id,
            tenant_metadata=tenant_metadata,
            document_metadata=document_metadata,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    async def batch_update(
        self,
        *,
        tenant_id: str,
        files: typing.List[core.File],
        sub_tenant_id: typing.Optional[str] = None,
        source_ids: typing.Optional[typing.List[str]] = OMIT,
        tenant_metadata: typing.Optional[str] = OMIT,
        document_metadata: typing.Optional[str] = OMIT,
        relations: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> BatchUploadData:
        """
        Parameters
        ----------
        tenant_id : str

        files : typing.List[core.File]
            See core.File for more documentation

        sub_tenant_id : typing.Optional[str]

        source_ids : typing.Optional[typing.List[str]]

        tenant_metadata : typing.Optional[str]

        document_metadata : typing.Optional[str]

        relations : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        BatchUploadData
            Successful Response

        Examples
        --------
        import asyncio

        from usecortex-ai import AsyncCortexAI

        client = AsyncCortexAI(token="YOUR_TOKEN", )
        async def main() -> None:
            await client.upload.batch_update(tenant_id='tenant_id', )
        asyncio.run(main())
        """
        _response = await self._raw_client.batch_update(
            tenant_id=tenant_id,
            files=files,
            sub_tenant_id=sub_tenant_id,
            source_ids=source_ids,
            tenant_metadata=tenant_metadata,
            document_metadata=document_metadata,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    async def upload_document(
        self,
        *,
        tenant_id: str,
        file: core.File,
        sub_tenant_id: typing.Optional[str] = None,
        tenant_metadata: typing.Optional[str] = OMIT,
        document_metadata: typing.Optional[str] = OMIT,
        relations: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Parameters
        ----------
        tenant_id : str

        file : core.File
            See core.File for more documentation

        sub_tenant_id : typing.Optional[str]

        tenant_metadata : typing.Optional[str]

        document_metadata : typing.Optional[str]

        relations : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        import asyncio

        from usecortex-ai import AsyncCortexAI

        client = AsyncCortexAI(token="YOUR_TOKEN", )
        async def main() -> None:
            await client.upload.upload_document(tenant_id='tenant_id', )
        asyncio.run(main())
        """
        _response = await self._raw_client.upload_document(
            tenant_id=tenant_id,
            file=file,
            sub_tenant_id=sub_tenant_id,
            tenant_metadata=tenant_metadata,
            document_metadata=document_metadata,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    async def update_document(
        self,
        *,
        source_id: str,
        tenant_id: str,
        file: core.File,
        sub_tenant_id: typing.Optional[str] = None,
        tenant_metadata: typing.Optional[str] = OMIT,
        document_metadata: typing.Optional[str] = OMIT,
        relations: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Parameters
        ----------
        source_id : str

        tenant_id : str

        file : core.File
            See core.File for more documentation

        sub_tenant_id : typing.Optional[str]

        tenant_metadata : typing.Optional[str]

        document_metadata : typing.Optional[str]

        relations : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        import asyncio

        from usecortex-ai import AsyncCortexAI

        client = AsyncCortexAI(token="YOUR_TOKEN", )
        async def main() -> None:
            await client.upload.update_document(source_id='source_id', tenant_id='tenant_id', )
        asyncio.run(main())
        """
        _response = await self._raw_client.update_document(
            source_id=source_id,
            tenant_id=tenant_id,
            file=file,
            sub_tenant_id=sub_tenant_id,
            tenant_metadata=tenant_metadata,
            document_metadata=document_metadata,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    async def upload_app_sources(
        self,
        *,
        tenant_id: str,
        request: typing.Sequence[SourceModel],
        sub_tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AppSourcesUploadData:
        """
        Parameters
        ----------
        tenant_id : str

        request : typing.Sequence[SourceModel]

        sub_tenant_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AppSourcesUploadData
            Successful Response

        Examples
        --------
        import asyncio

        from usecortex-ai import AsyncCortexAI, SourceModel

        client = AsyncCortexAI(token="YOUR_TOKEN", )
        async def main() -> None:
            await client.upload.upload_app_sources(tenant_id='tenant_id', request=[SourceModel()], )
        asyncio.run(main())
        """
        _response = await self._raw_client.upload_app_sources(
            tenant_id=tenant_id, request=request, sub_tenant_id=sub_tenant_id, request_options=request_options
        )
        return _response.data

    async def upload_markdown(
        self,
        *,
        tenant_id: str,
        content: str,
        sub_tenant_id: typing.Optional[str] = None,
        tenant_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        document_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        relations: typing.Optional[Relations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Upload markdown content. If request.document_metadata contains a 'file_id' key (non-empty), it will be used as the file ID;
        otherwise, a new file_id will be generated for that file. This allows file-specific IDs to be set directly in the metadata.

        Parameters
        ----------
        tenant_id : str

        content : str

        sub_tenant_id : typing.Optional[str]

        tenant_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        document_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        relations : typing.Optional[Relations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        import asyncio

        from usecortex-ai import AsyncCortexAI

        client = AsyncCortexAI(token="YOUR_TOKEN", )
        async def main() -> None:
            await client.upload.upload_markdown(tenant_id='tenant_id', content='content', )
        asyncio.run(main())
        """
        _response = await self._raw_client.upload_markdown(
            tenant_id=tenant_id,
            content=content,
            sub_tenant_id=sub_tenant_id,
            tenant_metadata=tenant_metadata,
            document_metadata=document_metadata,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    async def upload_text(
        self,
        *,
        tenant_id: str,
        content: str,
        sub_tenant_id: typing.Optional[str] = None,
        tenant_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        document_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        relations: typing.Optional[Relations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Upload markdown content. If request.document_metadata contains a 'file_id' key (non-empty), it will be used as the file ID;
        otherwise, a new file_id will be generated for that file. This allows file-specific IDs to be set directly in the metadata.

        Parameters
        ----------
        tenant_id : str

        content : str

        sub_tenant_id : typing.Optional[str]

        tenant_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        document_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        relations : typing.Optional[Relations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        import asyncio

        from usecortex-ai import AsyncCortexAI

        client = AsyncCortexAI(token="YOUR_TOKEN", )
        async def main() -> None:
            await client.upload.upload_text(tenant_id='tenant_id', content='content', )
        asyncio.run(main())
        """
        _response = await self._raw_client.upload_text(
            tenant_id=tenant_id,
            content=content,
            sub_tenant_id=sub_tenant_id,
            tenant_metadata=tenant_metadata,
            document_metadata=document_metadata,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    async def update_markdown(
        self,
        *,
        source_id: str,
        tenant_id: str,
        content: str,
        sub_tenant_id: typing.Optional[str] = None,
        tenant_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        document_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        relations: typing.Optional[Relations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Parameters
        ----------
        source_id : str

        tenant_id : str

        content : str

        sub_tenant_id : typing.Optional[str]

        tenant_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        document_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        relations : typing.Optional[Relations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        import asyncio

        from usecortex-ai import AsyncCortexAI

        client = AsyncCortexAI(token="YOUR_TOKEN", )
        async def main() -> None:
            await client.upload.update_markdown(source_id='source_id', tenant_id='tenant_id', content='content', )
        asyncio.run(main())
        """
        _response = await self._raw_client.update_markdown(
            source_id=source_id,
            tenant_id=tenant_id,
            content=content,
            sub_tenant_id=sub_tenant_id,
            tenant_metadata=tenant_metadata,
            document_metadata=document_metadata,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    async def update_text(
        self,
        *,
        source_id: str,
        tenant_id: str,
        content: str,
        sub_tenant_id: typing.Optional[str] = None,
        tenant_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        document_metadata: typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]] = OMIT,
        relations: typing.Optional[Relations] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Parameters
        ----------
        source_id : str

        tenant_id : str

        content : str

        sub_tenant_id : typing.Optional[str]

        tenant_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        document_metadata : typing.Optional[typing.Dict[str, typing.Optional[typing.Any]]]

        relations : typing.Optional[Relations]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        import asyncio

        from usecortex-ai import AsyncCortexAI

        client = AsyncCortexAI(token="YOUR_TOKEN", )
        async def main() -> None:
            await client.upload.update_text(source_id='source_id', tenant_id='tenant_id', content='content', )
        asyncio.run(main())
        """
        _response = await self._raw_client.update_text(
            source_id=source_id,
            tenant_id=tenant_id,
            content=content,
            sub_tenant_id=sub_tenant_id,
            tenant_metadata=tenant_metadata,
            document_metadata=document_metadata,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    async def upload_embeddings(
        self,
        *,
        tenant_id: str,
        embeddings: typing.Sequence[typing.Sequence[float]],
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Parameters
        ----------
        tenant_id : str

        embeddings : typing.Sequence[typing.Sequence[float]]

        sub_tenant_id : typing.Optional[str]

        file_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        import asyncio

        from usecortex-ai import AsyncCortexAI

        client = AsyncCortexAI(token="YOUR_TOKEN", )
        async def main() -> None:
            await client.upload.upload_embeddings(tenant_id='tenant_id', embeddings=[[1.1]], )
        asyncio.run(main())
        """
        _response = await self._raw_client.upload_embeddings(
            tenant_id=tenant_id,
            embeddings=embeddings,
            sub_tenant_id=sub_tenant_id,
            file_id=file_id,
            request_options=request_options,
        )
        return _response.data

    async def update_embeddings(
        self,
        *,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = None,
        embeddings: typing.Optional[typing.Dict[str, typing.Sequence[float]]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Parameters
        ----------
        tenant_id : str

        sub_tenant_id : typing.Optional[str]

        embeddings : typing.Optional[typing.Dict[str, typing.Sequence[float]]]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        import asyncio

        from usecortex-ai import AsyncCortexAI

        client = AsyncCortexAI(token="YOUR_TOKEN", )
        async def main() -> None:
            await client.upload.update_embeddings(tenant_id='tenant_id', )
        asyncio.run(main())
        """
        _response = await self._raw_client.update_embeddings(
            tenant_id=tenant_id, sub_tenant_id=sub_tenant_id, embeddings=embeddings, request_options=request_options
        )
        return _response.data

    async def scrape_webpage(
        self,
        *,
        web_url: str,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = None,
        file_id: typing.Optional[str] = None,
        relations: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Parameters
        ----------
        web_url : str

        tenant_id : str

        sub_tenant_id : typing.Optional[str]

        file_id : typing.Optional[str]

        relations : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        import asyncio

        from usecortex-ai import AsyncCortexAI

        client = AsyncCortexAI(token="YOUR_TOKEN", )
        async def main() -> None:
            await client.upload.scrape_webpage(web_url='web_url', tenant_id='tenant_id', )
        asyncio.run(main())
        """
        _response = await self._raw_client.scrape_webpage(
            web_url=web_url,
            tenant_id=tenant_id,
            sub_tenant_id=sub_tenant_id,
            file_id=file_id,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    async def update_webpage(
        self,
        *,
        web_url: str,
        source_id: str,
        tenant_id: str,
        sub_tenant_id: typing.Optional[str] = None,
        relations: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SingleUploadData:
        """
        Parameters
        ----------
        web_url : str

        source_id : str

        tenant_id : str

        sub_tenant_id : typing.Optional[str]

        relations : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SingleUploadData
            Successful Response

        Examples
        --------
        import asyncio

        from usecortex-ai import AsyncCortexAI

        client = AsyncCortexAI(token="YOUR_TOKEN", )
        async def main() -> None:
            await client.upload.update_webpage(web_url='web_url', source_id='source_id', tenant_id='tenant_id', )
        asyncio.run(main())
        """
        _response = await self._raw_client.update_webpage(
            web_url=web_url,
            source_id=source_id,
            tenant_id=tenant_id,
            sub_tenant_id=sub_tenant_id,
            relations=relations,
            request_options=request_options,
        )
        return _response.data

    async def delete_source(
        self,
        *,
        tenant_id: str,
        source_ids: typing.Sequence[str],
        sub_tenant_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Parameters
        ----------
        tenant_id : str

        source_ids : typing.Sequence[str]

        sub_tenant_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        import asyncio

        from usecortex-ai import AsyncCortexAI

        client = AsyncCortexAI(token="YOUR_TOKEN", )
        async def main() -> None:
            await client.upload.delete_source(tenant_id='tenant_id', source_ids=['source_ids'], )
        asyncio.run(main())
        """
        _response = await self._raw_client.delete_source(
            tenant_id=tenant_id, source_ids=source_ids, sub_tenant_id=sub_tenant_id, request_options=request_options
        )
        return _response.data

    async def delete_memory(
        self,
        *,
        tenant_id: str,
        source_ids: typing.Sequence[str],
        sub_tenant_id: typing.Optional[str] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Optional[typing.Any]:
        """
        Parameters
        ----------
        tenant_id : str

        source_ids : typing.Sequence[str]

        sub_tenant_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        typing.Optional[typing.Any]
            Successful Response

        Examples
        --------
        import asyncio

        from usecortex-ai import AsyncCortexAI

        client = AsyncCortexAI(token="YOUR_TOKEN", )
        async def main() -> None:
            await client.upload.delete_memory(tenant_id='tenant_id', source_ids=['source_ids'], )
        asyncio.run(main())
        """
        _response = await self._raw_client.delete_memory(
            tenant_id=tenant_id, source_ids=source_ids, sub_tenant_id=sub_tenant_id, request_options=request_options
        )
        return _response.data

    async def verify_processing(
        self,
        *,
        file_id: str,
        tenant_id: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ProcessingStatus:
        """
        Verify the processing status of an uploaded file.

        Returns:
            ProcessingStatusResponse: Processing status information

        Parameters
        ----------
        file_id : str

        tenant_id : typing.Optional[str]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ProcessingStatus
            Successful Response

        Examples
        --------
        import asyncio

        from usecortex-ai import AsyncCortexAI

        client = AsyncCortexAI(token="YOUR_TOKEN", )
        async def main() -> None:
            await client.upload.verify_processing(file_id='file_id', )
        asyncio.run(main())
        """
        _response = await self._raw_client.verify_processing(
            file_id=file_id, tenant_id=tenant_id, request_options=request_options
        )
        return _response.data
