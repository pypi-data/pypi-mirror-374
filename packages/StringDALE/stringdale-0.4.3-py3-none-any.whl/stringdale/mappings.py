# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/003_object_mappings.ipynb.

# %% auto 0
__all__ = ['logger', 'lark_edge_parser', 'access_object', 'set_access', 'assert_keys_contiguous', 'object_to_args_kwargs',
           'map_object', 'append_dicts', 'multi_map', 'parse_edge_descriptor']

# %% ../nbs/003_object_mappings.ipynb 6
import os
import enum
from pathlib import Path
from copy import deepcopy
import itertools
import functools
from enum import Enum
from parse import parse
from typing import Any
from copy import deepcopy,copy


from collections import defaultdict,OrderedDict
from contextlib import ExitStack
from singleton_decorator import singleton

from pprint import pprint
from pydantic import BaseModel
from pydantic_core import SchemaValidator

from typing import Optional,Union,List,Dict,Any,Literal

import networkx as nx
from networkx.readwrite import json_graph
from fastcore.basics import patch
from tqdm.auto import tqdm
import logging


# %% ../nbs/003_object_mappings.ipynb 7
logger = logging.getLogger(__name__)

# %% ../nbs/003_object_mappings.ipynb 9
from .core import jinja_render,checkLogs,maybe_await,_duplicates

from textwrap import dedent
from parse import parse
import re
import itertools as it
import types
import uuid
import time
import json

# %% ../nbs/003_object_mappings.ipynb 11
def access_object(obj, attr_path, missing_ok=False):
    """Access an attribute or item of an object, using a path of attribute/item names.
    
    Args:
        obj: The object to access
        attr_path: A string or tuple/list of strings representing the path to the attribute/item
        missing_ok: If True, return None if the attribute/item is not found
    """
    if isinstance(attr_path, str):
        attr_path = (attr_path,)
    elif isinstance(attr_path, (tuple, list)):
        pass
    else:
        raise ValueError(f"Invalid attribute path {attr_path}, must be a string or a tuple/list of strings")

    inner_obj = obj
    for attribute_name in attr_path:
        if attribute_name == ".":
            continue  # Keep current object
        elif attribute_name == "**":
            if isinstance(inner_obj, dict):
                continue  # Keep current dict
            else:
                inner_obj = vars(inner_obj)
                continue
        
        # Try both attribute and item access
        attr_error = item_error = None
        try:
            inner_obj = getattr(inner_obj, attribute_name)
            continue  # If successful, continue to next attribute
        except (AttributeError, TypeError) as e:
            attr_error = e
        
        try:
            inner_obj = inner_obj[attribute_name]
            continue  # If successful, continue to next attribute
        except (KeyError, IndexError, TypeError) as e:
            item_error = e
        
        # If both attempts failed
        if missing_ok:
            return None
        else:
            raise ValueError(f"When navigating path\n{attr_path} on object\n{obj}:\n"
                           f"attribute '{attribute_name}' is not a valid attribute or item of subobject:\n{inner_obj}")
    
    return inner_obj

# %% ../nbs/003_object_mappings.ipynb 18
def set_access(obj, attr_path, value):
    """set an attribute or item of an object, using a path of attribute/item names.
    
    Args:
        obj: The object to set
        attr_path: A string or tuple/list of strings representing the path to the attribute/item
        value: The value to set
    """
    sub_obj = obj
    for attr in attr_path[:-1]:
        if attr not in sub_obj:
            sub_obj[attr] = {}
        sub_obj = sub_obj[attr]
    sub_obj[attr_path[-1]] = value

# %% ../nbs/003_object_mappings.ipynb 22
def assert_keys_contiguous(list_of_keys):
    numbers = sorted(key for key in list_of_keys if isinstance(key,int))
    if len(numbers) > 0 and numbers[0] != 0:
        return False
    return all(numbers[i+1] - numbers[i] == 1 
                for i in range(len(numbers)-1))



# %% ../nbs/003_object_mappings.ipynb 24
def object_to_args_kwargs(input):
    arg_keys = sorted([i for i in input.keys() if isinstance(i,int)])
    args = [input[i] for i in arg_keys]
    kwargs = {k:v for k,v in input.items() if not isinstance(k,int)}
    return args,kwargs


# %% ../nbs/003_object_mappings.ipynb 27
def map_object(obj,mapping):
    """Map an object according to a mapping.
    
    Args:
        obj: The object to map
        mapping: A mapping of the form {key: accessor}
    Returns:
        A dict with the mapped values
    """
    mapped_dict = {}
    for key,access_path in mapping.items():
        if key == '_':
            continue
        elif access_path == '_' or '_' in access_path:
            raise ValueError(f"Invalid access path {access_path}, must not contain '_'")
        elif key == "**":
            mapped_dict.update(access_object(obj,access_path))
        else:
            mapped_dict[key] = access_object(obj,access_path)
    return mapped_dict

# %% ../nbs/003_object_mappings.ipynb 29
def append_dicts(dict_list: list[dict]) -> dict:
    """Combine multiple dictionaries with the same keys into a single dictionary where each value is a list.
    
    Args:
        dict_list: List of dictionaries with the same keys
        
    Returns:
        A dictionary where each key maps to a list of values from the input dictionaries
        
    Example:
        >>> dicts = [{'a': 1, 'b': 2}, {'a': 3, 'b': 4}]
        >>> append_dicts(dicts)
        {'a': [1, 3], 'b': [2, 4]}
    """
    if not dict_list:
        return {}
    
    result = defaultdict(list)
    for d in dict_list:
        for key, value in d.items():
            result[key].append(value)
    
    return dict(result)

# %% ../nbs/003_object_mappings.ipynb 30
def multi_map(obj_dict,mappings_dict,as_list_keys=None):
    """Map a dictionary of objects according to a dictionary of mappings.
    
    Args:
        obj_dict: A dictionary of objects to map {obj_name:obj}
        mappings_dict: A dictionary of mappings of the form {mapping_name:mapping}
    Returns:
        A dictionary that is the union of the mapped objects {obj_name:mapped_obj}
        If a key is present in multiple mappings, the value from the last mapping will be used.
        If an obj referenced in the mapping dict is not found in the obj_dict, it will be skipped.
    """
    if as_list_keys is None:
        as_list_keys = set()
    mapped_dict = {}
    for mapping_name,mapping in mappings_dict.items():
        if not mapping_name in obj_dict:
            continue
        if mapping_name in as_list_keys:
            sub_objects_list = [map_object(obj,mapping) for obj in obj_dict[mapping_name]]
            sub_obj = append_dicts(sub_objects_list)
        else:
            sub_obj = map_object(obj_dict[mapping_name],mapping)

        mapped_dict.update(sub_obj)
    return mapped_dict

# %% ../nbs/003_object_mappings.ipynb 34
from lark import Lark, Transformer


_EDGE_GRAMMAR = """
    %import common.WS
    %ignore WS
    NAME: /[a-zA-Z0-9_<>]+/  
    
    accessor_step : NAME 
        | "**" -> kwargs_accessor
        | "." -> self_accessor
        | "_" -> underscore

    accessor: accessor_step ("." accessor_step)*

    accessor_assignment: accessor "=" accessor

    state: ("state"|"State") "/" NAME

    map_key: NAME
        | "**" -> kwargs_map_key

    single_map: map_key -> implicit_map
        | map_key "=" accessor -> keyword_map

    mapping_expr: single_map 
        | "(" single_map ("," single_map)* ")"

    edge: NAME "->" NAME ( mapping_expr )?
        | NAME "->" state ( mapping_expr )? -> write_edge
        | state "->" NAME ( mapping_expr )? -> read_edge
    

    implicit_edge: NAME ( mapping_expr )?
        | state ( mapping_expr )? -> implicit_state_edge

"""


# %% ../nbs/003_object_mappings.ipynb 35
class _EdgeTransformer(Transformer):
    def NAME(self, item):
        try:
            return int(item)
        except:
            return str(item)

    def accessor_step(self, items):
        return items[0]

    def map_key(self, items):
        return items[0]

    def kwargs_map_key(self, items):
        return '**'

    def self_accessor(self, items):
        return '.'

    def kwargs_accessor(self, items):
        return '**'

    def underscore(self, items):
        return '_'

    def accessor(self, items):
        return tuple(items)

    def accessor_assignment(self, items):
        return items[0],items[1]

    def implicit_map(self, items):
        name = items[0]
        return {name:('.',)}

    def keyword_map(self, items):
        name, accessor = items
        return {name:accessor}



    def mapping_expr(self, items):
        mapping_dict = {}
        for item in items:
            mapping_dict.update(item)
        return mapping_dict

    def state(self,items):
        return items[0] # return the key

    def _default_mapping(self,):
        return {0:('.',)}


    def edge(self,items):
        return {
                'edge_type':'edge',
                'source_node':items[0],
                'target_node':items[1],
                'mapping':items[2] if len(items) == 3 else self._default_mapping()
            }

    def read_edge(self,items):
        return {
            'edge_type':'read_edge',
            'source_node':items[0],
            'target_node':items[1],
            'mapping':items[2] if len(items) == 3 else self._default_mapping()
        }

    def write_edge(self,items):
        return {
            'edge_type':'write_edge',
            'source_node':items[0],
            'target_node':items[1],
            'mapping':items[2] if len(items) == 3 else self._default_mapping()
        }

    def implicit_edge(self,items):
        return {
            'edge_type':'implicit_edge',
            'node':items[0],
            'mapping':items[1] if len(items) == 2 else self._default_mapping()
        }
    
    def implicit_state_edge(self,items):
        return {
            'edge_type':'implicit_state_edge',
            'node':items[0],
            'mapping':items[1] if len(items) == 2 else self._default_mapping()
        }
    

# %% ../nbs/003_object_mappings.ipynb 36
from lark.visitors import VisitError

# %% ../nbs/003_object_mappings.ipynb 37
lark_edge_parser = Lark(_EDGE_GRAMMAR, parser='lalr',start=['edge','implicit_edge','mapping_expr','accessor_assignment'])

def parse_edge_descriptor(edge_str:str,start='edge'):
 
    try:
        tree = lark_edge_parser.parse(edge_str, start=start)
    except Exception as e:
        raise SyntaxError(f"Edge string '{edge_str}' in not formatted correctly\n"
            f"{e}"
        ) 

    try:
        transformed = _EdgeTransformer().transform(tree)
    except Exception as e:
        raise ValueError(f"Transformation error when parsing edge '{edge_str}'. Parse tree:\n{tree.pretty()}\n"
            f"{e}"
        ) 

    return transformed    


