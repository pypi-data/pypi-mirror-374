"""
I2NeT Decoder Module
Decoding images generated by NeT2i from images to CSV format.
"""

import numpy as np
from PIL import Image
import struct
import os
import json
import csv
from typing import List, Dict, Any, Optional, Tuple
import glob
import ipaddress


class I2NeT_Decoder:
    
    def __init__(self, 
                 types_file_ipv4: str = "data_types.json",
                 types_file_ipv6: str = "data_types_ipv6.json"):
        self.types_file_ipv4 = types_file_ipv4
        self.types_file_ipv6 = types_file_ipv6
        self.ipv4_type_info = None
        self.ipv6_type_info = None
        self.processed_images = 0
        self.total_images = 0
        
    def load_type_information(self, is_ipv6: bool = False) -> Optional[Dict[str, Any]]:
        types_file = self.types_file_ipv6 if is_ipv6 else self.types_file_ipv4
        type_info_attr = 'ipv6_type_info' if is_ipv6 else 'ipv4_type_info'
        
        try:
            if os.path.exists(types_file):
                with open(types_file, 'r') as f:
                    type_info = json.load(f)
                setattr(self, type_info_attr, type_info)
                return type_info
            else:
                print(f"Type file '{types_file}' not found. Using fallback detection.")
                return None
        except Exception as e:
            print(f"Error loading type information from {types_file}: {e}")
            return None
    
    def detect_data_structure_from_rgb_count(self, rgb_count: int, type_info: Optional[Dict] = None) -> Dict[str, Any]:
        if type_info and 'original_types' in type_info:
            original_types = type_info['original_types']
            expected_pixels = self._calculate_expected_pixel_count(original_types)
            
            if rgb_count < expected_pixels:
                truncated_types = self._truncate_types_to_match_data(original_types, rgb_count)
                return {
                    'original_types': truncated_types,
                    'final_types': self._get_final_types_from_original(truncated_types),
                    'truncated': True,
                    'available_pixels': rgb_count,
                    'expected_pixels': expected_pixels
                }
            elif rgb_count >= expected_pixels:
                return type_info
        else:
            float_count = rgb_count // 2
            return {
                'original_types': ['Float'] * float_count,
                'final_types': ['Float'] * float_count,
                'generic': True,
                'available_pixels': rgb_count
            }
    
    def _calculate_expected_pixel_count(self, original_types: List[str]) -> int:
        pixel_count = 0
        for data_type in original_types:
            if data_type == "IPv6 Address":
                pixel_count += 6
            elif data_type == "IPv4 Address":
                pixel_count += 8
            elif data_type == "MAC Address":
                pixel_count += 4
            else:
                pixel_count += 2
        return pixel_count
    
    def _get_final_types_from_original(self, original_types: List[str]) -> List[str]:
        final_types = []
        for orig_type in original_types:
            if orig_type == "IPv4 Address":
                final_types.extend(["IPv4 Address"] * 4)
            elif orig_type == "MAC Address":
                final_types.extend(["MAC Address"] * 2)
            else:
                final_types.append(orig_type)
        return final_types
    
    def _truncate_types_to_match_data(self, original_types: List[str], available_pixels: int) -> List[str]:
        truncated_types = []
        pixel_count = 0
        
        for data_type in original_types:
            if data_type == "IPv6 Address":
                if pixel_count + 6 <= available_pixels:
                    truncated_types.append(data_type)
                    pixel_count += 6
                else:
                    remaining = available_pixels - pixel_count
                    float_count = remaining // 2
                    truncated_types.extend(['Float'] * float_count)
                    break
            elif data_type == "IPv4 Address":
                if pixel_count + 8 <= available_pixels:
                    truncated_types.append(data_type)
                    pixel_count += 8
                else:
                    remaining = available_pixels - pixel_count
                    float_count = remaining // 2
                    truncated_types.extend(['Float'] * float_count)
                    break
            elif data_type == "MAC Address":
                if pixel_count + 4 <= available_pixels:
                    truncated_types.append(data_type)
                    pixel_count += 4
                else:
                    remaining = available_pixels - pixel_count
                    float_count = remaining // 2
                    truncated_types.extend(['Float'] * float_count)
                    break
            else:
                if pixel_count + 2 <= available_pixels:
                    truncated_types.append(data_type)
                    pixel_count += 2
                else:
                    break
        
        return truncated_types
    
    def _two_rgb_pixels_to_float(self, rgb_pixel1: Tuple[int, int, int], rgb_pixel2: Tuple[int, int, int]) -> float:
        try:
            r1, g1, b1 = rgb_pixel1
            r2, g2, b2 = rgb_pixel2
            packed_bytes = bytes([r1, g1, b1, r2])
            float_val = struct.unpack('!f', packed_bytes)[0]
            return float_val
        except Exception as e:
            print(f"Float conversion error: {e}")
            return 0.0
    
    def _six_rgb_pixels_to_ipv6(self, rgb_pixels: List[Tuple[int, int, int]]) -> str:
        try:
            data_bytes = []
            for r, g, b in rgb_pixels:
                data_bytes.extend([r, g, b])
            # Extract first 16 bytes for IPv6
            raw_bytes = bytes(data_bytes[:16])
            ipv6_addr = ipaddress.IPv6Address(raw_bytes)
            return str(ipv6_addr)
        except Exception as e:
            # Optional: debug with print(f"IPv6 decode error: {e}, bytes={data_bytes[:16]}")
            return "::1"
    
    def _extract_rgb_from_image(self, image_path: str) -> List[Tuple[int, int, int]]:
        try:
            img = Image.open(image_path)
            array = np.array(img)
            height, width = array.shape[:2]
            
            stripe_colors = []
            last_color = None
            sample_step = max(1, height // 100)
            
            for row in range(0, height, sample_step):
                current_color = tuple(array[row, 0])
                if last_color is None or current_color != last_color:
                    stripe_colors.append(current_color)
                    last_color = current_color
            
            return stripe_colors
            
        except Exception as e:
            print(f"Error extracting RGB from {image_path}: {e}")
            return []
    
    def _round_floats_in_row(self, row: List[Any]) -> List[Any]:
        """
        Round floats to avoid floating-point noise (e.g., 1.784999 â†’ 1.785)
        Keep integers as int.
        """
        result = []
        for x in row:
            if isinstance(x, float):
                if x.is_integer():
                    result.append(int(x))
                else:
                    # Round to 6 decimals; adjust as needed
                    rounded = round(x, 6)
                    if abs(rounded - round(rounded, 3)) < 1e-5:
                        rounded = round(rounded, 3)
                    result.append(rounded)
            else:
                result.append(x)
        return result

    def _merge_datetime_components(self, values: List[Any]) -> List[Any]:
        """
        Detect 6 consecutive numeric values: [Year, Month, Day, Hour, Minute, Second]
        Merge into "YYYY-MM-DD HH:MM:SS"
        """
        if len(values) < 6:
            return values

        result = []
        i = 0
        while i < len(values):
            if i + 5 < len(values):
                try:
                    nums = [values[i], values[i+1], values[i+2], values[i+3], values[i+4], values[i+5]]
                    parsed = []
                    for x in nums:
                        try:
                            val = int(round(float(x)))
                            parsed.append(val)
                        except:
                            raise ValueError("Not numeric")

                    year, month, day, hour, minute, second = parsed

                    if (1900 <= year <= 2100 and
                        1 <= month <= 12 and
                        1 <= day <= 31 and
                        0 <= hour <= 23 and
                        0 <= minute <= 59 and
                        0 <= second <= 59):

                        # Basic calendar validation
                        if month in [4,6,9,11] and day > 30:
                            pass
                        elif month == 2:
                            leap = (year % 4 == 0 and (year % 100 != 0 or year % 400 == 0))
                            if day > 29 or (day == 29 and not leap):
                                pass
                            else:
                                dt_str = f"{year:04d}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:02d}"
                                result.append(dt_str)
                                i += 6
                                continue
                        else:
                            dt_str = f"{year:04d}-{month:02d}-{day:02d} {hour:02d}:{minute:02d}:{second:02d}"
                            result.append(dt_str)
                            i += 6
                            continue
                except:
                    pass

            result.append(values[i])
            i += 1

        return result

    def _reconstruct_with_adaptive_types(self, rgb_values: List[Tuple[int, int, int]], adaptive_type_info: Dict[str, Any]) -> List[Any]:
        if not adaptive_type_info or 'original_types' not in adaptive_type_info:
            decoded_values = []
            i = 0
            while i + 1 < len(rgb_values):
                float_val = self._two_rgb_pixels_to_float(rgb_values[i], rgb_values[i + 1])
                decoded_values.append(float_val)
                i += 2
            merged = self._merge_datetime_components(decoded_values)
            return self._round_floats_in_row(merged)

        original_types = adaptive_type_info['original_types']
        reconstructed = []
        pixel_idx = 0
        
        for orig_type in original_types:
            if pixel_idx >= len(rgb_values):
                break

            try:
                if orig_type == "IPv6 Address":
                    if pixel_idx + 5 < len(rgb_values):
                        ipv6_pixels = rgb_values[pixel_idx:pixel_idx + 6]
                        ipv6_addr = self._six_rgb_pixels_to_ipv6(ipv6_pixels)
                        reconstructed.append(ipv6_addr)
                        pixel_idx += 6
                    else:
                        remaining = len(rgb_values) - pixel_idx
                        while pixel_idx + 1 < len(rgb_values):
                            float_val = self._two_rgb_pixels_to_float(rgb_values[pixel_idx], rgb_values[pixel_idx + 1])
                            reconstructed.append(float_val)
                            pixel_idx += 2
                        break

                elif orig_type == "IPv4 Address":
                    if pixel_idx + 7 < len(rgb_values):
                        octets = []
                        for j in range(4):
                            octet_float = self._two_rgb_pixels_to_float(
                                rgb_values[pixel_idx + j*2],
                                rgb_values[pixel_idx + j*2 + 1]
                            )
                            octet = max(0, min(255, int(round(octet_float))))
                            octets.append(str(octet))
                        ipv4_addr = ".".join(octets)
                        reconstructed.append(ipv4_addr)
                        pixel_idx += 8
                    else:
                        while pixel_idx + 1 < len(rgb_values):
                            float_val = self._two_rgb_pixels_to_float(rgb_values[pixel_idx], rgb_values[pixel_idx + 1])
                            reconstructed.append(float_val)
                            pixel_idx += 2
                        break

                elif orig_type == "MAC Address":
                    if pixel_idx + 3 < len(rgb_values):
                        chunk1_float = self._two_rgb_pixels_to_float(rgb_values[pixel_idx], rgb_values[pixel_idx + 1])
                        chunk2_float = self._two_rgb_pixels_to_float(rgb_values[pixel_idx + 2], rgb_values[pixel_idx + 3])
                        chunk1 = int(round(chunk1_float)) & 0xFFFFFF
                        chunk2 = int(round(chunk2_float)) & 0xFFFFFF
                        c1 = format(chunk1, '06x')
                        c2 = format(chunk2, '06x')
                        mac = f"{c1[:2]}:{c1[2:4]}:{c1[4:6]}:{c2[:2]}:{c2[2:4]}:{c2[4:6]}"
                        reconstructed.append(mac)
                        pixel_idx += 4
                    else:
                        while pixel_idx + 1 < len(rgb_values):
                            float_val = self._two_rgb_pixels_to_float(rgb_values[pixel_idx], rgb_values[pixel_idx + 1])
                            reconstructed.append(float_val)
                            pixel_idx += 2
                        break

                elif orig_type in ["Float", "Integer", "String"]:
                    if pixel_idx + 1 < len(rgb_values):
                        float_val = self._two_rgb_pixels_to_float(rgb_values[pixel_idx], rgb_values[pixel_idx + 1])
                        if orig_type == "Integer":
                            val = int(round(float_val))
                        elif orig_type == "String":
                            val = f"str_{int(round(float_val))}"
                        else:
                            val = float_val
                        reconstructed.append(val)
                        pixel_idx += 2
                    else:
                        break

                else:
                    if pixel_idx + 1 < len(rgb_values):
                        float_val = self._two_rgb_pixels_to_float(rgb_values[pixel_idx], rgb_values[pixel_idx + 1])
                        reconstructed.append(float_val)
                        pixel_idx += 2
                    else:
                        break

            except Exception as e:
                print(f"Error reconstructing {orig_type}: {e}")
                reconstructed.append("error")
                if orig_type == "IPv6 Address":
                    pixel_idx += 6
                elif orig_type == "IPv4 Address":
                    pixel_idx += 8
                elif orig_type == "MAC Address":
                    pixel_idx += 4
                else:
                    pixel_idx += 2

        # Apply datetime merge and rounding
        merged = self._merge_datetime_components(reconstructed)
        return self._round_floats_in_row(merged)
    
    def decode_single_image(self, image_path: str, is_ipv6: bool = None) -> List[Any]:
        try:
            if is_ipv6 is None:
                filename = os.path.basename(image_path)
                is_ipv6 = filename.startswith('ipv6_')
            
            type_info = self.ipv6_type_info if is_ipv6 else self.ipv4_type_info
            if type_info is None:
                type_info = self.load_type_information(is_ipv6)
            
            rgb_values = self._extract_rgb_from_image(image_path)
            if not rgb_values:
                print(f"No RGB values extracted from {image_path}")
                return []
            
            adaptive_type_info = self.detect_data_structure_from_rgb_count(len(rgb_values), type_info)
            reconstructed = self._reconstruct_with_adaptive_types(rgb_values, adaptive_type_info)
            
            return reconstructed
            
        except Exception as e:
            print(f"Error processing image {image_path}: {e}")
            return []

    def _get_sorted_image_files(self, data_directory: str, prefix: str = None) -> List[str]:
        image_patterns = ['*.png', '*.jpg', '*.jpeg', '*.bmp', '*.tiff']
        image_files = []
        
        for pattern in image_patterns:
            files = glob.glob(os.path.join(data_directory, pattern))
            if prefix:
                files = [f for f in files if os.path.basename(f).startswith(prefix)]
            image_files.extend(files)
        
        def sort_key(filepath):
            filename = os.path.basename(filepath)
            if prefix:
                name_without_prefix = filename[len(prefix):]
            else:
                name_without_prefix = filename
            name_without_ext = os.path.splitext(name_without_prefix)[0]
            if name_without_ext.isdigit():
                return int(name_without_ext)
            else:
                return filename
        
        return sorted(image_files, key=sort_key)
    
    def load_data(self, data_directory: str, verbose: bool = True) -> Dict[str, Any]:
        if not os.path.exists(data_directory):
            raise FileNotFoundError(f"Directory {data_directory} does not exist!")
        
        self.load_type_information(is_ipv6=False)
        self.load_type_information(is_ipv6=True)
        
        results = {
            "input_directory": data_directory,
            "ipv4_results": None,
            "ipv6_results": None,
            "total_images_processed": 0
        }
        
        ipv4_files = self._get_sorted_image_files(data_directory, 'ipv4_')
        if ipv4_files:
            #if verbose:
            #    print(f"Found {len(ipv4_files)} IPv4 images")
            ipv4_results = self._process_image_set(ipv4_files, 'decoded_ipv4.csv', is_ipv6=False, verbose=verbose)
            results["ipv4_results"] = ipv4_results
            results["total_images_processed"] += ipv4_results["processed_images"]
        
        ipv6_files = self._get_sorted_image_files(data_directory, 'ipv6_')
        if ipv6_files:
            #if verbose:
            #    print(f"Found {len(ipv6_files)} IPv6 images")
            ipv6_results = self._process_image_set(ipv6_files, 'decoded_ipv6.csv', is_ipv6=True, verbose=verbose)
            results["ipv6_results"] = ipv6_results
            results["total_images_processed"] += ipv6_results["processed_images"]
        
        other_files = []
        all_files = self._get_sorted_image_files(data_directory)
        for f in all_files:
            filename = os.path.basename(f)
            if not filename.startswith('ipv4_') and not filename.startswith('ipv6_'):
                other_files.append(f)
        
        if other_files:
            if verbose:
                print(f"Found {len(other_files)} images without prefix, processing as IPv4")
            other_results = self._process_image_set(other_files, 'decoded_other.csv', is_ipv6=False, verbose=verbose)
            results["other_results"] = other_results
            results["total_images_processed"] += other_results["processed_images"]
        
        #if verbose:
        #    print(f"\n Decoding completed!")
        
        return results
    
    def _process_image_set(self, image_files: List[str], output_csv: str, is_ipv6: bool, verbose: bool) -> Dict[str, Any]:
        processed_images = 0
        successful_rows = 0
        
        try:
            with open(output_csv, 'w', newline='') as csvfile:
                writer = csv.writer(csvfile)
                
                for i, image_path in enumerate(image_files):
                    try:
                        reconstructed_line = self.decode_single_image(image_path, is_ipv6)
                        
                        if reconstructed_line:
                            writer.writerow(reconstructed_line)
                            successful_rows += 1
                        else:
                            if verbose:
                                print(f"No data extracted from {os.path.basename(image_path)}")
                        
                        processed_images += 1
                        
                        if verbose and (i + 1) % 10 == 0:
                            print(f"Processed {i + 1}/{len(image_files)} {'IPv6' if is_ipv6 else 'IPv4'} images...")
                            
                    except Exception as e:
                        if verbose:
                            print(f"Error processing {os.path.basename(image_path)}: {e}")
                        processed_images += 1
                
                success_rate = (successful_rows / len(image_files)) * 100 if len(image_files) > 0 else 0
                
                return {
                    "output_file": output_csv,
                    "ip_version": "IPv6" if is_ipv6 else "IPv4",
                    "total_images": len(image_files),
                    "processed_images": processed_images,
                    "successful_rows": successful_rows,
                    "success_rate": success_rate,
                    "type_info": self.ipv6_type_info if is_ipv6 else self.ipv4_type_info
                }
                
        except Exception as e:
            error_msg = f"Error creating CSV file {output_csv}: {e}"
            print(error_msg)
            raise RuntimeError(error_msg)



def decode(data_directory: str, 
          output_csv: str,
          types_file_ipv4: str = "data_types.json",
          types_file_ipv6: str = "data_types_ipv6.json",
          verbose: bool = True) -> Dict[str, Any]:
    
    if verbose:
        print(" Starting I2NeT decoding...")
    
    results = load_data_with_ipv4_ipv6_support(
        data_directory=data_directory,
        types_file_ipv4=types_file_ipv4,
        types_file_ipv6=types_file_ipv6,
        verbose=verbose
    )
    
    total_rows = _merge_csv_files(results, output_csv, verbose)
    _cleanup_temp_files(results, verbose)
    
    final_results = {
        "input_directory": data_directory,
        "output_file": output_csv,
        "total_images_processed": results["total_images_processed"],
        "total_rows": total_rows,
        "ipv4_rows": results["ipv4_results"]["successful_rows"] if results.get("ipv4_results") else 0,
        "ipv6_rows": results["ipv6_results"]["successful_rows"] if results.get("ipv6_results") else 0,
        "other_rows": results["other_results"]["successful_rows"] if results.get("other_results") else 0,
        "success": total_rows > 0
    }
    
    if verbose:
        print(f" Output file: {output_csv}")
        #print(f" Total rows decoded: {total_rows}")
        #if final_results['ipv4_rows'] > 0:
        #    print(f"    IPv4 rows: {final_results['ipv4_rows']}")
        #if final_results['ipv6_rows'] > 0:
        #    print(f"    IPv6 rows: {final_results['ipv6_rows']}")
        #if final_results['other_rows'] > 0:
        #    print(f"    Other rows: {final_results['other_rows']}")
    
    return final_results


def load_data_with_ipv4_ipv6_support(data_directory: str,
                                    types_file_ipv4: str = "data_types.json",
                                    types_file_ipv6: str = "data_types_ipv6.json",
                                    verbose: bool = True) -> Dict[str, Any]:
    decoder = I2NeT_Decoder(types_file_ipv4, types_file_ipv6)
    return decoder.load_data(data_directory, verbose)


def _merge_csv_files(results: Dict[str, Any], output_csv: str, verbose: bool) -> int:
    total_rows = 0
    try:
        with open(output_csv, 'w', newline='') as outfile:
            writer = csv.writer(outfile)
            for file_name in ["decoded_ipv4.csv", "decoded_ipv6.csv", "decoded_other.csv"]:
                if os.path.exists(file_name):
                    with open(file_name, 'r') as infile:
                        reader = csv.reader(infile)
                        for row in reader:
                            writer.writerow(row)
                            total_rows += 1
        return total_rows
    except Exception as e:
        print(f"Error merging CSV files: {e}")
        return 0


def _cleanup_temp_files(results: Dict[str, Any], verbose: bool) -> None:
    temp_files = ["decoded_ipv4.csv", "decoded_ipv6.csv", "decoded_other.csv"]
    for temp_file in temp_files:
        try:
            if os.path.exists(temp_file):
                os.remove(temp_file)
        except Exception as e:
            if verbose:
                print(f"Warning: Could not remove {temp_file}: {e}")


def decode_single(image_path: str, 
                 types_file: str = "data_types.json",
                 is_ipv6: bool = None,
                 verbose: bool = False) -> List[Any]:
    if is_ipv6 is None:
        filename = os.path.basename(image_path)
        is_ipv6 = filename.startswith('ipv6_')
    decoder = I2NeT_Decoder(
        types_file_ipv4="data_types.json" if not is_ipv6 else types_file,
        types_file_ipv6="data_types_ipv6.json" if is_ipv6 else types_file
    )
    return decoder.decode_single_image(image_path, is_ipv6)


def get_decoder(types_file_ipv4: str = "data_types.json",
               types_file_ipv6: str = "data_types_ipv6.json") -> I2NeT_Decoder:
    return I2NeT_Decoder(types_file_ipv4, types_file_ipv6)


__all__ = [
    'decode',
    'decode_single', 
    'get_decoder',
    'load_data_with_ipv4_ipv6_support',
    'I2NeT_Decoder'
]