"""DTO domain types."""

from __future__ import annotations

import dataclasses
from dataclasses import dataclass, field
from enum import Enum
from typing import TYPE_CHECKING, Any, Literal, Optional, Union, final, get_type_hints

from typing_extensions import TypeAlias, override

from strawchemy.utils import get_annotations

if TYPE_CHECKING:
    from collections.abc import Callable, Mapping


__all__ = ("DTOAuto", "DTOConfig", "DTOFieldConfig", "DTOMissing", "ExcludeFields", "IncludeFields", "Purpose")

DTOScope: TypeAlias = Literal["global", "dto"]


IncludeFields: TypeAlias = Union[list[str], set[str], Literal["all"]]
ExcludeFields: TypeAlias = Union[list[str], set[str]]


@final
class DTOMissing:
    """A sentinel type to detect if a parameter is supplied or not when.

    constructing pydantic FieldInfo.
    """


@final
class DTOAuto: ...


@final
class DTOSkip: ...


@final
class DTOUnset:
    @override
    def __str__(self) -> str:
        return ""

    @override
    def __repr__(self) -> str:
        return "DTOUnset"

    def __bool__(self) -> bool:
        return False


class Purpose(str, Enum):
    """For identifying the purpose of a DTO to the factory.

    The factory will exclude fields marked as private or read-only on the domain model depending
    on the purpose of the DTO.

    Example:
    ```python
    ReadDTO = dto.factory("AuthorReadDTO", Author, purpose=dto.Purpose.READ)
    ```
    """

    READ = "read"
    """To mark a DTO that is to be used to serialize data returned to
    clients."""
    WRITE = "write"
    """To mark a DTO that is to deserialize and validate data provided by
    clients."""
    COMPLETE = "complete"
    """To mark a DTO that is to deserialize and validate data provided by
    clients. Fields marked as TO_COMPLETE must not be null."""


@dataclass
class PurposeConfig:
    """Mark the field as read-only, or private."""

    type_override: Optional[Any] = DTOMissing
    validator: Optional[Callable[[Any], Any]] = None
    """Single argument callables that are defined on the DTO as validators for the field."""
    alias: Optional[str] = None
    """Customize name of generated DTO field."""
    partial: Optional[bool] = None


@dataclass
class DTOFieldConfig:
    """For configuring DTO behavior on SQLAlchemy model fields."""

    purposes: set[Purpose] = field(default_factory=lambda: {Purpose.READ, Purpose.WRITE})
    default_config: PurposeConfig = field(default_factory=PurposeConfig)
    configs: dict[Purpose, PurposeConfig] = field(default_factory=dict)

    def purpose_config(self, dto_config: DTOConfig) -> PurposeConfig:
        return self.configs.get(dto_config.purpose, self.default_config)


@dataclass
class DTOConfig:
    """Control the generated DTO.

    This class holds configuration settings that influence how a Data Transfer
    Object (DTO) is generated by the DTO factory. It allows customization of
    field inclusion/exclusion, optionality, type hints, and field aliasing based
    on the intended purpose (read, write, etc.) of the DTO.

    Attributes:
        purpose: Configure the DTO for "read", "write", or "complete" operations.
            Determines which fields from the source model are included based on
            their `DTOFieldConfig`.
        include: Explicitly include fields from the source model in the generated
            DTO. Can be a list or set of field names, or the literal "all" to
            include all fields not explicitly excluded. Defaults to an empty set.
        exclude: Explicitly exclude fields from the source model. Can be a list
            or set of field names. Defaults to an empty set. Setting this
            implicitly sets `include` to "all".
        partial: If True, makes all fields in the generated DTO optional.
            Defaults to None.
        partial_default: The default value assigned to fields when `partial` is
            True and the field is not provided. Defaults to None.
        unset_sentinel: A sentinel object used to represent fields that are not
            set, particularly useful when distinguishing between a field explicitly
            set to `None` and a field that was not provided at all. Defaults to
            `DTO_UNSET`.
        type_overrides: A mapping to override the type annotations for specific
            fields in the generated DTO. Keys can be field names or types,
            values are the overriding types. Defaults to an empty dict.
        annotation_overrides: A dictionary to directly set or override the type
            annotations for specific fields by name. Defaults to an empty dict.
        aliases: A mapping of source model field names to their desired names
            (aliases) in the generated DTO. Defaults to an empty dict. Mutually
            exclusive with `alias_generator`.
        alias_generator: A callable that accepts a field name and returns its
            alias for the generated DTO. Defaults to None. Mutually exclusive
            with `aliases`.

    Raises:
        ValueError: If both `aliases` and `alias_generator` are provided, or
            if `exclude` is set while `include` is also set to a specific list/set
            (i.e., not "all" or empty).
    """

    purpose: Purpose
    """Configure the DTO for "read" or "write" operations."""
    include: IncludeFields = field(default_factory=set)
    """Explicitly include fields from the generated DTO."""
    exclude: ExcludeFields = field(default_factory=set)
    """Explicitly exclude fields from the generated DTO. Implies `include="all"`."""
    partial: Optional[bool] = None
    """Make all field optional."""
    partial_default: Any = None
    unset_sentinel: Any = DTOUnset
    type_overrides: Mapping[Any, Any] = field(default_factory=dict)
    annotation_overrides: dict[str, Any] = field(default_factory=dict)
    aliases: Mapping[str, str] = field(default_factory=dict)
    exclude_defaults: bool = False
    alias_generator: Optional[Callable[[str], str]] = None
    scope: Optional[DTOScope] = None
    exclude_from_scope: bool = False
    tags: set[str] = field(default_factory=set)

    def __post_init__(self) -> None:
        if self.aliases and self.alias_generator is not None:
            msg = "You must set `aliases` or `alias_generator`, not both"
            raise ValueError(msg)
        if self.include and self.include != "all" and self.exclude:
            msg = "When using `exclude` you must set `include='all' or leave it unset`"
            raise ValueError(msg)
        if self.exclude:
            self.include = "all"

    def copy_with(
        self,
        purpose: Union[Purpose, type[DTOUnset]] = DTOUnset,
        include: Optional[IncludeFields] = None,
        exclude: Optional[ExcludeFields] = None,
        partial: Union[bool, None, type[DTOUnset]] = DTOUnset,
        unset_sentinel: Union[Any, type[DTOUnset]] = DTOUnset,
        type_overrides: Union[Mapping[Any, Any], type[DTOUnset]] = DTOUnset,
        annotation_overrides: Union[dict[str, Any], type[DTOUnset]] = DTOUnset,
        aliases: Union[Mapping[str, str], type[DTOUnset]] = DTOUnset,
        exclude_defaults: Union[bool, type[DTOUnset]] = DTOUnset,
        alias_generator: Union[Callable[[str], str], type[DTOUnset]] = DTOUnset,
        partial_default: Union[Any, type[DTOUnset]] = DTOUnset,
        scope: Union[DTOScope, type[DTOUnset]] = DTOUnset,
        exclude_from_scope: Union[bool, type[DTOUnset]] = DTOUnset,
        tags: Union[set[str], type[DTOUnset]] = DTOUnset,
    ) -> DTOConfig:
        """Create a copy of the DTOConfig with the specified changes."""
        if include is None and exclude is None:
            include, exclude = self.include, self.exclude
        else:
            include = include or []
            exclude = exclude or []
        return DTOConfig(
            include=include,
            exclude=exclude,
            purpose=self.purpose if purpose is DTOUnset else purpose,
            partial=self.partial if partial is DTOUnset else partial,
            unset_sentinel=self.unset_sentinel if unset_sentinel is DTOUnset else unset_sentinel,
            type_overrides=self.type_overrides if type_overrides is DTOUnset else type_overrides,
            annotation_overrides=self.annotation_overrides
            if annotation_overrides is DTOUnset
            else annotation_overrides,
            aliases=self.aliases if aliases is DTOUnset else aliases,
            exclude_defaults=self.exclude_defaults if exclude_defaults is DTOUnset else exclude_defaults,
            alias_generator=self.alias_generator if alias_generator is DTOUnset else alias_generator,
            partial_default=self.partial_default if partial_default is DTOUnset else partial_default,
            scope=self.scope if scope is DTOUnset else scope,
            exclude_from_scope=self.exclude_from_scope if exclude_from_scope is DTOUnset else exclude_from_scope,
            tags=self.tags if tags is DTOUnset else tags,
        )

    def with_base_annotations(self, base: type[Any]) -> DTOConfig:
        """Merge type annotations from a base class into this DTOConfig.

        Args:
            base: The base class to extract type annotations from

        Returns:
            A new DTOConfig instance with:
            - Type annotations from the base class merged into annotation_overrides
            - Updated include set to include all fields if exclude is specified or include was "all"

        The method handles two cases:
        1. When include is "all" or exclude is specified: All fields from the base class are included
        2. When specific fields are included: Only those fields are added to the include set
        """
        include: set[str] = set(self.include) if self.include != "all" else set()
        include_all = self.include == "all" or self.exclude
        annotation_overrides: dict[str, Any] = self.annotation_overrides
        try:
            base_annotations = get_type_hints(base, include_extras=True)
        except NameError:
            base_annotations = get_annotations(base)
        for name, annotation in base_annotations.items():
            if not include_all:
                include.add(name)
            annotation_overrides[name] = annotation
        return dataclasses.replace(
            self,
            include="all" if include_all else include,
            annotation_overrides=annotation_overrides,
        )

    def alias(self, name: str) -> Optional[str]:
        if self.aliases:
            return self.aliases.get(name)
        if self.alias_generator is not None:
            return self.alias_generator(name)
        return None
