# Copyright (c) 2017 ETH Zurich, Cosmology Research Group
"""
Created on Jul 31, 2017
@author: Joerg Herbel
"""

from concurrent.futures import ThreadPoolExecutor

import numba as nb
import numpy as np

# Gauss-Legendre nodes and weights
# Generated by http://keisan.casio.com/has10/SpecExec.cgi?id=system/2006/1280624821
GAUSS_LEGENDRE_NODES = np.array(
    [0.5 - 0.7745966692414833770359 / 2, 0.5, 0.5 + 0.7745966692414833770359 / 2],
    dtype=np.float32,
)

GAUSS_LEGENDRE_WEIGHTS = np.array(
    [
        0.555555555555555555556 / 2,
        0.8888888888888888888889 / 2,
        0.555555555555555555556 / 2,
    ],
    dtype=np.float32,
)

GAUSS_LEGENDRE_WEIGHTS_2D = np.outer(GAUSS_LEGENDRE_WEIGHTS, GAUSS_LEGENDRE_WEIGHTS)


def rng_buffer():
    buffer = np.random.randint(0, 1 << 32, size=(44497,)).astype(np.uint32)
    return buffer


@nb.jit(nopython=True)
def sin_cos_table():
    r = (
        np.arange(0, (1 << 11) + 1).astype(np.float64)
        * 2.0
        * np.pi
        / np.float64(1 << 11)
    )
    sin_table = np.sin(r)
    cos_table = np.cos(r)
    return sin_table, cos_table


def compute_ellip_matrices(size, e1, e2):
    """
    size can either be the PSF fwhm or the intrinsic galaxy r50
    """

    m = np.empty((len(size), 2, 2))
    m[:, 0, 0] = 1
    m[:, 0, 1] = 0
    m[:, 1, 0] = 0
    m[:, 1, 1] = 1

    e = np.sqrt(e1**2 + e2**2)
    mask_e = e > 1e-7

    m[mask_e, 0, 0] = np.sqrt(
        (1.0 + e[mask_e]) * (1.0 + e1[mask_e] / e[mask_e]) / 2.0
    ) * np.copysign(1.0, e2[mask_e])
    m[mask_e, 0, 1] = np.sqrt((1.0 - e[mask_e]) * (1.0 - e1[mask_e] / e[mask_e]) / 2.0)
    m[mask_e, 1, 0] = np.sqrt((1.0 + e[mask_e]) * (1.0 - e1[mask_e] / e[mask_e]) / 2.0)
    m[mask_e, 1, 1] = np.sqrt(
        (1.0 - e[mask_e]) * (1.0 + e1[mask_e] / e[mask_e]) / 2.0
    ) * np.copysign(1.0, e2[mask_e])

    m *= size[:, None, None]

    return m


def compute_flexion_tensors(fwhm, f1, f2, g1, g2):
    d = np.zeros((len(fwhm), 2, 2, 2))

    d[:, 0, 0, 0] = 3 * f1 + g1
    d[:, 0, 1, 0] = 2 * (f2 + g2)
    # we deliberately do not compute this entry, since it equals d[:, 0, 1, 0];
    # instead, we use d[:, 0, 1, 0] = d[:, 0, 1, 0] + d[:, 0, 0, 1]
    # d[:, 0, 0, 1] = f2 + g2
    d[:, 0, 1, 1] = f1 - g1

    d[:, 1, 0, 0] = f2 + g2
    d[:, 1, 1, 0] = 2 * (f1 - g1)
    # see comment for d[:, 0, 0, 1]
    # d[:, 1, 0, 1] = f1 - g1
    d[:, 1, 1, 1] = 3 * f2 - g2

    d *= -0.5 * fwhm[:, None, None, None]

    return d


def compute_kurtoses(fwhm, kurtoses, beta):
    k = kurtoses[:, np.newaxis] / beta * fwhm[:, np.newaxis]
    return k


@nb.jit(nopython=True)
def psf_flexion_suppression(beta, flexion_suppression):
    suppress_factor = flexion_suppression / beta**2.0
    return suppress_factor


@nb.jit(nopython=True)
def psf_kurtosis_suppression(beta):
    suppress_factor = -12.5 / beta**2.0
    return suppress_factor


def distribute_photons_psf_profiles(nphot, n_profiles, flux_ratio):
    nphot_split = np.zeros((len(nphot), n_profiles), dtype=np.int64)
    flux_ratio_clip = np.clip(flux_ratio, a_min=0, a_max=1)
    nphot_split[:, 0] = np.array(np.round(flux_ratio_clip * nphot), dtype=np.int64)

    for i in range(1, n_profiles):
        nphot_split[:, i] = nphot - nphot_split[:, i - 1]

    return nphot_split


@nb.jit(nopython=True)
def moffat_cdf_factors(psf_beta):
    alpha_by_fwhm = 1.0 / (2.0 * np.sqrt(2.0 ** (1.0 / psf_beta) - 1.0))
    beta_power = 1.0 / (1.0 - psf_beta)
    return alpha_by_fwhm, beta_power


@nb.jit(nopython=True)
def draw_photon_psf_radial(
    rng_buffer, sin_table, cos_table, rng, alpha_by_fwhm, beta_power
):
    # sin/cos
    scL = rng_buffer[rng] >> (32 - 11)
    scB = np.float64(rng_buffer[rng] & np.uint32((1 << (32 - 11)) - 1)) / np.float64(
        1 << (32 - 11)
    )
    scA = 1.0 - scB
    sn = scA * sin_table[scL] + scB * sin_table[scL + 1]
    cn = scA * cos_table[scL] + scB * cos_table[scL + 1]

    # dr
    cdf = np.float64(
        rng_buffer[rng + 1] & np.uint32((1 << (32 - 11)) - 1)
    ) / np.float64(1 << (32 - 11))
    dr = alpha_by_fwhm * np.sqrt((1 - cdf) ** beta_power - 1)

    return dr, sn, cn


@nb.jit(nopython=True)
def draw_photon_psf(
    rng_buffer,
    sin_table,
    cos_table,
    alpha_by_fwhm,
    beta_power,
    rng,
    ellip_matrix,
    flexion_tensor,
    kurtosis,
    flexion_suppression,
    kurtosis_suppression,
    dx_offset,
    dy_offset,
):
    dr, sn, cn = draw_photon_psf_radial(
        rng_buffer, sin_table, cos_table, rng, alpha_by_fwhm, beta_power
    )

    # update position
    x_phot_circ = dr * cn
    y_phot_circ = dr * sn

    # ellipticity
    dx = ellip_matrix[0, 0] * x_phot_circ - ellip_matrix[0, 1] * y_phot_circ
    dy = ellip_matrix[1, 0] * x_phot_circ + ellip_matrix[1, 1] * y_phot_circ

    # flexion
    x_phot_circ_sq = x_phot_circ**2
    y_phot_circ_sq = y_phot_circ**2
    r_phot_sq = x_phot_circ_sq + y_phot_circ_sq
    x_phot_y_phot_circ = x_phot_circ * y_phot_circ

    flexion_suppress = np.exp(flexion_suppression * r_phot_sq)

    dx += (
        flexion_tensor[0, 0, 0] * x_phot_circ_sq
        + flexion_tensor[0, 1, 0] * x_phot_y_phot_circ
        + flexion_tensor[0, 1, 1] * y_phot_circ_sq
    ) * flexion_suppress

    dy += (
        flexion_tensor[1, 0, 0] * x_phot_circ_sq
        + flexion_tensor[1, 1, 0] * x_phot_y_phot_circ
        + flexion_tensor[1, 1, 1] * y_phot_circ_sq
    ) * flexion_suppress

    # kurtosis
    kurtosis_suppress = np.exp(kurtosis_suppression * r_phot_sq)
    dx += (kurtosis * r_phot_sq * x_phot_circ) * kurtosis_suppress
    dy += (kurtosis * r_phot_sq * y_phot_circ) * kurtosis_suppress

    # Offset between multiple profiles
    dx += dx_offset
    dy += dy_offset

    return dr, dx, dy


@nb.jit(nopython=True)
def draw_photon_gal(
    rng_buffer,
    sin_table,
    cos_table,
    gammaprecision,
    gammaprecisionhigh,
    intrinsic_sersic_l,
    intrinsic_sersic_b,
    intrinsic_table,
    rng,
    ellip_matrix,
):
    # sin/cos
    scL = rng_buffer[rng + 2] >> (32 - 11)
    scB = np.float64(
        rng_buffer[rng + 2] & np.uint32((1 << (32 - 11)) - 1)
    ) / np.float64(1 << (32 - 11))
    scA = 1.0 - scB
    sn = scA * sin_table[scL] + scB * sin_table[scL + 1]
    cn = scA * cos_table[scL] + scB * cos_table[scL + 1]

    # dr
    drMask = (
        rng_buffer[rng + 3] >> (32 - gammaprecisionhigh)
        == (1 << gammaprecisionhigh) - 1
    )
    drK = rng_buffer[rng + 3] << np.uint32(drMask * gammaprecisionhigh)
    drL = ((drK >> (32 - gammaprecision)) & ((1 << gammaprecision) - 1)) + np.uint32(
        drMask * (1 << gammaprecision)
    )
    drB = np.float64(
        rng_buffer[rng + 3]
        & ((1 << (32 - gammaprecision - np.uint32(drMask * gammaprecisionhigh))) - 1)
    ) / np.float64(1 << (32 - gammaprecision - np.uint32(drMask * gammaprecisionhigh)))
    drA = 1.0 - drB

    nL = intrinsic_sersic_l
    nB = intrinsic_sersic_b
    nA = 1 - nB

    dr = drA * (
        nA * intrinsic_table[nL, drL] + nB * intrinsic_table[nL + 1, drL]
    ) + drB * (
        nA * intrinsic_table[nL, drL + 1] + nB * intrinsic_table[nL + 1, drL + 1]
    )

    dx = dr * (cn * ellip_matrix[0, 0] - sn * ellip_matrix[0, 1])
    dy = dr * (cn * ellip_matrix[1, 0] + sn * ellip_matrix[1, 1])

    return dx, dy


@nb.jit(nopython=True)
def add_photon(image, x, y, dx, dy):
    """
    Add one photon to image.

    :param image: image
    :param x: centroid x-position
    :param y: centroid y-position
    :param dx: x-coordinate sampled from light profile
    :param dy: y-coordinate sampled from light profile
    :return:
    """
    x_dx = x + dx
    y_dy = y + dy
    if 0 <= x_dx < image.shape[1] and 0 <= y_dy < image.shape[0]:
        image[np.int32(y_dy), np.int32(x_dx)] += 1


@nb.jit(nopython=True)
def integrate_pixel_psf(
    alpha_sq,
    beta,
    r50,
    e1,
    e2,
    dx_offset,
    dy_offset,
    nphot,
    min_x,
    max_x,
    min_y,
    max_y,
    offset_x,
    offset_y,
    mean,
):
    e1_plus = 1 + e1
    e1_minus = 1 - e1
    e2_2 = 2 * e2
    normalization_sq = 1 - (e1**2 + e2**2)

    r50_sq = r50**2
    r50_sq_alpha_sq = r50_sq * alpha_sq
    fac = (beta - 1) / np.sqrt(normalization_sq) / (np.pi * r50_sq_alpha_sq)

    for x in range(min_x, max_x + 1):
        xdiff = x - offset_x

        for y in range(min_y, max_y + 1):
            density = 0.0
            ydiff = y - offset_y

            for beta_ind in range(len(beta)):
                for xi in range(0, len(GAUSS_LEGENDRE_WEIGHTS)):
                    x_centered = xdiff + GAUSS_LEGENDRE_NODES[xi] - dx_offset[beta_ind]
                    x_centered_e1 = x_centered**2 * e1_minus
                    x_centered_e2_2 = e2_2 * x_centered

                    for yi in range(0, len(GAUSS_LEGENDRE_WEIGHTS)):
                        y_centered = (
                            ydiff + GAUSS_LEGENDRE_NODES[yi] - dy_offset[beta_ind]
                        )
                        dr_sq = (
                            x_centered_e1
                            + y_centered**2 * e1_plus
                            - x_centered_e2_2 * y_centered
                        ) / normalization_sq
                        density += (
                            nphot[beta_ind]
                            * GAUSS_LEGENDRE_WEIGHTS_2D[yi, xi]
                            * fac[beta_ind]
                            * (1 + dr_sq / r50_sq_alpha_sq[beta_ind])
                            ** (-beta[beta_ind])
                        )

            mean[y - min_y, x - min_x] = np.random.poisson(density)

    return mean


def split_array(arr, n_split):
    x_sort_ind = np.argsort(arr)
    ind_split = np.linspace(0, len(arr), num=n_split + 1, dtype=np.int32)

    indices_split = [None] * n_split
    for i_split in range(n_split):
        indices_split[i_split] = x_sort_ind[ind_split[i_split] : ind_split[i_split + 1]]

    return indices_split


def execute_threaded(func, n_threads, *args):
    with ThreadPoolExecutor(max_workers=n_threads) as executor:
        executor.map(func, *args)
